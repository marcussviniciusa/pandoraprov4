
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Office
 * 
 */
export type Office = $Result.DefaultSelection<Prisma.$OfficePayload>
/**
 * Model WhatsappConfig
 * 
 */
export type WhatsappConfig = $Result.DefaultSelection<Prisma.$WhatsappConfigPayload>
/**
 * Model WhatsAppInstance
 * 
 */
export type WhatsAppInstance = $Result.DefaultSelection<Prisma.$WhatsAppInstancePayload>
/**
 * Model WhatsAppContact
 * 
 */
export type WhatsAppContact = $Result.DefaultSelection<Prisma.$WhatsAppContactPayload>
/**
 * Model WhatsAppConversation
 * 
 */
export type WhatsAppConversation = $Result.DefaultSelection<Prisma.$WhatsAppConversationPayload>
/**
 * Model WhatsAppMessage
 * 
 */
export type WhatsAppMessage = $Result.DefaultSelection<Prisma.$WhatsAppMessagePayload>
/**
 * Model WhatsAppImport
 * 
 */
export type WhatsAppImport = $Result.DefaultSelection<Prisma.$WhatsAppImportPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model AudioTranscription
 * 
 */
export type AudioTranscription = $Result.DefaultSelection<Prisma.$AudioTranscriptionPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ClientTag
 * 
 */
export type ClientTag = $Result.DefaultSelection<Prisma.$ClientTagPayload>
/**
 * Model ConversationTag
 * 
 */
export type ConversationTag = $Result.DefaultSelection<Prisma.$ConversationTagPayload>
/**
 * Model CustomStatus
 * 
 */
export type CustomStatus = $Result.DefaultSelection<Prisma.$CustomStatusPayload>
/**
 * Model ConversationCustomStatus
 * 
 */
export type ConversationCustomStatus = $Result.DefaultSelection<Prisma.$ConversationCustomStatusPayload>
/**
 * Model AiAgent
 * 
 */
export type AiAgent = $Result.DefaultSelection<Prisma.$AiAgentPayload>
/**
 * Model AIProviderConfig
 * 
 */
export type AIProviderConfig = $Result.DefaultSelection<Prisma.$AIProviderConfigPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Tool
 * 
 */
export type Tool = $Result.DefaultSelection<Prisma.$ToolPayload>
/**
 * Model ToolExecution
 * 
 */
export type ToolExecution = $Result.DefaultSelection<Prisma.$ToolExecutionPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookExecution
 * 
 */
export type WebhookExecution = $Result.DefaultSelection<Prisma.$WebhookExecutionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model GlobalConfig
 * 
 */
export type GlobalConfig = $Result.DefaultSelection<Prisma.$GlobalConfigPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ConversationStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED',
  CLOSED: 'CLOSED'
};

export type ConversationStatus = (typeof ConversationStatus)[keyof typeof ConversationStatus]


export const MessageType: {
  TEXT: 'TEXT',
  AUDIO: 'AUDIO',
  IMAGE: 'IMAGE',
  DOCUMENT: 'DOCUMENT',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const AgentType: {
  RECEPTIONIST: 'RECEPTIONIST',
  PREVIDENCIARIO: 'PREVIDENCIARIO',
  BPC_LOAS: 'BPC_LOAS',
  TRABALHISTA: 'TRABALHISTA'
};

export type AgentType = (typeof AgentType)[keyof typeof AgentType]


export const AIProvider: {
  OPENAI: 'OPENAI',
  GOOGLE: 'GOOGLE',
  ANTHROPIC: 'ANTHROPIC'
};

export type AIProvider = (typeof AIProvider)[keyof typeof AIProvider]


export const AIModel: {
  GPT_4_1_MINI: 'GPT_4_1_MINI',
  GPT_4O_MINI: 'GPT_4O_MINI',
  GPT_4_5: 'GPT_4_5',
  GEMINI_2_5_PRO: 'GEMINI_2_5_PRO',
  CLAUDE_3_7: 'CLAUDE_3_7',
  CLAUDE_4: 'CLAUDE_4'
};

export type AIModel = (typeof AIModel)[keyof typeof AIModel]


export const TranscriptionProvider: {
  GOOGLE_SPEECH: 'GOOGLE_SPEECH',
  GROQ_WHISPER: 'GROQ_WHISPER',
  OPENAI_WHISPER: 'OPENAI_WHISPER'
};

export type TranscriptionProvider = (typeof TranscriptionProvider)[keyof typeof TranscriptionProvider]


export const ToolExecutionStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
  TIMEOUT: 'TIMEOUT'
};

export type ToolExecutionStatus = (typeof ToolExecutionStatus)[keyof typeof ToolExecutionStatus]


export const WhatsAppInstanceStatus: {
  CONNECTING: 'CONNECTING',
  CONNECTED: 'CONNECTED',
  DISCONNECTED: 'DISCONNECTED',
  ERROR: 'ERROR'
};

export type WhatsAppInstanceStatus = (typeof WhatsAppInstanceStatus)[keyof typeof WhatsAppInstanceStatus]


export const WhatsAppMessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  AUDIO: 'AUDIO',
  VIDEO: 'VIDEO',
  DOCUMENT: 'DOCUMENT',
  LOCATION: 'LOCATION',
  STICKER: 'STICKER',
  CONTACT: 'CONTACT',
  POLL: 'POLL'
};

export type WhatsAppMessageType = (typeof WhatsAppMessageType)[keyof typeof WhatsAppMessageType]


export const WhatsAppMessageStatus: {
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ',
  FAILED: 'FAILED',
  PENDING: 'PENDING'
};

export type WhatsAppMessageStatus = (typeof WhatsAppMessageStatus)[keyof typeof WhatsAppMessageStatus]


export const WhatsAppConversationStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  PENDING: 'PENDING',
  ARCHIVED: 'ARCHIVED'
};

export type WhatsAppConversationStatus = (typeof WhatsAppConversationStatus)[keyof typeof WhatsAppConversationStatus]


export const WhatsAppImportStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type WhatsAppImportStatus = (typeof WhatsAppImportStatus)[keyof typeof WhatsAppImportStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ConversationStatus = $Enums.ConversationStatus

export const ConversationStatus: typeof $Enums.ConversationStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type AgentType = $Enums.AgentType

export const AgentType: typeof $Enums.AgentType

export type AIProvider = $Enums.AIProvider

export const AIProvider: typeof $Enums.AIProvider

export type AIModel = $Enums.AIModel

export const AIModel: typeof $Enums.AIModel

export type TranscriptionProvider = $Enums.TranscriptionProvider

export const TranscriptionProvider: typeof $Enums.TranscriptionProvider

export type ToolExecutionStatus = $Enums.ToolExecutionStatus

export const ToolExecutionStatus: typeof $Enums.ToolExecutionStatus

export type WhatsAppInstanceStatus = $Enums.WhatsAppInstanceStatus

export const WhatsAppInstanceStatus: typeof $Enums.WhatsAppInstanceStatus

export type WhatsAppMessageType = $Enums.WhatsAppMessageType

export const WhatsAppMessageType: typeof $Enums.WhatsAppMessageType

export type WhatsAppMessageStatus = $Enums.WhatsAppMessageStatus

export const WhatsAppMessageStatus: typeof $Enums.WhatsAppMessageStatus

export type WhatsAppConversationStatus = $Enums.WhatsAppConversationStatus

export const WhatsAppConversationStatus: typeof $Enums.WhatsAppConversationStatus

export type WhatsAppImportStatus = $Enums.WhatsAppImportStatus

export const WhatsAppImportStatus: typeof $Enums.WhatsAppImportStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.office`: Exposes CRUD operations for the **Office** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offices
    * const offices = await prisma.office.findMany()
    * ```
    */
  get office(): Prisma.OfficeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsappConfig`: Exposes CRUD operations for the **WhatsappConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsappConfigs
    * const whatsappConfigs = await prisma.whatsappConfig.findMany()
    * ```
    */
  get whatsappConfig(): Prisma.WhatsappConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppInstance`: Exposes CRUD operations for the **WhatsAppInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppInstances
    * const whatsAppInstances = await prisma.whatsAppInstance.findMany()
    * ```
    */
  get whatsAppInstance(): Prisma.WhatsAppInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppContact`: Exposes CRUD operations for the **WhatsAppContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppContacts
    * const whatsAppContacts = await prisma.whatsAppContact.findMany()
    * ```
    */
  get whatsAppContact(): Prisma.WhatsAppContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppConversation`: Exposes CRUD operations for the **WhatsAppConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppConversations
    * const whatsAppConversations = await prisma.whatsAppConversation.findMany()
    * ```
    */
  get whatsAppConversation(): Prisma.WhatsAppConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppMessage`: Exposes CRUD operations for the **WhatsAppMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppMessages
    * const whatsAppMessages = await prisma.whatsAppMessage.findMany()
    * ```
    */
  get whatsAppMessage(): Prisma.WhatsAppMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppImport`: Exposes CRUD operations for the **WhatsAppImport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppImports
    * const whatsAppImports = await prisma.whatsAppImport.findMany()
    * ```
    */
  get whatsAppImport(): Prisma.WhatsAppImportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioTranscription`: Exposes CRUD operations for the **AudioTranscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioTranscriptions
    * const audioTranscriptions = await prisma.audioTranscription.findMany()
    * ```
    */
  get audioTranscription(): Prisma.AudioTranscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientTag`: Exposes CRUD operations for the **ClientTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientTags
    * const clientTags = await prisma.clientTag.findMany()
    * ```
    */
  get clientTag(): Prisma.ClientTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationTag`: Exposes CRUD operations for the **ConversationTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationTags
    * const conversationTags = await prisma.conversationTag.findMany()
    * ```
    */
  get conversationTag(): Prisma.ConversationTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customStatus`: Exposes CRUD operations for the **CustomStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomStatuses
    * const customStatuses = await prisma.customStatus.findMany()
    * ```
    */
  get customStatus(): Prisma.CustomStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationCustomStatus`: Exposes CRUD operations for the **ConversationCustomStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationCustomStatuses
    * const conversationCustomStatuses = await prisma.conversationCustomStatus.findMany()
    * ```
    */
  get conversationCustomStatus(): Prisma.ConversationCustomStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiAgent`: Exposes CRUD operations for the **AiAgent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiAgents
    * const aiAgents = await prisma.aiAgent.findMany()
    * ```
    */
  get aiAgent(): Prisma.AiAgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIProviderConfig`: Exposes CRUD operations for the **AIProviderConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIProviderConfigs
    * const aIProviderConfigs = await prisma.aIProviderConfig.findMany()
    * ```
    */
  get aIProviderConfig(): Prisma.AIProviderConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tool`: Exposes CRUD operations for the **Tool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tools
    * const tools = await prisma.tool.findMany()
    * ```
    */
  get tool(): Prisma.ToolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.toolExecution`: Exposes CRUD operations for the **ToolExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ToolExecutions
    * const toolExecutions = await prisma.toolExecution.findMany()
    * ```
    */
  get toolExecution(): Prisma.ToolExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookExecution`: Exposes CRUD operations for the **WebhookExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookExecutions
    * const webhookExecutions = await prisma.webhookExecution.findMany()
    * ```
    */
  get webhookExecution(): Prisma.WebhookExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.globalConfig`: Exposes CRUD operations for the **GlobalConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalConfigs
    * const globalConfigs = await prisma.globalConfig.findMany()
    * ```
    */
  get globalConfig(): Prisma.GlobalConfigDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Office: 'Office',
    WhatsappConfig: 'WhatsappConfig',
    WhatsAppInstance: 'WhatsAppInstance',
    WhatsAppContact: 'WhatsAppContact',
    WhatsAppConversation: 'WhatsAppConversation',
    WhatsAppMessage: 'WhatsAppMessage',
    WhatsAppImport: 'WhatsAppImport',
    Client: 'Client',
    Conversation: 'Conversation',
    Message: 'Message',
    AudioTranscription: 'AudioTranscription',
    Tag: 'Tag',
    ClientTag: 'ClientTag',
    ConversationTag: 'ConversationTag',
    CustomStatus: 'CustomStatus',
    ConversationCustomStatus: 'ConversationCustomStatus',
    AiAgent: 'AiAgent',
    AIProviderConfig: 'AIProviderConfig',
    Document: 'Document',
    Tool: 'Tool',
    ToolExecution: 'ToolExecution',
    Webhook: 'Webhook',
    WebhookExecution: 'WebhookExecution',
    AuditLog: 'AuditLog',
    GlobalConfig: 'GlobalConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "office" | "whatsappConfig" | "whatsAppInstance" | "whatsAppContact" | "whatsAppConversation" | "whatsAppMessage" | "whatsAppImport" | "client" | "conversation" | "message" | "audioTranscription" | "tag" | "clientTag" | "conversationTag" | "customStatus" | "conversationCustomStatus" | "aiAgent" | "aIProviderConfig" | "document" | "tool" | "toolExecution" | "webhook" | "webhookExecution" | "auditLog" | "globalConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Office: {
        payload: Prisma.$OfficePayload<ExtArgs>
        fields: Prisma.OfficeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfficeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfficeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>
          }
          findFirst: {
            args: Prisma.OfficeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfficeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>
          }
          findMany: {
            args: Prisma.OfficeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>[]
          }
          create: {
            args: Prisma.OfficeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>
          }
          createMany: {
            args: Prisma.OfficeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfficeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>[]
          }
          delete: {
            args: Prisma.OfficeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>
          }
          update: {
            args: Prisma.OfficeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>
          }
          deleteMany: {
            args: Prisma.OfficeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfficeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OfficeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>[]
          }
          upsert: {
            args: Prisma.OfficeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfficePayload>
          }
          aggregate: {
            args: Prisma.OfficeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffice>
          }
          groupBy: {
            args: Prisma.OfficeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfficeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfficeCountArgs<ExtArgs>
            result: $Utils.Optional<OfficeCountAggregateOutputType> | number
          }
        }
      }
      WhatsappConfig: {
        payload: Prisma.$WhatsappConfigPayload<ExtArgs>
        fields: Prisma.WhatsappConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsappConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsappConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>
          }
          findFirst: {
            args: Prisma.WhatsappConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsappConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>
          }
          findMany: {
            args: Prisma.WhatsappConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>[]
          }
          create: {
            args: Prisma.WhatsappConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>
          }
          createMany: {
            args: Prisma.WhatsappConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsappConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>[]
          }
          delete: {
            args: Prisma.WhatsappConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>
          }
          update: {
            args: Prisma.WhatsappConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>
          }
          deleteMany: {
            args: Prisma.WhatsappConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsappConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsappConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>[]
          }
          upsert: {
            args: Prisma.WhatsappConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappConfigPayload>
          }
          aggregate: {
            args: Prisma.WhatsappConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsappConfig>
          }
          groupBy: {
            args: Prisma.WhatsappConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsappConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsappConfigCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsappConfigCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppInstance: {
        payload: Prisma.$WhatsAppInstancePayload<ExtArgs>
        fields: Prisma.WhatsAppInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>
          }
          findFirst: {
            args: Prisma.WhatsAppInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>
          }
          findMany: {
            args: Prisma.WhatsAppInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>[]
          }
          create: {
            args: Prisma.WhatsAppInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>
          }
          createMany: {
            args: Prisma.WhatsAppInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>[]
          }
          delete: {
            args: Prisma.WhatsAppInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>
          }
          update: {
            args: Prisma.WhatsAppInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppInstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppInstancePayload>
          }
          aggregate: {
            args: Prisma.WhatsAppInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppInstance>
          }
          groupBy: {
            args: Prisma.WhatsAppInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppInstanceCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppContact: {
        payload: Prisma.$WhatsAppContactPayload<ExtArgs>
        fields: Prisma.WhatsAppContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          findMany: {
            args: Prisma.WhatsAppContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>[]
          }
          create: {
            args: Prisma.WhatsAppContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          createMany: {
            args: Prisma.WhatsAppContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          update: {
            args: Prisma.WhatsAppContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppContactPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppContact>
          }
          groupBy: {
            args: Prisma.WhatsAppContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppContactCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppContactCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppConversation: {
        payload: Prisma.$WhatsAppConversationPayload<ExtArgs>
        fields: Prisma.WhatsAppConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
          }
          findMany: {
            args: Prisma.WhatsAppConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>[]
          }
          create: {
            args: Prisma.WhatsAppConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
          }
          createMany: {
            args: Prisma.WhatsAppConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
          }
          update: {
            args: Prisma.WhatsAppConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppConversationPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppConversation>
          }
          groupBy: {
            args: Prisma.WhatsAppConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppConversationCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppConversationCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppMessage: {
        payload: Prisma.$WhatsAppMessagePayload<ExtArgs>
        fields: Prisma.WhatsAppMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
          }
          findFirst: {
            args: Prisma.WhatsAppMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
          }
          findMany: {
            args: Prisma.WhatsAppMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>[]
          }
          create: {
            args: Prisma.WhatsAppMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
          }
          createMany: {
            args: Prisma.WhatsAppMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>[]
          }
          delete: {
            args: Prisma.WhatsAppMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
          }
          update: {
            args: Prisma.WhatsAppMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessagePayload>
          }
          aggregate: {
            args: Prisma.WhatsAppMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppMessage>
          }
          groupBy: {
            args: Prisma.WhatsAppMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppMessageCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppMessageCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppImport: {
        payload: Prisma.$WhatsAppImportPayload<ExtArgs>
        fields: Prisma.WhatsAppImportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppImportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppImportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppImportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppImportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>
          }
          findMany: {
            args: Prisma.WhatsAppImportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>[]
          }
          create: {
            args: Prisma.WhatsAppImportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>
          }
          createMany: {
            args: Prisma.WhatsAppImportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppImportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppImportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>
          }
          update: {
            args: Prisma.WhatsAppImportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppImportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppImportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppImportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppImportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppImportPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppImportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppImport>
          }
          groupBy: {
            args: Prisma.WhatsAppImportGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppImportGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppImportCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppImportCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      AudioTranscription: {
        payload: Prisma.$AudioTranscriptionPayload<ExtArgs>
        fields: Prisma.AudioTranscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioTranscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioTranscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>
          }
          findFirst: {
            args: Prisma.AudioTranscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioTranscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>
          }
          findMany: {
            args: Prisma.AudioTranscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>[]
          }
          create: {
            args: Prisma.AudioTranscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>
          }
          createMany: {
            args: Prisma.AudioTranscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioTranscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>[]
          }
          delete: {
            args: Prisma.AudioTranscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>
          }
          update: {
            args: Prisma.AudioTranscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>
          }
          deleteMany: {
            args: Prisma.AudioTranscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioTranscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudioTranscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>[]
          }
          upsert: {
            args: Prisma.AudioTranscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTranscriptionPayload>
          }
          aggregate: {
            args: Prisma.AudioTranscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioTranscription>
          }
          groupBy: {
            args: Prisma.AudioTranscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioTranscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioTranscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<AudioTranscriptionCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ClientTag: {
        payload: Prisma.$ClientTagPayload<ExtArgs>
        fields: Prisma.ClientTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>
          }
          findFirst: {
            args: Prisma.ClientTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>
          }
          findMany: {
            args: Prisma.ClientTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>[]
          }
          create: {
            args: Prisma.ClientTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>
          }
          createMany: {
            args: Prisma.ClientTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>[]
          }
          delete: {
            args: Prisma.ClientTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>
          }
          update: {
            args: Prisma.ClientTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>
          }
          deleteMany: {
            args: Prisma.ClientTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>[]
          }
          upsert: {
            args: Prisma.ClientTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientTagPayload>
          }
          aggregate: {
            args: Prisma.ClientTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientTag>
          }
          groupBy: {
            args: Prisma.ClientTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientTagCountArgs<ExtArgs>
            result: $Utils.Optional<ClientTagCountAggregateOutputType> | number
          }
        }
      }
      ConversationTag: {
        payload: Prisma.$ConversationTagPayload<ExtArgs>
        fields: Prisma.ConversationTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>
          }
          findFirst: {
            args: Prisma.ConversationTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>
          }
          findMany: {
            args: Prisma.ConversationTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>[]
          }
          create: {
            args: Prisma.ConversationTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>
          }
          createMany: {
            args: Prisma.ConversationTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>[]
          }
          delete: {
            args: Prisma.ConversationTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>
          }
          update: {
            args: Prisma.ConversationTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>
          }
          deleteMany: {
            args: Prisma.ConversationTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>[]
          }
          upsert: {
            args: Prisma.ConversationTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationTagPayload>
          }
          aggregate: {
            args: Prisma.ConversationTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationTag>
          }
          groupBy: {
            args: Prisma.ConversationTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationTagCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationTagCountAggregateOutputType> | number
          }
        }
      }
      CustomStatus: {
        payload: Prisma.$CustomStatusPayload<ExtArgs>
        fields: Prisma.CustomStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>
          }
          findFirst: {
            args: Prisma.CustomStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>
          }
          findMany: {
            args: Prisma.CustomStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>[]
          }
          create: {
            args: Prisma.CustomStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>
          }
          createMany: {
            args: Prisma.CustomStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>[]
          }
          delete: {
            args: Prisma.CustomStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>
          }
          update: {
            args: Prisma.CustomStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>
          }
          deleteMany: {
            args: Prisma.CustomStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>[]
          }
          upsert: {
            args: Prisma.CustomStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomStatusPayload>
          }
          aggregate: {
            args: Prisma.CustomStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomStatus>
          }
          groupBy: {
            args: Prisma.CustomStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomStatusCountArgs<ExtArgs>
            result: $Utils.Optional<CustomStatusCountAggregateOutputType> | number
          }
        }
      }
      ConversationCustomStatus: {
        payload: Prisma.$ConversationCustomStatusPayload<ExtArgs>
        fields: Prisma.ConversationCustomStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationCustomStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationCustomStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>
          }
          findFirst: {
            args: Prisma.ConversationCustomStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationCustomStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>
          }
          findMany: {
            args: Prisma.ConversationCustomStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>[]
          }
          create: {
            args: Prisma.ConversationCustomStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>
          }
          createMany: {
            args: Prisma.ConversationCustomStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCustomStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>[]
          }
          delete: {
            args: Prisma.ConversationCustomStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>
          }
          update: {
            args: Prisma.ConversationCustomStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>
          }
          deleteMany: {
            args: Prisma.ConversationCustomStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationCustomStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationCustomStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>[]
          }
          upsert: {
            args: Prisma.ConversationCustomStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationCustomStatusPayload>
          }
          aggregate: {
            args: Prisma.ConversationCustomStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationCustomStatus>
          }
          groupBy: {
            args: Prisma.ConversationCustomStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationCustomStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCustomStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCustomStatusCountAggregateOutputType> | number
          }
        }
      }
      AiAgent: {
        payload: Prisma.$AiAgentPayload<ExtArgs>
        fields: Prisma.AiAgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiAgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiAgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          findFirst: {
            args: Prisma.AiAgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiAgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          findMany: {
            args: Prisma.AiAgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          create: {
            args: Prisma.AiAgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          createMany: {
            args: Prisma.AiAgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiAgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          delete: {
            args: Prisma.AiAgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          update: {
            args: Prisma.AiAgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          deleteMany: {
            args: Prisma.AiAgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiAgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiAgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>[]
          }
          upsert: {
            args: Prisma.AiAgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiAgentPayload>
          }
          aggregate: {
            args: Prisma.AiAgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiAgent>
          }
          groupBy: {
            args: Prisma.AiAgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiAgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiAgentCountArgs<ExtArgs>
            result: $Utils.Optional<AiAgentCountAggregateOutputType> | number
          }
        }
      }
      AIProviderConfig: {
        payload: Prisma.$AIProviderConfigPayload<ExtArgs>
        fields: Prisma.AIProviderConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIProviderConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIProviderConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>
          }
          findFirst: {
            args: Prisma.AIProviderConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIProviderConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>
          }
          findMany: {
            args: Prisma.AIProviderConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>[]
          }
          create: {
            args: Prisma.AIProviderConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>
          }
          createMany: {
            args: Prisma.AIProviderConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIProviderConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>[]
          }
          delete: {
            args: Prisma.AIProviderConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>
          }
          update: {
            args: Prisma.AIProviderConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>
          }
          deleteMany: {
            args: Prisma.AIProviderConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIProviderConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIProviderConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>[]
          }
          upsert: {
            args: Prisma.AIProviderConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderConfigPayload>
          }
          aggregate: {
            args: Prisma.AIProviderConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIProviderConfig>
          }
          groupBy: {
            args: Prisma.AIProviderConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIProviderConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIProviderConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AIProviderConfigCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Tool: {
        payload: Prisma.$ToolPayload<ExtArgs>
        fields: Prisma.ToolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ToolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ToolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>
          }
          findFirst: {
            args: Prisma.ToolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ToolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>
          }
          findMany: {
            args: Prisma.ToolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>[]
          }
          create: {
            args: Prisma.ToolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>
          }
          createMany: {
            args: Prisma.ToolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ToolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>[]
          }
          delete: {
            args: Prisma.ToolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>
          }
          update: {
            args: Prisma.ToolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>
          }
          deleteMany: {
            args: Prisma.ToolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ToolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ToolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>[]
          }
          upsert: {
            args: Prisma.ToolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolPayload>
          }
          aggregate: {
            args: Prisma.ToolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTool>
          }
          groupBy: {
            args: Prisma.ToolGroupByArgs<ExtArgs>
            result: $Utils.Optional<ToolGroupByOutputType>[]
          }
          count: {
            args: Prisma.ToolCountArgs<ExtArgs>
            result: $Utils.Optional<ToolCountAggregateOutputType> | number
          }
        }
      }
      ToolExecution: {
        payload: Prisma.$ToolExecutionPayload<ExtArgs>
        fields: Prisma.ToolExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ToolExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ToolExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>
          }
          findFirst: {
            args: Prisma.ToolExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ToolExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>
          }
          findMany: {
            args: Prisma.ToolExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>[]
          }
          create: {
            args: Prisma.ToolExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>
          }
          createMany: {
            args: Prisma.ToolExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ToolExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>[]
          }
          delete: {
            args: Prisma.ToolExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>
          }
          update: {
            args: Prisma.ToolExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>
          }
          deleteMany: {
            args: Prisma.ToolExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ToolExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ToolExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>[]
          }
          upsert: {
            args: Prisma.ToolExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ToolExecutionPayload>
          }
          aggregate: {
            args: Prisma.ToolExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToolExecution>
          }
          groupBy: {
            args: Prisma.ToolExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ToolExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ToolExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<ToolExecutionCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookExecution: {
        payload: Prisma.$WebhookExecutionPayload<ExtArgs>
        fields: Prisma.WebhookExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>
          }
          findFirst: {
            args: Prisma.WebhookExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>
          }
          findMany: {
            args: Prisma.WebhookExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>[]
          }
          create: {
            args: Prisma.WebhookExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>
          }
          createMany: {
            args: Prisma.WebhookExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>[]
          }
          delete: {
            args: Prisma.WebhookExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>
          }
          update: {
            args: Prisma.WebhookExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>
          }
          deleteMany: {
            args: Prisma.WebhookExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>[]
          }
          upsert: {
            args: Prisma.WebhookExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookExecutionPayload>
          }
          aggregate: {
            args: Prisma.WebhookExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookExecution>
          }
          groupBy: {
            args: Prisma.WebhookExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookExecutionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      GlobalConfig: {
        payload: Prisma.$GlobalConfigPayload<ExtArgs>
        fields: Prisma.GlobalConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          findFirst: {
            args: Prisma.GlobalConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          findMany: {
            args: Prisma.GlobalConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>[]
          }
          create: {
            args: Prisma.GlobalConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          createMany: {
            args: Prisma.GlobalConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>[]
          }
          delete: {
            args: Prisma.GlobalConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          update: {
            args: Prisma.GlobalConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          deleteMany: {
            args: Prisma.GlobalConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GlobalConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>[]
          }
          upsert: {
            args: Prisma.GlobalConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalConfigPayload>
          }
          aggregate: {
            args: Prisma.GlobalConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalConfig>
          }
          groupBy: {
            args: Prisma.GlobalConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalConfigCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    office?: OfficeOmit
    whatsappConfig?: WhatsappConfigOmit
    whatsAppInstance?: WhatsAppInstanceOmit
    whatsAppContact?: WhatsAppContactOmit
    whatsAppConversation?: WhatsAppConversationOmit
    whatsAppMessage?: WhatsAppMessageOmit
    whatsAppImport?: WhatsAppImportOmit
    client?: ClientOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    audioTranscription?: AudioTranscriptionOmit
    tag?: TagOmit
    clientTag?: ClientTagOmit
    conversationTag?: ConversationTagOmit
    customStatus?: CustomStatusOmit
    conversationCustomStatus?: ConversationCustomStatusOmit
    aiAgent?: AiAgentOmit
    aIProviderConfig?: AIProviderConfigOmit
    document?: DocumentOmit
    tool?: ToolOmit
    toolExecution?: ToolExecutionOmit
    webhook?: WebhookOmit
    webhookExecution?: WebhookExecutionOmit
    auditLog?: AuditLogOmit
    globalConfig?: GlobalConfigOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdConversations: number
    assignedConversations: number
    messages: number
    logs: number
    sessions: number
    toolsCreated: number
    whatsappInstancesCreated: number
    whatsappImportsUploaded: number
    whatsappConversationsAssigned: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdConversations?: boolean | UserCountOutputTypeCountCreatedConversationsArgs
    assignedConversations?: boolean | UserCountOutputTypeCountAssignedConversationsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    toolsCreated?: boolean | UserCountOutputTypeCountToolsCreatedArgs
    whatsappInstancesCreated?: boolean | UserCountOutputTypeCountWhatsappInstancesCreatedArgs
    whatsappImportsUploaded?: boolean | UserCountOutputTypeCountWhatsappImportsUploadedArgs
    whatsappConversationsAssigned?: boolean | UserCountOutputTypeCountWhatsappConversationsAssignedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountToolsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToolWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsappInstancesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppInstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsappImportsUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppImportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsappConversationsAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppConversationWhereInput
  }


  /**
   * Count Type OfficeCountOutputType
   */

  export type OfficeCountOutputType = {
    users: number
    clients: number
    conversations: number
    tags: number
    customStatuses: number
    aiAgents: number
    whatsappConfigs: number
    documents: number
    tools: number
    webhooks: number
    auditLogs: number
    aiConfigs: number
    whatsappInstances: number
  }

  export type OfficeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OfficeCountOutputTypeCountUsersArgs
    clients?: boolean | OfficeCountOutputTypeCountClientsArgs
    conversations?: boolean | OfficeCountOutputTypeCountConversationsArgs
    tags?: boolean | OfficeCountOutputTypeCountTagsArgs
    customStatuses?: boolean | OfficeCountOutputTypeCountCustomStatusesArgs
    aiAgents?: boolean | OfficeCountOutputTypeCountAiAgentsArgs
    whatsappConfigs?: boolean | OfficeCountOutputTypeCountWhatsappConfigsArgs
    documents?: boolean | OfficeCountOutputTypeCountDocumentsArgs
    tools?: boolean | OfficeCountOutputTypeCountToolsArgs
    webhooks?: boolean | OfficeCountOutputTypeCountWebhooksArgs
    auditLogs?: boolean | OfficeCountOutputTypeCountAuditLogsArgs
    aiConfigs?: boolean | OfficeCountOutputTypeCountAiConfigsArgs
    whatsappInstances?: boolean | OfficeCountOutputTypeCountWhatsappInstancesArgs
  }

  // Custom InputTypes
  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfficeCountOutputType
     */
    select?: OfficeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountCustomStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomStatusWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountAiAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAgentWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountWhatsappConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappConfigWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToolWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountWebhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountAiConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIProviderConfigWhereInput
  }

  /**
   * OfficeCountOutputType without action
   */
  export type OfficeCountOutputTypeCountWhatsappInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppInstanceWhereInput
  }


  /**
   * Count Type WhatsappConfigCountOutputType
   */

  export type WhatsappConfigCountOutputType = {
    conversations: number
    messages: number
  }

  export type WhatsappConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | WhatsappConfigCountOutputTypeCountConversationsArgs
    messages?: boolean | WhatsappConfigCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * WhatsappConfigCountOutputType without action
   */
  export type WhatsappConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfigCountOutputType
     */
    select?: WhatsappConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsappConfigCountOutputType without action
   */
  export type WhatsappConfigCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * WhatsappConfigCountOutputType without action
   */
  export type WhatsappConfigCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type WhatsAppInstanceCountOutputType
   */

  export type WhatsAppInstanceCountOutputType = {
    contacts: number
    conversations: number
    messages: number
    imports: number
  }

  export type WhatsAppInstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | WhatsAppInstanceCountOutputTypeCountContactsArgs
    conversations?: boolean | WhatsAppInstanceCountOutputTypeCountConversationsArgs
    messages?: boolean | WhatsAppInstanceCountOutputTypeCountMessagesArgs
    imports?: boolean | WhatsAppInstanceCountOutputTypeCountImportsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppInstanceCountOutputType without action
   */
  export type WhatsAppInstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstanceCountOutputType
     */
    select?: WhatsAppInstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppInstanceCountOutputType without action
   */
  export type WhatsAppInstanceCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppContactWhereInput
  }

  /**
   * WhatsAppInstanceCountOutputType without action
   */
  export type WhatsAppInstanceCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppConversationWhereInput
  }

  /**
   * WhatsAppInstanceCountOutputType without action
   */
  export type WhatsAppInstanceCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageWhereInput
  }

  /**
   * WhatsAppInstanceCountOutputType without action
   */
  export type WhatsAppInstanceCountOutputTypeCountImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppImportWhereInput
  }


  /**
   * Count Type WhatsAppContactCountOutputType
   */

  export type WhatsAppContactCountOutputType = {
    conversations: number
    messages: number
    imports: number
  }

  export type WhatsAppContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | WhatsAppContactCountOutputTypeCountConversationsArgs
    messages?: boolean | WhatsAppContactCountOutputTypeCountMessagesArgs
    imports?: boolean | WhatsAppContactCountOutputTypeCountImportsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppContactCountOutputType without action
   */
  export type WhatsAppContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContactCountOutputType
     */
    select?: WhatsAppContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppContactCountOutputType without action
   */
  export type WhatsAppContactCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppConversationWhereInput
  }

  /**
   * WhatsAppContactCountOutputType without action
   */
  export type WhatsAppContactCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageWhereInput
  }

  /**
   * WhatsAppContactCountOutputType without action
   */
  export type WhatsAppContactCountOutputTypeCountImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppImportWhereInput
  }


  /**
   * Count Type WhatsAppConversationCountOutputType
   */

  export type WhatsAppConversationCountOutputType = {
    messages: number
  }

  export type WhatsAppConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | WhatsAppConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppConversationCountOutputType without action
   */
  export type WhatsAppConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversationCountOutputType
     */
    select?: WhatsAppConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppConversationCountOutputType without action
   */
  export type WhatsAppConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    conversations: number
    documents: number
    clientTags: number
    whatsappContacts: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | ClientCountOutputTypeCountConversationsArgs
    documents?: boolean | ClientCountOutputTypeCountDocumentsArgs
    clientTags?: boolean | ClientCountOutputTypeCountClientTagsArgs
    whatsappContacts?: boolean | ClientCountOutputTypeCountWhatsappContactsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientTagWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountWhatsappContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppContactWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    conversationTags: number
    conversationStatus: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    conversationTags?: boolean | ConversationCountOutputTypeCountConversationTagsArgs
    conversationStatus?: boolean | ConversationCountOutputTypeCountConversationStatusArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountConversationTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationTagWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountConversationStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationCustomStatusWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    clientTags: number
    conversationTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientTags?: boolean | TagCountOutputTypeCountClientTagsArgs
    conversationTags?: boolean | TagCountOutputTypeCountConversationTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountClientTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountConversationTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationTagWhereInput
  }


  /**
   * Count Type CustomStatusCountOutputType
   */

  export type CustomStatusCountOutputType = {
    conversationStatuses: number
  }

  export type CustomStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversationStatuses?: boolean | CustomStatusCountOutputTypeCountConversationStatusesArgs
  }

  // Custom InputTypes
  /**
   * CustomStatusCountOutputType without action
   */
  export type CustomStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatusCountOutputType
     */
    select?: CustomStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomStatusCountOutputType without action
   */
  export type CustomStatusCountOutputTypeCountConversationStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationCustomStatusWhereInput
  }


  /**
   * Count Type AiAgentCountOutputType
   */

  export type AiAgentCountOutputType = {
    whatsappConversations: number
  }

  export type AiAgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappConversations?: boolean | AiAgentCountOutputTypeCountWhatsappConversationsArgs
  }

  // Custom InputTypes
  /**
   * AiAgentCountOutputType without action
   */
  export type AiAgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgentCountOutputType
     */
    select?: AiAgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiAgentCountOutputType without action
   */
  export type AiAgentCountOutputTypeCountWhatsappConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppConversationWhereInput
  }


  /**
   * Count Type ToolCountOutputType
   */

  export type ToolCountOutputType = {
    executions: number
  }

  export type ToolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | ToolCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * ToolCountOutputType without action
   */
  export type ToolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolCountOutputType
     */
    select?: ToolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ToolCountOutputType without action
   */
  export type ToolCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToolExecutionWhereInput
  }


  /**
   * Count Type ToolExecutionCountOutputType
   */

  export type ToolExecutionCountOutputType = {
    whatsappMessages: number
  }

  export type ToolExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappMessages?: boolean | ToolExecutionCountOutputTypeCountWhatsappMessagesArgs
  }

  // Custom InputTypes
  /**
   * ToolExecutionCountOutputType without action
   */
  export type ToolExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecutionCountOutputType
     */
    select?: ToolExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ToolExecutionCountOutputType without action
   */
  export type ToolExecutionCountOutputTypeCountWhatsappMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    executions: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | WebhookCountOutputTypeCountExecutionsArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookExecutionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    officeId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | User$officeArgs<ExtArgs>
    createdConversations?: boolean | User$createdConversationsArgs<ExtArgs>
    assignedConversations?: boolean | User$assignedConversationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    toolsCreated?: boolean | User$toolsCreatedArgs<ExtArgs>
    whatsappInstancesCreated?: boolean | User$whatsappInstancesCreatedArgs<ExtArgs>
    whatsappImportsUploaded?: boolean | User$whatsappImportsUploadedArgs<ExtArgs>
    whatsappConversationsAssigned?: boolean | User$whatsappConversationsAssignedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | User$officeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | User$officeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "isActive" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | User$officeArgs<ExtArgs>
    createdConversations?: boolean | User$createdConversationsArgs<ExtArgs>
    assignedConversations?: boolean | User$assignedConversationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    toolsCreated?: boolean | User$toolsCreatedArgs<ExtArgs>
    whatsappInstancesCreated?: boolean | User$whatsappInstancesCreatedArgs<ExtArgs>
    whatsappImportsUploaded?: boolean | User$whatsappImportsUploadedArgs<ExtArgs>
    whatsappConversationsAssigned?: boolean | User$whatsappConversationsAssignedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | User$officeArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | User$officeArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs> | null
      createdConversations: Prisma.$ConversationPayload<ExtArgs>[]
      assignedConversations: Prisma.$ConversationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      logs: Prisma.$AuditLogPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      toolsCreated: Prisma.$ToolPayload<ExtArgs>[]
      whatsappInstancesCreated: Prisma.$WhatsAppInstancePayload<ExtArgs>[]
      whatsappImportsUploaded: Prisma.$WhatsAppImportPayload<ExtArgs>[]
      whatsappConversationsAssigned: Prisma.$WhatsAppConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      officeId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends User$officeArgs<ExtArgs> = {}>(args?: Subset<T, User$officeArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdConversations<T extends User$createdConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedConversations<T extends User$assignedConversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toolsCreated<T extends User$toolsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$toolsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappInstancesCreated<T extends User$whatsappInstancesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsappInstancesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappImportsUploaded<T extends User$whatsappImportsUploadedArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsappImportsUploadedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappConversationsAssigned<T extends User$whatsappConversationsAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsappConversationsAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly officeId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.office
   */
  export type User$officeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    where?: OfficeWhereInput
  }

  /**
   * User.createdConversations
   */
  export type User$createdConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.assignedConversations
   */
  export type User$assignedConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.toolsCreated
   */
  export type User$toolsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    where?: ToolWhereInput
    orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[]
    cursor?: ToolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[]
  }

  /**
   * User.whatsappInstancesCreated
   */
  export type User$whatsappInstancesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    where?: WhatsAppInstanceWhereInput
    orderBy?: WhatsAppInstanceOrderByWithRelationInput | WhatsAppInstanceOrderByWithRelationInput[]
    cursor?: WhatsAppInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppInstanceScalarFieldEnum | WhatsAppInstanceScalarFieldEnum[]
  }

  /**
   * User.whatsappImportsUploaded
   */
  export type User$whatsappImportsUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    where?: WhatsAppImportWhereInput
    orderBy?: WhatsAppImportOrderByWithRelationInput | WhatsAppImportOrderByWithRelationInput[]
    cursor?: WhatsAppImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppImportScalarFieldEnum | WhatsAppImportScalarFieldEnum[]
  }

  /**
   * User.whatsappConversationsAssigned
   */
  export type User$whatsappConversationsAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    where?: WhatsAppConversationWhereInput
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    cursor?: WhatsAppConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppConversationScalarFieldEnum | WhatsAppConversationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Office
   */

  export type AggregateOffice = {
    _count: OfficeCountAggregateOutputType | null
    _min: OfficeMinAggregateOutputType | null
    _max: OfficeMaxAggregateOutputType | null
  }

  export type OfficeMinAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfficeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfficeCountAggregateOutputType = {
    id: number
    name: number
    cnpj: number
    phone: number
    email: number
    address: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfficeMinAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfficeMaxAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfficeCountAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    phone?: true
    email?: true
    address?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfficeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Office to aggregate.
     */
    where?: OfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offices to fetch.
     */
    orderBy?: OfficeOrderByWithRelationInput | OfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offices
    **/
    _count?: true | OfficeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfficeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfficeMaxAggregateInputType
  }

  export type GetOfficeAggregateType<T extends OfficeAggregateArgs> = {
        [P in keyof T & keyof AggregateOffice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffice[P]>
      : GetScalarType<T[P], AggregateOffice[P]>
  }




  export type OfficeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfficeWhereInput
    orderBy?: OfficeOrderByWithAggregationInput | OfficeOrderByWithAggregationInput[]
    by: OfficeScalarFieldEnum[] | OfficeScalarFieldEnum
    having?: OfficeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfficeCountAggregateInputType | true
    _min?: OfficeMinAggregateInputType
    _max?: OfficeMaxAggregateInputType
  }

  export type OfficeGroupByOutputType = {
    id: string
    name: string
    cnpj: string | null
    phone: string | null
    email: string | null
    address: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OfficeCountAggregateOutputType | null
    _min: OfficeMinAggregateOutputType | null
    _max: OfficeMaxAggregateOutputType | null
  }

  type GetOfficeGroupByPayload<T extends OfficeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfficeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfficeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfficeGroupByOutputType[P]>
            : GetScalarType<T[P], OfficeGroupByOutputType[P]>
        }
      >
    >


  export type OfficeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cnpj?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Office$usersArgs<ExtArgs>
    clients?: boolean | Office$clientsArgs<ExtArgs>
    conversations?: boolean | Office$conversationsArgs<ExtArgs>
    tags?: boolean | Office$tagsArgs<ExtArgs>
    customStatuses?: boolean | Office$customStatusesArgs<ExtArgs>
    aiAgents?: boolean | Office$aiAgentsArgs<ExtArgs>
    whatsappConfigs?: boolean | Office$whatsappConfigsArgs<ExtArgs>
    documents?: boolean | Office$documentsArgs<ExtArgs>
    tools?: boolean | Office$toolsArgs<ExtArgs>
    webhooks?: boolean | Office$webhooksArgs<ExtArgs>
    auditLogs?: boolean | Office$auditLogsArgs<ExtArgs>
    aiConfigs?: boolean | Office$aiConfigsArgs<ExtArgs>
    whatsappInstances?: boolean | Office$whatsappInstancesArgs<ExtArgs>
    _count?: boolean | OfficeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["office"]>

  export type OfficeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cnpj?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["office"]>

  export type OfficeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cnpj?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["office"]>

  export type OfficeSelectScalar = {
    id?: boolean
    name?: boolean
    cnpj?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfficeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cnpj" | "phone" | "email" | "address" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["office"]>
  export type OfficeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Office$usersArgs<ExtArgs>
    clients?: boolean | Office$clientsArgs<ExtArgs>
    conversations?: boolean | Office$conversationsArgs<ExtArgs>
    tags?: boolean | Office$tagsArgs<ExtArgs>
    customStatuses?: boolean | Office$customStatusesArgs<ExtArgs>
    aiAgents?: boolean | Office$aiAgentsArgs<ExtArgs>
    whatsappConfigs?: boolean | Office$whatsappConfigsArgs<ExtArgs>
    documents?: boolean | Office$documentsArgs<ExtArgs>
    tools?: boolean | Office$toolsArgs<ExtArgs>
    webhooks?: boolean | Office$webhooksArgs<ExtArgs>
    auditLogs?: boolean | Office$auditLogsArgs<ExtArgs>
    aiConfigs?: boolean | Office$aiConfigsArgs<ExtArgs>
    whatsappInstances?: boolean | Office$whatsappInstancesArgs<ExtArgs>
    _count?: boolean | OfficeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OfficeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OfficeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OfficePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Office"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      customStatuses: Prisma.$CustomStatusPayload<ExtArgs>[]
      aiAgents: Prisma.$AiAgentPayload<ExtArgs>[]
      whatsappConfigs: Prisma.$WhatsappConfigPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      tools: Prisma.$ToolPayload<ExtArgs>[]
      webhooks: Prisma.$WebhookPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      aiConfigs: Prisma.$AIProviderConfigPayload<ExtArgs>[]
      whatsappInstances: Prisma.$WhatsAppInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cnpj: string | null
      phone: string | null
      email: string | null
      address: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["office"]>
    composites: {}
  }

  type OfficeGetPayload<S extends boolean | null | undefined | OfficeDefaultArgs> = $Result.GetResult<Prisma.$OfficePayload, S>

  type OfficeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OfficeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OfficeCountAggregateInputType | true
    }

  export interface OfficeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Office'], meta: { name: 'Office' } }
    /**
     * Find zero or one Office that matches the filter.
     * @param {OfficeFindUniqueArgs} args - Arguments to find a Office
     * @example
     * // Get one Office
     * const office = await prisma.office.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfficeFindUniqueArgs>(args: SelectSubset<T, OfficeFindUniqueArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Office that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OfficeFindUniqueOrThrowArgs} args - Arguments to find a Office
     * @example
     * // Get one Office
     * const office = await prisma.office.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfficeFindUniqueOrThrowArgs>(args: SelectSubset<T, OfficeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Office that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeFindFirstArgs} args - Arguments to find a Office
     * @example
     * // Get one Office
     * const office = await prisma.office.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfficeFindFirstArgs>(args?: SelectSubset<T, OfficeFindFirstArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Office that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeFindFirstOrThrowArgs} args - Arguments to find a Office
     * @example
     * // Get one Office
     * const office = await prisma.office.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfficeFindFirstOrThrowArgs>(args?: SelectSubset<T, OfficeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offices
     * const offices = await prisma.office.findMany()
     * 
     * // Get first 10 Offices
     * const offices = await prisma.office.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const officeWithIdOnly = await prisma.office.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfficeFindManyArgs>(args?: SelectSubset<T, OfficeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Office.
     * @param {OfficeCreateArgs} args - Arguments to create a Office.
     * @example
     * // Create one Office
     * const Office = await prisma.office.create({
     *   data: {
     *     // ... data to create a Office
     *   }
     * })
     * 
     */
    create<T extends OfficeCreateArgs>(args: SelectSubset<T, OfficeCreateArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offices.
     * @param {OfficeCreateManyArgs} args - Arguments to create many Offices.
     * @example
     * // Create many Offices
     * const office = await prisma.office.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfficeCreateManyArgs>(args?: SelectSubset<T, OfficeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offices and returns the data saved in the database.
     * @param {OfficeCreateManyAndReturnArgs} args - Arguments to create many Offices.
     * @example
     * // Create many Offices
     * const office = await prisma.office.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offices and only return the `id`
     * const officeWithIdOnly = await prisma.office.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfficeCreateManyAndReturnArgs>(args?: SelectSubset<T, OfficeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Office.
     * @param {OfficeDeleteArgs} args - Arguments to delete one Office.
     * @example
     * // Delete one Office
     * const Office = await prisma.office.delete({
     *   where: {
     *     // ... filter to delete one Office
     *   }
     * })
     * 
     */
    delete<T extends OfficeDeleteArgs>(args: SelectSubset<T, OfficeDeleteArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Office.
     * @param {OfficeUpdateArgs} args - Arguments to update one Office.
     * @example
     * // Update one Office
     * const office = await prisma.office.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfficeUpdateArgs>(args: SelectSubset<T, OfficeUpdateArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offices.
     * @param {OfficeDeleteManyArgs} args - Arguments to filter Offices to delete.
     * @example
     * // Delete a few Offices
     * const { count } = await prisma.office.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfficeDeleteManyArgs>(args?: SelectSubset<T, OfficeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offices
     * const office = await prisma.office.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfficeUpdateManyArgs>(args: SelectSubset<T, OfficeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offices and returns the data updated in the database.
     * @param {OfficeUpdateManyAndReturnArgs} args - Arguments to update many Offices.
     * @example
     * // Update many Offices
     * const office = await prisma.office.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Offices and only return the `id`
     * const officeWithIdOnly = await prisma.office.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OfficeUpdateManyAndReturnArgs>(args: SelectSubset<T, OfficeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Office.
     * @param {OfficeUpsertArgs} args - Arguments to update or create a Office.
     * @example
     * // Update or create a Office
     * const office = await prisma.office.upsert({
     *   create: {
     *     // ... data to create a Office
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Office we want to update
     *   }
     * })
     */
    upsert<T extends OfficeUpsertArgs>(args: SelectSubset<T, OfficeUpsertArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeCountArgs} args - Arguments to filter Offices to count.
     * @example
     * // Count the number of Offices
     * const count = await prisma.office.count({
     *   where: {
     *     // ... the filter for the Offices we want to count
     *   }
     * })
    **/
    count<T extends OfficeCountArgs>(
      args?: Subset<T, OfficeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfficeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Office.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfficeAggregateArgs>(args: Subset<T, OfficeAggregateArgs>): Prisma.PrismaPromise<GetOfficeAggregateType<T>>

    /**
     * Group by Office.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfficeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfficeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfficeGroupByArgs['orderBy'] }
        : { orderBy?: OfficeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfficeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfficeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Office model
   */
  readonly fields: OfficeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Office.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfficeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Office$usersArgs<ExtArgs> = {}>(args?: Subset<T, Office$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends Office$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Office$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Office$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Office$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Office$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Office$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customStatuses<T extends Office$customStatusesArgs<ExtArgs> = {}>(args?: Subset<T, Office$customStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiAgents<T extends Office$aiAgentsArgs<ExtArgs> = {}>(args?: Subset<T, Office$aiAgentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappConfigs<T extends Office$whatsappConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Office$whatsappConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Office$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Office$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tools<T extends Office$toolsArgs<ExtArgs> = {}>(args?: Subset<T, Office$toolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    webhooks<T extends Office$webhooksArgs<ExtArgs> = {}>(args?: Subset<T, Office$webhooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Office$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Office$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiConfigs<T extends Office$aiConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Office$aiConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappInstances<T extends Office$whatsappInstancesArgs<ExtArgs> = {}>(args?: Subset<T, Office$whatsappInstancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Office model
   */
  interface OfficeFieldRefs {
    readonly id: FieldRef<"Office", 'String'>
    readonly name: FieldRef<"Office", 'String'>
    readonly cnpj: FieldRef<"Office", 'String'>
    readonly phone: FieldRef<"Office", 'String'>
    readonly email: FieldRef<"Office", 'String'>
    readonly address: FieldRef<"Office", 'String'>
    readonly isActive: FieldRef<"Office", 'Boolean'>
    readonly createdAt: FieldRef<"Office", 'DateTime'>
    readonly updatedAt: FieldRef<"Office", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Office findUnique
   */
  export type OfficeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * Filter, which Office to fetch.
     */
    where: OfficeWhereUniqueInput
  }

  /**
   * Office findUniqueOrThrow
   */
  export type OfficeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * Filter, which Office to fetch.
     */
    where: OfficeWhereUniqueInput
  }

  /**
   * Office findFirst
   */
  export type OfficeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * Filter, which Office to fetch.
     */
    where?: OfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offices to fetch.
     */
    orderBy?: OfficeOrderByWithRelationInput | OfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offices.
     */
    cursor?: OfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offices.
     */
    distinct?: OfficeScalarFieldEnum | OfficeScalarFieldEnum[]
  }

  /**
   * Office findFirstOrThrow
   */
  export type OfficeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * Filter, which Office to fetch.
     */
    where?: OfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offices to fetch.
     */
    orderBy?: OfficeOrderByWithRelationInput | OfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offices.
     */
    cursor?: OfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offices.
     */
    distinct?: OfficeScalarFieldEnum | OfficeScalarFieldEnum[]
  }

  /**
   * Office findMany
   */
  export type OfficeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * Filter, which Offices to fetch.
     */
    where?: OfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offices to fetch.
     */
    orderBy?: OfficeOrderByWithRelationInput | OfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offices.
     */
    cursor?: OfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offices.
     */
    skip?: number
    distinct?: OfficeScalarFieldEnum | OfficeScalarFieldEnum[]
  }

  /**
   * Office create
   */
  export type OfficeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * The data needed to create a Office.
     */
    data: XOR<OfficeCreateInput, OfficeUncheckedCreateInput>
  }

  /**
   * Office createMany
   */
  export type OfficeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offices.
     */
    data: OfficeCreateManyInput | OfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Office createManyAndReturn
   */
  export type OfficeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * The data used to create many Offices.
     */
    data: OfficeCreateManyInput | OfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Office update
   */
  export type OfficeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * The data needed to update a Office.
     */
    data: XOR<OfficeUpdateInput, OfficeUncheckedUpdateInput>
    /**
     * Choose, which Office to update.
     */
    where: OfficeWhereUniqueInput
  }

  /**
   * Office updateMany
   */
  export type OfficeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offices.
     */
    data: XOR<OfficeUpdateManyMutationInput, OfficeUncheckedUpdateManyInput>
    /**
     * Filter which Offices to update
     */
    where?: OfficeWhereInput
    /**
     * Limit how many Offices to update.
     */
    limit?: number
  }

  /**
   * Office updateManyAndReturn
   */
  export type OfficeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * The data used to update Offices.
     */
    data: XOR<OfficeUpdateManyMutationInput, OfficeUncheckedUpdateManyInput>
    /**
     * Filter which Offices to update
     */
    where?: OfficeWhereInput
    /**
     * Limit how many Offices to update.
     */
    limit?: number
  }

  /**
   * Office upsert
   */
  export type OfficeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * The filter to search for the Office to update in case it exists.
     */
    where: OfficeWhereUniqueInput
    /**
     * In case the Office found by the `where` argument doesn't exist, create a new Office with this data.
     */
    create: XOR<OfficeCreateInput, OfficeUncheckedCreateInput>
    /**
     * In case the Office was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfficeUpdateInput, OfficeUncheckedUpdateInput>
  }

  /**
   * Office delete
   */
  export type OfficeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
    /**
     * Filter which Office to delete.
     */
    where: OfficeWhereUniqueInput
  }

  /**
   * Office deleteMany
   */
  export type OfficeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offices to delete
     */
    where?: OfficeWhereInput
    /**
     * Limit how many Offices to delete.
     */
    limit?: number
  }

  /**
   * Office.users
   */
  export type Office$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Office.clients
   */
  export type Office$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Office.conversations
   */
  export type Office$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Office.tags
   */
  export type Office$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Office.customStatuses
   */
  export type Office$customStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    where?: CustomStatusWhereInput
    orderBy?: CustomStatusOrderByWithRelationInput | CustomStatusOrderByWithRelationInput[]
    cursor?: CustomStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomStatusScalarFieldEnum | CustomStatusScalarFieldEnum[]
  }

  /**
   * Office.aiAgents
   */
  export type Office$aiAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    where?: AiAgentWhereInput
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    cursor?: AiAgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * Office.whatsappConfigs
   */
  export type Office$whatsappConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    where?: WhatsappConfigWhereInput
    orderBy?: WhatsappConfigOrderByWithRelationInput | WhatsappConfigOrderByWithRelationInput[]
    cursor?: WhatsappConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsappConfigScalarFieldEnum | WhatsappConfigScalarFieldEnum[]
  }

  /**
   * Office.documents
   */
  export type Office$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Office.tools
   */
  export type Office$toolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    where?: ToolWhereInput
    orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[]
    cursor?: ToolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[]
  }

  /**
   * Office.webhooks
   */
  export type Office$webhooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    cursor?: WebhookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Office.auditLogs
   */
  export type Office$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Office.aiConfigs
   */
  export type Office$aiConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    where?: AIProviderConfigWhereInput
    orderBy?: AIProviderConfigOrderByWithRelationInput | AIProviderConfigOrderByWithRelationInput[]
    cursor?: AIProviderConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIProviderConfigScalarFieldEnum | AIProviderConfigScalarFieldEnum[]
  }

  /**
   * Office.whatsappInstances
   */
  export type Office$whatsappInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    where?: WhatsAppInstanceWhereInput
    orderBy?: WhatsAppInstanceOrderByWithRelationInput | WhatsAppInstanceOrderByWithRelationInput[]
    cursor?: WhatsAppInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppInstanceScalarFieldEnum | WhatsAppInstanceScalarFieldEnum[]
  }

  /**
   * Office without action
   */
  export type OfficeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Office
     */
    select?: OfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Office
     */
    omit?: OfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfficeInclude<ExtArgs> | null
  }


  /**
   * Model WhatsappConfig
   */

  export type AggregateWhatsappConfig = {
    _count: WhatsappConfigCountAggregateOutputType | null
    _min: WhatsappConfigMinAggregateOutputType | null
    _max: WhatsappConfigMaxAggregateOutputType | null
  }

  export type WhatsappConfigMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    phone: string | null
    qrCode: string | null
    isActive: boolean | null
    apiUrl: string | null
    apiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type WhatsappConfigMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    phone: string | null
    qrCode: string | null
    isActive: boolean | null
    apiUrl: string | null
    apiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type WhatsappConfigCountAggregateOutputType = {
    id: number
    instanceId: number
    phone: number
    qrCode: number
    isActive: number
    apiUrl: number
    apiKey: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type WhatsappConfigMinAggregateInputType = {
    id?: true
    instanceId?: true
    phone?: true
    qrCode?: true
    isActive?: true
    apiUrl?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type WhatsappConfigMaxAggregateInputType = {
    id?: true
    instanceId?: true
    phone?: true
    qrCode?: true
    isActive?: true
    apiUrl?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type WhatsappConfigCountAggregateInputType = {
    id?: true
    instanceId?: true
    phone?: true
    qrCode?: true
    isActive?: true
    apiUrl?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type WhatsappConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappConfig to aggregate.
     */
    where?: WhatsappConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappConfigs to fetch.
     */
    orderBy?: WhatsappConfigOrderByWithRelationInput | WhatsappConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsappConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsappConfigs
    **/
    _count?: true | WhatsappConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsappConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsappConfigMaxAggregateInputType
  }

  export type GetWhatsappConfigAggregateType<T extends WhatsappConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsappConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsappConfig[P]>
      : GetScalarType<T[P], AggregateWhatsappConfig[P]>
  }




  export type WhatsappConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappConfigWhereInput
    orderBy?: WhatsappConfigOrderByWithAggregationInput | WhatsappConfigOrderByWithAggregationInput[]
    by: WhatsappConfigScalarFieldEnum[] | WhatsappConfigScalarFieldEnum
    having?: WhatsappConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsappConfigCountAggregateInputType | true
    _min?: WhatsappConfigMinAggregateInputType
    _max?: WhatsappConfigMaxAggregateInputType
  }

  export type WhatsappConfigGroupByOutputType = {
    id: string
    instanceId: string
    phone: string
    qrCode: string | null
    isActive: boolean
    apiUrl: string | null
    apiKey: string | null
    createdAt: Date
    updatedAt: Date
    officeId: string
    _count: WhatsappConfigCountAggregateOutputType | null
    _min: WhatsappConfigMinAggregateOutputType | null
    _max: WhatsappConfigMaxAggregateOutputType | null
  }

  type GetWhatsappConfigGroupByPayload<T extends WhatsappConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsappConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsappConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsappConfigGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsappConfigGroupByOutputType[P]>
        }
      >
    >


  export type WhatsappConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    phone?: boolean
    qrCode?: boolean
    isActive?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    conversations?: boolean | WhatsappConfig$conversationsArgs<ExtArgs>
    messages?: boolean | WhatsappConfig$messagesArgs<ExtArgs>
    _count?: boolean | WhatsappConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappConfig"]>

  export type WhatsappConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    phone?: boolean
    qrCode?: boolean
    isActive?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappConfig"]>

  export type WhatsappConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    phone?: boolean
    qrCode?: boolean
    isActive?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappConfig"]>

  export type WhatsappConfigSelectScalar = {
    id?: boolean
    instanceId?: boolean
    phone?: boolean
    qrCode?: boolean
    isActive?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type WhatsappConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceId" | "phone" | "qrCode" | "isActive" | "apiUrl" | "apiKey" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["whatsappConfig"]>
  export type WhatsappConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    conversations?: boolean | WhatsappConfig$conversationsArgs<ExtArgs>
    messages?: boolean | WhatsappConfig$messagesArgs<ExtArgs>
    _count?: boolean | WhatsappConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsappConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type WhatsappConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $WhatsappConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsappConfig"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      phone: string
      qrCode: string | null
      isActive: boolean
      apiUrl: string | null
      apiKey: string | null
      createdAt: Date
      updatedAt: Date
      officeId: string
    }, ExtArgs["result"]["whatsappConfig"]>
    composites: {}
  }

  type WhatsappConfigGetPayload<S extends boolean | null | undefined | WhatsappConfigDefaultArgs> = $Result.GetResult<Prisma.$WhatsappConfigPayload, S>

  type WhatsappConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsappConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsappConfigCountAggregateInputType | true
    }

  export interface WhatsappConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsappConfig'], meta: { name: 'WhatsappConfig' } }
    /**
     * Find zero or one WhatsappConfig that matches the filter.
     * @param {WhatsappConfigFindUniqueArgs} args - Arguments to find a WhatsappConfig
     * @example
     * // Get one WhatsappConfig
     * const whatsappConfig = await prisma.whatsappConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsappConfigFindUniqueArgs>(args: SelectSubset<T, WhatsappConfigFindUniqueArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsappConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsappConfigFindUniqueOrThrowArgs} args - Arguments to find a WhatsappConfig
     * @example
     * // Get one WhatsappConfig
     * const whatsappConfig = await prisma.whatsappConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsappConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsappConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappConfigFindFirstArgs} args - Arguments to find a WhatsappConfig
     * @example
     * // Get one WhatsappConfig
     * const whatsappConfig = await prisma.whatsappConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsappConfigFindFirstArgs>(args?: SelectSubset<T, WhatsappConfigFindFirstArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappConfigFindFirstOrThrowArgs} args - Arguments to find a WhatsappConfig
     * @example
     * // Get one WhatsappConfig
     * const whatsappConfig = await prisma.whatsappConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsappConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsappConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsappConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsappConfigs
     * const whatsappConfigs = await prisma.whatsappConfig.findMany()
     * 
     * // Get first 10 WhatsappConfigs
     * const whatsappConfigs = await prisma.whatsappConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsappConfigWithIdOnly = await prisma.whatsappConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsappConfigFindManyArgs>(args?: SelectSubset<T, WhatsappConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsappConfig.
     * @param {WhatsappConfigCreateArgs} args - Arguments to create a WhatsappConfig.
     * @example
     * // Create one WhatsappConfig
     * const WhatsappConfig = await prisma.whatsappConfig.create({
     *   data: {
     *     // ... data to create a WhatsappConfig
     *   }
     * })
     * 
     */
    create<T extends WhatsappConfigCreateArgs>(args: SelectSubset<T, WhatsappConfigCreateArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsappConfigs.
     * @param {WhatsappConfigCreateManyArgs} args - Arguments to create many WhatsappConfigs.
     * @example
     * // Create many WhatsappConfigs
     * const whatsappConfig = await prisma.whatsappConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsappConfigCreateManyArgs>(args?: SelectSubset<T, WhatsappConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsappConfigs and returns the data saved in the database.
     * @param {WhatsappConfigCreateManyAndReturnArgs} args - Arguments to create many WhatsappConfigs.
     * @example
     * // Create many WhatsappConfigs
     * const whatsappConfig = await prisma.whatsappConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsappConfigs and only return the `id`
     * const whatsappConfigWithIdOnly = await prisma.whatsappConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsappConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsappConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsappConfig.
     * @param {WhatsappConfigDeleteArgs} args - Arguments to delete one WhatsappConfig.
     * @example
     * // Delete one WhatsappConfig
     * const WhatsappConfig = await prisma.whatsappConfig.delete({
     *   where: {
     *     // ... filter to delete one WhatsappConfig
     *   }
     * })
     * 
     */
    delete<T extends WhatsappConfigDeleteArgs>(args: SelectSubset<T, WhatsappConfigDeleteArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsappConfig.
     * @param {WhatsappConfigUpdateArgs} args - Arguments to update one WhatsappConfig.
     * @example
     * // Update one WhatsappConfig
     * const whatsappConfig = await prisma.whatsappConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsappConfigUpdateArgs>(args: SelectSubset<T, WhatsappConfigUpdateArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsappConfigs.
     * @param {WhatsappConfigDeleteManyArgs} args - Arguments to filter WhatsappConfigs to delete.
     * @example
     * // Delete a few WhatsappConfigs
     * const { count } = await prisma.whatsappConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsappConfigDeleteManyArgs>(args?: SelectSubset<T, WhatsappConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsappConfigs
     * const whatsappConfig = await prisma.whatsappConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsappConfigUpdateManyArgs>(args: SelectSubset<T, WhatsappConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappConfigs and returns the data updated in the database.
     * @param {WhatsappConfigUpdateManyAndReturnArgs} args - Arguments to update many WhatsappConfigs.
     * @example
     * // Update many WhatsappConfigs
     * const whatsappConfig = await prisma.whatsappConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsappConfigs and only return the `id`
     * const whatsappConfigWithIdOnly = await prisma.whatsappConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsappConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsappConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsappConfig.
     * @param {WhatsappConfigUpsertArgs} args - Arguments to update or create a WhatsappConfig.
     * @example
     * // Update or create a WhatsappConfig
     * const whatsappConfig = await prisma.whatsappConfig.upsert({
     *   create: {
     *     // ... data to create a WhatsappConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsappConfig we want to update
     *   }
     * })
     */
    upsert<T extends WhatsappConfigUpsertArgs>(args: SelectSubset<T, WhatsappConfigUpsertArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsappConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappConfigCountArgs} args - Arguments to filter WhatsappConfigs to count.
     * @example
     * // Count the number of WhatsappConfigs
     * const count = await prisma.whatsappConfig.count({
     *   where: {
     *     // ... the filter for the WhatsappConfigs we want to count
     *   }
     * })
    **/
    count<T extends WhatsappConfigCountArgs>(
      args?: Subset<T, WhatsappConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsappConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsappConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsappConfigAggregateArgs>(args: Subset<T, WhatsappConfigAggregateArgs>): Prisma.PrismaPromise<GetWhatsappConfigAggregateType<T>>

    /**
     * Group by WhatsappConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsappConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsappConfigGroupByArgs['orderBy'] }
        : { orderBy?: WhatsappConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsappConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsappConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsappConfig model
   */
  readonly fields: WhatsappConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsappConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsappConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversations<T extends WhatsappConfig$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappConfig$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends WhatsappConfig$messagesArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappConfig$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsappConfig model
   */
  interface WhatsappConfigFieldRefs {
    readonly id: FieldRef<"WhatsappConfig", 'String'>
    readonly instanceId: FieldRef<"WhatsappConfig", 'String'>
    readonly phone: FieldRef<"WhatsappConfig", 'String'>
    readonly qrCode: FieldRef<"WhatsappConfig", 'String'>
    readonly isActive: FieldRef<"WhatsappConfig", 'Boolean'>
    readonly apiUrl: FieldRef<"WhatsappConfig", 'String'>
    readonly apiKey: FieldRef<"WhatsappConfig", 'String'>
    readonly createdAt: FieldRef<"WhatsappConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsappConfig", 'DateTime'>
    readonly officeId: FieldRef<"WhatsappConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WhatsappConfig findUnique
   */
  export type WhatsappConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappConfig to fetch.
     */
    where: WhatsappConfigWhereUniqueInput
  }

  /**
   * WhatsappConfig findUniqueOrThrow
   */
  export type WhatsappConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappConfig to fetch.
     */
    where: WhatsappConfigWhereUniqueInput
  }

  /**
   * WhatsappConfig findFirst
   */
  export type WhatsappConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappConfig to fetch.
     */
    where?: WhatsappConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappConfigs to fetch.
     */
    orderBy?: WhatsappConfigOrderByWithRelationInput | WhatsappConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappConfigs.
     */
    cursor?: WhatsappConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappConfigs.
     */
    distinct?: WhatsappConfigScalarFieldEnum | WhatsappConfigScalarFieldEnum[]
  }

  /**
   * WhatsappConfig findFirstOrThrow
   */
  export type WhatsappConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappConfig to fetch.
     */
    where?: WhatsappConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappConfigs to fetch.
     */
    orderBy?: WhatsappConfigOrderByWithRelationInput | WhatsappConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappConfigs.
     */
    cursor?: WhatsappConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappConfigs.
     */
    distinct?: WhatsappConfigScalarFieldEnum | WhatsappConfigScalarFieldEnum[]
  }

  /**
   * WhatsappConfig findMany
   */
  export type WhatsappConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappConfigs to fetch.
     */
    where?: WhatsappConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappConfigs to fetch.
     */
    orderBy?: WhatsappConfigOrderByWithRelationInput | WhatsappConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsappConfigs.
     */
    cursor?: WhatsappConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappConfigs.
     */
    skip?: number
    distinct?: WhatsappConfigScalarFieldEnum | WhatsappConfigScalarFieldEnum[]
  }

  /**
   * WhatsappConfig create
   */
  export type WhatsappConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsappConfig.
     */
    data: XOR<WhatsappConfigCreateInput, WhatsappConfigUncheckedCreateInput>
  }

  /**
   * WhatsappConfig createMany
   */
  export type WhatsappConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsappConfigs.
     */
    data: WhatsappConfigCreateManyInput | WhatsappConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappConfig createManyAndReturn
   */
  export type WhatsappConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsappConfigs.
     */
    data: WhatsappConfigCreateManyInput | WhatsappConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsappConfig update
   */
  export type WhatsappConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsappConfig.
     */
    data: XOR<WhatsappConfigUpdateInput, WhatsappConfigUncheckedUpdateInput>
    /**
     * Choose, which WhatsappConfig to update.
     */
    where: WhatsappConfigWhereUniqueInput
  }

  /**
   * WhatsappConfig updateMany
   */
  export type WhatsappConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsappConfigs.
     */
    data: XOR<WhatsappConfigUpdateManyMutationInput, WhatsappConfigUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappConfigs to update
     */
    where?: WhatsappConfigWhereInput
    /**
     * Limit how many WhatsappConfigs to update.
     */
    limit?: number
  }

  /**
   * WhatsappConfig updateManyAndReturn
   */
  export type WhatsappConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * The data used to update WhatsappConfigs.
     */
    data: XOR<WhatsappConfigUpdateManyMutationInput, WhatsappConfigUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappConfigs to update
     */
    where?: WhatsappConfigWhereInput
    /**
     * Limit how many WhatsappConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsappConfig upsert
   */
  export type WhatsappConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsappConfig to update in case it exists.
     */
    where: WhatsappConfigWhereUniqueInput
    /**
     * In case the WhatsappConfig found by the `where` argument doesn't exist, create a new WhatsappConfig with this data.
     */
    create: XOR<WhatsappConfigCreateInput, WhatsappConfigUncheckedCreateInput>
    /**
     * In case the WhatsappConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsappConfigUpdateInput, WhatsappConfigUncheckedUpdateInput>
  }

  /**
   * WhatsappConfig delete
   */
  export type WhatsappConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    /**
     * Filter which WhatsappConfig to delete.
     */
    where: WhatsappConfigWhereUniqueInput
  }

  /**
   * WhatsappConfig deleteMany
   */
  export type WhatsappConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappConfigs to delete
     */
    where?: WhatsappConfigWhereInput
    /**
     * Limit how many WhatsappConfigs to delete.
     */
    limit?: number
  }

  /**
   * WhatsappConfig.conversations
   */
  export type WhatsappConfig$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * WhatsappConfig.messages
   */
  export type WhatsappConfig$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * WhatsappConfig without action
   */
  export type WhatsappConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppInstance
   */

  export type AggregateWhatsAppInstance = {
    _count: WhatsAppInstanceCountAggregateOutputType | null
    _min: WhatsAppInstanceMinAggregateOutputType | null
    _max: WhatsAppInstanceMaxAggregateOutputType | null
  }

  export type WhatsAppInstanceMinAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    status: $Enums.WhatsAppInstanceStatus | null
    qrCode: string | null
    webhookUrl: string | null
    officeId: string | null
    createdById: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppInstanceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    status: $Enums.WhatsAppInstanceStatus | null
    qrCode: string | null
    webhookUrl: string | null
    officeId: string | null
    createdById: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppInstanceCountAggregateOutputType = {
    id: number
    name: number
    phoneNumber: number
    status: number
    qrCode: number
    webhookUrl: number
    officeId: number
    createdById: number
    connectionData: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppInstanceMinAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    status?: true
    qrCode?: true
    webhookUrl?: true
    officeId?: true
    createdById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppInstanceMaxAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    status?: true
    qrCode?: true
    webhookUrl?: true
    officeId?: true
    createdById?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppInstanceCountAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    status?: true
    qrCode?: true
    webhookUrl?: true
    officeId?: true
    createdById?: true
    connectionData?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppInstance to aggregate.
     */
    where?: WhatsAppInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppInstances to fetch.
     */
    orderBy?: WhatsAppInstanceOrderByWithRelationInput | WhatsAppInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppInstances
    **/
    _count?: true | WhatsAppInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppInstanceMaxAggregateInputType
  }

  export type GetWhatsAppInstanceAggregateType<T extends WhatsAppInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppInstance[P]>
      : GetScalarType<T[P], AggregateWhatsAppInstance[P]>
  }




  export type WhatsAppInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppInstanceWhereInput
    orderBy?: WhatsAppInstanceOrderByWithAggregationInput | WhatsAppInstanceOrderByWithAggregationInput[]
    by: WhatsAppInstanceScalarFieldEnum[] | WhatsAppInstanceScalarFieldEnum
    having?: WhatsAppInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppInstanceCountAggregateInputType | true
    _min?: WhatsAppInstanceMinAggregateInputType
    _max?: WhatsAppInstanceMaxAggregateInputType
  }

  export type WhatsAppInstanceGroupByOutputType = {
    id: string
    name: string
    phoneNumber: string | null
    status: $Enums.WhatsAppInstanceStatus
    qrCode: string | null
    webhookUrl: string | null
    officeId: string
    createdById: string
    connectionData: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppInstanceCountAggregateOutputType | null
    _min: WhatsAppInstanceMinAggregateOutputType | null
    _max: WhatsAppInstanceMaxAggregateOutputType | null
  }

  type GetWhatsAppInstanceGroupByPayload<T extends WhatsAppInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppInstanceGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    status?: boolean
    qrCode?: boolean
    webhookUrl?: boolean
    officeId?: boolean
    createdById?: boolean
    connectionData?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | WhatsAppInstance$contactsArgs<ExtArgs>
    conversations?: boolean | WhatsAppInstance$conversationsArgs<ExtArgs>
    messages?: boolean | WhatsAppInstance$messagesArgs<ExtArgs>
    imports?: boolean | WhatsAppInstance$importsArgs<ExtArgs>
    _count?: boolean | WhatsAppInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppInstance"]>

  export type WhatsAppInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    status?: boolean
    qrCode?: boolean
    webhookUrl?: boolean
    officeId?: boolean
    createdById?: boolean
    connectionData?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppInstance"]>

  export type WhatsAppInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    status?: boolean
    qrCode?: boolean
    webhookUrl?: boolean
    officeId?: boolean
    createdById?: boolean
    connectionData?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppInstance"]>

  export type WhatsAppInstanceSelectScalar = {
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    status?: boolean
    qrCode?: boolean
    webhookUrl?: boolean
    officeId?: boolean
    createdById?: boolean
    connectionData?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phoneNumber" | "status" | "qrCode" | "webhookUrl" | "officeId" | "createdById" | "connectionData" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppInstance"]>
  export type WhatsAppInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | WhatsAppInstance$contactsArgs<ExtArgs>
    conversations?: boolean | WhatsAppInstance$conversationsArgs<ExtArgs>
    messages?: boolean | WhatsAppInstance$messagesArgs<ExtArgs>
    imports?: boolean | WhatsAppInstance$importsArgs<ExtArgs>
    _count?: boolean | WhatsAppInstanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhatsAppInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppInstance"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      contacts: Prisma.$WhatsAppContactPayload<ExtArgs>[]
      conversations: Prisma.$WhatsAppConversationPayload<ExtArgs>[]
      messages: Prisma.$WhatsAppMessagePayload<ExtArgs>[]
      imports: Prisma.$WhatsAppImportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phoneNumber: string | null
      status: $Enums.WhatsAppInstanceStatus
      qrCode: string | null
      webhookUrl: string | null
      officeId: string
      createdById: string
      connectionData: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppInstance"]>
    composites: {}
  }

  type WhatsAppInstanceGetPayload<S extends boolean | null | undefined | WhatsAppInstanceDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppInstancePayload, S>

  type WhatsAppInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppInstanceCountAggregateInputType | true
    }

  export interface WhatsAppInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppInstance'], meta: { name: 'WhatsAppInstance' } }
    /**
     * Find zero or one WhatsAppInstance that matches the filter.
     * @param {WhatsAppInstanceFindUniqueArgs} args - Arguments to find a WhatsAppInstance
     * @example
     * // Get one WhatsAppInstance
     * const whatsAppInstance = await prisma.whatsAppInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppInstanceFindUniqueArgs>(args: SelectSubset<T, WhatsAppInstanceFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppInstanceFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppInstance
     * @example
     * // Get one WhatsAppInstance
     * const whatsAppInstance = await prisma.whatsAppInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppInstanceFindFirstArgs} args - Arguments to find a WhatsAppInstance
     * @example
     * // Get one WhatsAppInstance
     * const whatsAppInstance = await prisma.whatsAppInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppInstanceFindFirstArgs>(args?: SelectSubset<T, WhatsAppInstanceFindFirstArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppInstanceFindFirstOrThrowArgs} args - Arguments to find a WhatsAppInstance
     * @example
     * // Get one WhatsAppInstance
     * const whatsAppInstance = await prisma.whatsAppInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppInstances
     * const whatsAppInstances = await prisma.whatsAppInstance.findMany()
     * 
     * // Get first 10 WhatsAppInstances
     * const whatsAppInstances = await prisma.whatsAppInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppInstanceWithIdOnly = await prisma.whatsAppInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppInstanceFindManyArgs>(args?: SelectSubset<T, WhatsAppInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppInstance.
     * @param {WhatsAppInstanceCreateArgs} args - Arguments to create a WhatsAppInstance.
     * @example
     * // Create one WhatsAppInstance
     * const WhatsAppInstance = await prisma.whatsAppInstance.create({
     *   data: {
     *     // ... data to create a WhatsAppInstance
     *   }
     * })
     * 
     */
    create<T extends WhatsAppInstanceCreateArgs>(args: SelectSubset<T, WhatsAppInstanceCreateArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppInstances.
     * @param {WhatsAppInstanceCreateManyArgs} args - Arguments to create many WhatsAppInstances.
     * @example
     * // Create many WhatsAppInstances
     * const whatsAppInstance = await prisma.whatsAppInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppInstanceCreateManyArgs>(args?: SelectSubset<T, WhatsAppInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppInstances and returns the data saved in the database.
     * @param {WhatsAppInstanceCreateManyAndReturnArgs} args - Arguments to create many WhatsAppInstances.
     * @example
     * // Create many WhatsAppInstances
     * const whatsAppInstance = await prisma.whatsAppInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppInstances and only return the `id`
     * const whatsAppInstanceWithIdOnly = await prisma.whatsAppInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppInstance.
     * @param {WhatsAppInstanceDeleteArgs} args - Arguments to delete one WhatsAppInstance.
     * @example
     * // Delete one WhatsAppInstance
     * const WhatsAppInstance = await prisma.whatsAppInstance.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppInstance
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppInstanceDeleteArgs>(args: SelectSubset<T, WhatsAppInstanceDeleteArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppInstance.
     * @param {WhatsAppInstanceUpdateArgs} args - Arguments to update one WhatsAppInstance.
     * @example
     * // Update one WhatsAppInstance
     * const whatsAppInstance = await prisma.whatsAppInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppInstanceUpdateArgs>(args: SelectSubset<T, WhatsAppInstanceUpdateArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppInstances.
     * @param {WhatsAppInstanceDeleteManyArgs} args - Arguments to filter WhatsAppInstances to delete.
     * @example
     * // Delete a few WhatsAppInstances
     * const { count } = await prisma.whatsAppInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppInstanceDeleteManyArgs>(args?: SelectSubset<T, WhatsAppInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppInstances
     * const whatsAppInstance = await prisma.whatsAppInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppInstanceUpdateManyArgs>(args: SelectSubset<T, WhatsAppInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppInstances and returns the data updated in the database.
     * @param {WhatsAppInstanceUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppInstances.
     * @example
     * // Update many WhatsAppInstances
     * const whatsAppInstance = await prisma.whatsAppInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppInstances and only return the `id`
     * const whatsAppInstanceWithIdOnly = await prisma.whatsAppInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppInstance.
     * @param {WhatsAppInstanceUpsertArgs} args - Arguments to update or create a WhatsAppInstance.
     * @example
     * // Update or create a WhatsAppInstance
     * const whatsAppInstance = await prisma.whatsAppInstance.upsert({
     *   create: {
     *     // ... data to create a WhatsAppInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppInstance we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppInstanceUpsertArgs>(args: SelectSubset<T, WhatsAppInstanceUpsertArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppInstanceCountArgs} args - Arguments to filter WhatsAppInstances to count.
     * @example
     * // Count the number of WhatsAppInstances
     * const count = await prisma.whatsAppInstance.count({
     *   where: {
     *     // ... the filter for the WhatsAppInstances we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppInstanceCountArgs>(
      args?: Subset<T, WhatsAppInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppInstanceAggregateArgs>(args: Subset<T, WhatsAppInstanceAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppInstanceAggregateType<T>>

    /**
     * Group by WhatsAppInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppInstanceGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppInstance model
   */
  readonly fields: WhatsAppInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contacts<T extends WhatsAppInstance$contactsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstance$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends WhatsAppInstance$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstance$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends WhatsAppInstance$messagesArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstance$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imports<T extends WhatsAppInstance$importsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstance$importsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppInstance model
   */
  interface WhatsAppInstanceFieldRefs {
    readonly id: FieldRef<"WhatsAppInstance", 'String'>
    readonly name: FieldRef<"WhatsAppInstance", 'String'>
    readonly phoneNumber: FieldRef<"WhatsAppInstance", 'String'>
    readonly status: FieldRef<"WhatsAppInstance", 'WhatsAppInstanceStatus'>
    readonly qrCode: FieldRef<"WhatsAppInstance", 'String'>
    readonly webhookUrl: FieldRef<"WhatsAppInstance", 'String'>
    readonly officeId: FieldRef<"WhatsAppInstance", 'String'>
    readonly createdById: FieldRef<"WhatsAppInstance", 'String'>
    readonly connectionData: FieldRef<"WhatsAppInstance", 'Json'>
    readonly isActive: FieldRef<"WhatsAppInstance", 'Boolean'>
    readonly createdAt: FieldRef<"WhatsAppInstance", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppInstance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppInstance findUnique
   */
  export type WhatsAppInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppInstance to fetch.
     */
    where: WhatsAppInstanceWhereUniqueInput
  }

  /**
   * WhatsAppInstance findUniqueOrThrow
   */
  export type WhatsAppInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppInstance to fetch.
     */
    where: WhatsAppInstanceWhereUniqueInput
  }

  /**
   * WhatsAppInstance findFirst
   */
  export type WhatsAppInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppInstance to fetch.
     */
    where?: WhatsAppInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppInstances to fetch.
     */
    orderBy?: WhatsAppInstanceOrderByWithRelationInput | WhatsAppInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppInstances.
     */
    cursor?: WhatsAppInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppInstances.
     */
    distinct?: WhatsAppInstanceScalarFieldEnum | WhatsAppInstanceScalarFieldEnum[]
  }

  /**
   * WhatsAppInstance findFirstOrThrow
   */
  export type WhatsAppInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppInstance to fetch.
     */
    where?: WhatsAppInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppInstances to fetch.
     */
    orderBy?: WhatsAppInstanceOrderByWithRelationInput | WhatsAppInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppInstances.
     */
    cursor?: WhatsAppInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppInstances.
     */
    distinct?: WhatsAppInstanceScalarFieldEnum | WhatsAppInstanceScalarFieldEnum[]
  }

  /**
   * WhatsAppInstance findMany
   */
  export type WhatsAppInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppInstances to fetch.
     */
    where?: WhatsAppInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppInstances to fetch.
     */
    orderBy?: WhatsAppInstanceOrderByWithRelationInput | WhatsAppInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppInstances.
     */
    cursor?: WhatsAppInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppInstances.
     */
    skip?: number
    distinct?: WhatsAppInstanceScalarFieldEnum | WhatsAppInstanceScalarFieldEnum[]
  }

  /**
   * WhatsAppInstance create
   */
  export type WhatsAppInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppInstance.
     */
    data: XOR<WhatsAppInstanceCreateInput, WhatsAppInstanceUncheckedCreateInput>
  }

  /**
   * WhatsAppInstance createMany
   */
  export type WhatsAppInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppInstances.
     */
    data: WhatsAppInstanceCreateManyInput | WhatsAppInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppInstance createManyAndReturn
   */
  export type WhatsAppInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppInstances.
     */
    data: WhatsAppInstanceCreateManyInput | WhatsAppInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppInstance update
   */
  export type WhatsAppInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppInstance.
     */
    data: XOR<WhatsAppInstanceUpdateInput, WhatsAppInstanceUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppInstance to update.
     */
    where: WhatsAppInstanceWhereUniqueInput
  }

  /**
   * WhatsAppInstance updateMany
   */
  export type WhatsAppInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppInstances.
     */
    data: XOR<WhatsAppInstanceUpdateManyMutationInput, WhatsAppInstanceUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppInstances to update
     */
    where?: WhatsAppInstanceWhereInput
    /**
     * Limit how many WhatsAppInstances to update.
     */
    limit?: number
  }

  /**
   * WhatsAppInstance updateManyAndReturn
   */
  export type WhatsAppInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppInstances.
     */
    data: XOR<WhatsAppInstanceUpdateManyMutationInput, WhatsAppInstanceUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppInstances to update
     */
    where?: WhatsAppInstanceWhereInput
    /**
     * Limit how many WhatsAppInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppInstance upsert
   */
  export type WhatsAppInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppInstance to update in case it exists.
     */
    where: WhatsAppInstanceWhereUniqueInput
    /**
     * In case the WhatsAppInstance found by the `where` argument doesn't exist, create a new WhatsAppInstance with this data.
     */
    create: XOR<WhatsAppInstanceCreateInput, WhatsAppInstanceUncheckedCreateInput>
    /**
     * In case the WhatsAppInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppInstanceUpdateInput, WhatsAppInstanceUncheckedUpdateInput>
  }

  /**
   * WhatsAppInstance delete
   */
  export type WhatsAppInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppInstance to delete.
     */
    where: WhatsAppInstanceWhereUniqueInput
  }

  /**
   * WhatsAppInstance deleteMany
   */
  export type WhatsAppInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppInstances to delete
     */
    where?: WhatsAppInstanceWhereInput
    /**
     * Limit how many WhatsAppInstances to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppInstance.contacts
   */
  export type WhatsAppInstance$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    where?: WhatsAppContactWhereInput
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    cursor?: WhatsAppContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * WhatsAppInstance.conversations
   */
  export type WhatsAppInstance$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    where?: WhatsAppConversationWhereInput
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    cursor?: WhatsAppConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppConversationScalarFieldEnum | WhatsAppConversationScalarFieldEnum[]
  }

  /**
   * WhatsAppInstance.messages
   */
  export type WhatsAppInstance$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    where?: WhatsAppMessageWhereInput
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    cursor?: WhatsAppMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageScalarFieldEnum | WhatsAppMessageScalarFieldEnum[]
  }

  /**
   * WhatsAppInstance.imports
   */
  export type WhatsAppInstance$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    where?: WhatsAppImportWhereInput
    orderBy?: WhatsAppImportOrderByWithRelationInput | WhatsAppImportOrderByWithRelationInput[]
    cursor?: WhatsAppImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppImportScalarFieldEnum | WhatsAppImportScalarFieldEnum[]
  }

  /**
   * WhatsAppInstance without action
   */
  export type WhatsAppInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppInstance
     */
    select?: WhatsAppInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppInstance
     */
    omit?: WhatsAppInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppInstanceInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppContact
   */

  export type AggregateWhatsAppContact = {
    _count: WhatsAppContactCountAggregateOutputType | null
    _min: WhatsAppContactMinAggregateOutputType | null
    _max: WhatsAppContactMaxAggregateOutputType | null
  }

  export type WhatsAppContactMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    remoteJid: string | null
    phoneNumber: string | null
    name: string | null
    pushName: string | null
    profilePicUrl: string | null
    isGroup: boolean | null
    lastSeen: Date | null
    isBlocked: boolean | null
    clientId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppContactMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    remoteJid: string | null
    phoneNumber: string | null
    name: string | null
    pushName: string | null
    profilePicUrl: string | null
    isGroup: boolean | null
    lastSeen: Date | null
    isBlocked: boolean | null
    clientId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppContactCountAggregateOutputType = {
    id: number
    instanceId: number
    remoteJid: number
    phoneNumber: number
    name: number
    pushName: number
    profilePicUrl: number
    isGroup: number
    lastSeen: number
    isBlocked: number
    clientId: number
    tags: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppContactMinAggregateInputType = {
    id?: true
    instanceId?: true
    remoteJid?: true
    phoneNumber?: true
    name?: true
    pushName?: true
    profilePicUrl?: true
    isGroup?: true
    lastSeen?: true
    isBlocked?: true
    clientId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppContactMaxAggregateInputType = {
    id?: true
    instanceId?: true
    remoteJid?: true
    phoneNumber?: true
    name?: true
    pushName?: true
    profilePicUrl?: true
    isGroup?: true
    lastSeen?: true
    isBlocked?: true
    clientId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppContactCountAggregateInputType = {
    id?: true
    instanceId?: true
    remoteJid?: true
    phoneNumber?: true
    name?: true
    pushName?: true
    profilePicUrl?: true
    isGroup?: true
    lastSeen?: true
    isBlocked?: true
    clientId?: true
    tags?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppContact to aggregate.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppContacts
    **/
    _count?: true | WhatsAppContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppContactMaxAggregateInputType
  }

  export type GetWhatsAppContactAggregateType<T extends WhatsAppContactAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppContact[P]>
      : GetScalarType<T[P], AggregateWhatsAppContact[P]>
  }




  export type WhatsAppContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppContactWhereInput
    orderBy?: WhatsAppContactOrderByWithAggregationInput | WhatsAppContactOrderByWithAggregationInput[]
    by: WhatsAppContactScalarFieldEnum[] | WhatsAppContactScalarFieldEnum
    having?: WhatsAppContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppContactCountAggregateInputType | true
    _min?: WhatsAppContactMinAggregateInputType
    _max?: WhatsAppContactMaxAggregateInputType
  }

  export type WhatsAppContactGroupByOutputType = {
    id: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name: string | null
    pushName: string | null
    profilePicUrl: string | null
    isGroup: boolean
    lastSeen: Date | null
    isBlocked: boolean
    clientId: string | null
    tags: string[]
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppContactCountAggregateOutputType | null
    _min: WhatsAppContactMinAggregateOutputType | null
    _max: WhatsAppContactMaxAggregateOutputType | null
  }

  type GetWhatsAppContactGroupByPayload<T extends WhatsAppContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppContactGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppContactGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    remoteJid?: boolean
    phoneNumber?: boolean
    name?: boolean
    pushName?: boolean
    profilePicUrl?: boolean
    isGroup?: boolean
    lastSeen?: boolean
    isBlocked?: boolean
    clientId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    client?: boolean | WhatsAppContact$clientArgs<ExtArgs>
    conversations?: boolean | WhatsAppContact$conversationsArgs<ExtArgs>
    messages?: boolean | WhatsAppContact$messagesArgs<ExtArgs>
    imports?: boolean | WhatsAppContact$importsArgs<ExtArgs>
    _count?: boolean | WhatsAppContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppContact"]>

  export type WhatsAppContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    remoteJid?: boolean
    phoneNumber?: boolean
    name?: boolean
    pushName?: boolean
    profilePicUrl?: boolean
    isGroup?: boolean
    lastSeen?: boolean
    isBlocked?: boolean
    clientId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    client?: boolean | WhatsAppContact$clientArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppContact"]>

  export type WhatsAppContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    remoteJid?: boolean
    phoneNumber?: boolean
    name?: boolean
    pushName?: boolean
    profilePicUrl?: boolean
    isGroup?: boolean
    lastSeen?: boolean
    isBlocked?: boolean
    clientId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    client?: boolean | WhatsAppContact$clientArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppContact"]>

  export type WhatsAppContactSelectScalar = {
    id?: boolean
    instanceId?: boolean
    remoteJid?: boolean
    phoneNumber?: boolean
    name?: boolean
    pushName?: boolean
    profilePicUrl?: boolean
    isGroup?: boolean
    lastSeen?: boolean
    isBlocked?: boolean
    clientId?: boolean
    tags?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceId" | "remoteJid" | "phoneNumber" | "name" | "pushName" | "profilePicUrl" | "isGroup" | "lastSeen" | "isBlocked" | "clientId" | "tags" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppContact"]>
  export type WhatsAppContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    client?: boolean | WhatsAppContact$clientArgs<ExtArgs>
    conversations?: boolean | WhatsAppContact$conversationsArgs<ExtArgs>
    messages?: boolean | WhatsAppContact$messagesArgs<ExtArgs>
    imports?: boolean | WhatsAppContact$importsArgs<ExtArgs>
    _count?: boolean | WhatsAppContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    client?: boolean | WhatsAppContact$clientArgs<ExtArgs>
  }
  export type WhatsAppContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    client?: boolean | WhatsAppContact$clientArgs<ExtArgs>
  }

  export type $WhatsAppContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppContact"
    objects: {
      instance: Prisma.$WhatsAppInstancePayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
      conversations: Prisma.$WhatsAppConversationPayload<ExtArgs>[]
      messages: Prisma.$WhatsAppMessagePayload<ExtArgs>[]
      imports: Prisma.$WhatsAppImportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      remoteJid: string
      phoneNumber: string
      name: string | null
      pushName: string | null
      profilePicUrl: string | null
      isGroup: boolean
      lastSeen: Date | null
      isBlocked: boolean
      clientId: string | null
      tags: string[]
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppContact"]>
    composites: {}
  }

  type WhatsAppContactGetPayload<S extends boolean | null | undefined | WhatsAppContactDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppContactPayload, S>

  type WhatsAppContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppContactCountAggregateInputType | true
    }

  export interface WhatsAppContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppContact'], meta: { name: 'WhatsAppContact' } }
    /**
     * Find zero or one WhatsAppContact that matches the filter.
     * @param {WhatsAppContactFindUniqueArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppContactFindUniqueArgs>(args: SelectSubset<T, WhatsAppContactFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppContactFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppContactFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactFindFirstArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppContactFindFirstArgs>(args?: SelectSubset<T, WhatsAppContactFindFirstArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactFindFirstOrThrowArgs} args - Arguments to find a WhatsAppContact
     * @example
     * // Get one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppContactFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppContacts
     * const whatsAppContacts = await prisma.whatsAppContact.findMany()
     * 
     * // Get first 10 WhatsAppContacts
     * const whatsAppContacts = await prisma.whatsAppContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppContactWithIdOnly = await prisma.whatsAppContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppContactFindManyArgs>(args?: SelectSubset<T, WhatsAppContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppContact.
     * @param {WhatsAppContactCreateArgs} args - Arguments to create a WhatsAppContact.
     * @example
     * // Create one WhatsAppContact
     * const WhatsAppContact = await prisma.whatsAppContact.create({
     *   data: {
     *     // ... data to create a WhatsAppContact
     *   }
     * })
     * 
     */
    create<T extends WhatsAppContactCreateArgs>(args: SelectSubset<T, WhatsAppContactCreateArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppContacts.
     * @param {WhatsAppContactCreateManyArgs} args - Arguments to create many WhatsAppContacts.
     * @example
     * // Create many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppContactCreateManyArgs>(args?: SelectSubset<T, WhatsAppContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppContacts and returns the data saved in the database.
     * @param {WhatsAppContactCreateManyAndReturnArgs} args - Arguments to create many WhatsAppContacts.
     * @example
     * // Create many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppContacts and only return the `id`
     * const whatsAppContactWithIdOnly = await prisma.whatsAppContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppContactCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppContact.
     * @param {WhatsAppContactDeleteArgs} args - Arguments to delete one WhatsAppContact.
     * @example
     * // Delete one WhatsAppContact
     * const WhatsAppContact = await prisma.whatsAppContact.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppContact
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppContactDeleteArgs>(args: SelectSubset<T, WhatsAppContactDeleteArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppContact.
     * @param {WhatsAppContactUpdateArgs} args - Arguments to update one WhatsAppContact.
     * @example
     * // Update one WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppContactUpdateArgs>(args: SelectSubset<T, WhatsAppContactUpdateArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppContacts.
     * @param {WhatsAppContactDeleteManyArgs} args - Arguments to filter WhatsAppContacts to delete.
     * @example
     * // Delete a few WhatsAppContacts
     * const { count } = await prisma.whatsAppContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppContactDeleteManyArgs>(args?: SelectSubset<T, WhatsAppContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppContactUpdateManyArgs>(args: SelectSubset<T, WhatsAppContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppContacts and returns the data updated in the database.
     * @param {WhatsAppContactUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppContacts.
     * @example
     * // Update many WhatsAppContacts
     * const whatsAppContact = await prisma.whatsAppContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppContacts and only return the `id`
     * const whatsAppContactWithIdOnly = await prisma.whatsAppContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppContactUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppContact.
     * @param {WhatsAppContactUpsertArgs} args - Arguments to update or create a WhatsAppContact.
     * @example
     * // Update or create a WhatsAppContact
     * const whatsAppContact = await prisma.whatsAppContact.upsert({
     *   create: {
     *     // ... data to create a WhatsAppContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppContact we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppContactUpsertArgs>(args: SelectSubset<T, WhatsAppContactUpsertArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactCountArgs} args - Arguments to filter WhatsAppContacts to count.
     * @example
     * // Count the number of WhatsAppContacts
     * const count = await prisma.whatsAppContact.count({
     *   where: {
     *     // ... the filter for the WhatsAppContacts we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppContactCountArgs>(
      args?: Subset<T, WhatsAppContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppContactAggregateArgs>(args: Subset<T, WhatsAppContactAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppContactAggregateType<T>>

    /**
     * Group by WhatsAppContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppContactGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppContact model
   */
  readonly fields: WhatsAppContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends WhatsAppInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstanceDefaultArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends WhatsAppContact$clientArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppContact$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conversations<T extends WhatsAppContact$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppContact$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends WhatsAppContact$messagesArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppContact$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imports<T extends WhatsAppContact$importsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppContact$importsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppContact model
   */
  interface WhatsAppContactFieldRefs {
    readonly id: FieldRef<"WhatsAppContact", 'String'>
    readonly instanceId: FieldRef<"WhatsAppContact", 'String'>
    readonly remoteJid: FieldRef<"WhatsAppContact", 'String'>
    readonly phoneNumber: FieldRef<"WhatsAppContact", 'String'>
    readonly name: FieldRef<"WhatsAppContact", 'String'>
    readonly pushName: FieldRef<"WhatsAppContact", 'String'>
    readonly profilePicUrl: FieldRef<"WhatsAppContact", 'String'>
    readonly isGroup: FieldRef<"WhatsAppContact", 'Boolean'>
    readonly lastSeen: FieldRef<"WhatsAppContact", 'DateTime'>
    readonly isBlocked: FieldRef<"WhatsAppContact", 'Boolean'>
    readonly clientId: FieldRef<"WhatsAppContact", 'String'>
    readonly tags: FieldRef<"WhatsAppContact", 'String[]'>
    readonly notes: FieldRef<"WhatsAppContact", 'String'>
    readonly createdAt: FieldRef<"WhatsAppContact", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppContact findUnique
   */
  export type WhatsAppContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact findUniqueOrThrow
   */
  export type WhatsAppContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact findFirst
   */
  export type WhatsAppContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppContacts.
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppContacts.
     */
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * WhatsAppContact findFirstOrThrow
   */
  export type WhatsAppContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContact to fetch.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppContacts.
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppContacts.
     */
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * WhatsAppContact findMany
   */
  export type WhatsAppContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppContacts to fetch.
     */
    where?: WhatsAppContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppContacts to fetch.
     */
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppContacts.
     */
    cursor?: WhatsAppContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppContacts.
     */
    skip?: number
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * WhatsAppContact create
   */
  export type WhatsAppContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppContact.
     */
    data: XOR<WhatsAppContactCreateInput, WhatsAppContactUncheckedCreateInput>
  }

  /**
   * WhatsAppContact createMany
   */
  export type WhatsAppContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppContacts.
     */
    data: WhatsAppContactCreateManyInput | WhatsAppContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppContact createManyAndReturn
   */
  export type WhatsAppContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppContacts.
     */
    data: WhatsAppContactCreateManyInput | WhatsAppContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppContact update
   */
  export type WhatsAppContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppContact.
     */
    data: XOR<WhatsAppContactUpdateInput, WhatsAppContactUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppContact to update.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact updateMany
   */
  export type WhatsAppContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppContacts.
     */
    data: XOR<WhatsAppContactUpdateManyMutationInput, WhatsAppContactUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppContacts to update
     */
    where?: WhatsAppContactWhereInput
    /**
     * Limit how many WhatsAppContacts to update.
     */
    limit?: number
  }

  /**
   * WhatsAppContact updateManyAndReturn
   */
  export type WhatsAppContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppContacts.
     */
    data: XOR<WhatsAppContactUpdateManyMutationInput, WhatsAppContactUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppContacts to update
     */
    where?: WhatsAppContactWhereInput
    /**
     * Limit how many WhatsAppContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppContact upsert
   */
  export type WhatsAppContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppContact to update in case it exists.
     */
    where: WhatsAppContactWhereUniqueInput
    /**
     * In case the WhatsAppContact found by the `where` argument doesn't exist, create a new WhatsAppContact with this data.
     */
    create: XOR<WhatsAppContactCreateInput, WhatsAppContactUncheckedCreateInput>
    /**
     * In case the WhatsAppContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppContactUpdateInput, WhatsAppContactUncheckedUpdateInput>
  }

  /**
   * WhatsAppContact delete
   */
  export type WhatsAppContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppContact to delete.
     */
    where: WhatsAppContactWhereUniqueInput
  }

  /**
   * WhatsAppContact deleteMany
   */
  export type WhatsAppContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppContacts to delete
     */
    where?: WhatsAppContactWhereInput
    /**
     * Limit how many WhatsAppContacts to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppContact.client
   */
  export type WhatsAppContact$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * WhatsAppContact.conversations
   */
  export type WhatsAppContact$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    where?: WhatsAppConversationWhereInput
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    cursor?: WhatsAppConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppConversationScalarFieldEnum | WhatsAppConversationScalarFieldEnum[]
  }

  /**
   * WhatsAppContact.messages
   */
  export type WhatsAppContact$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    where?: WhatsAppMessageWhereInput
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    cursor?: WhatsAppMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageScalarFieldEnum | WhatsAppMessageScalarFieldEnum[]
  }

  /**
   * WhatsAppContact.imports
   */
  export type WhatsAppContact$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    where?: WhatsAppImportWhereInput
    orderBy?: WhatsAppImportOrderByWithRelationInput | WhatsAppImportOrderByWithRelationInput[]
    cursor?: WhatsAppImportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppImportScalarFieldEnum | WhatsAppImportScalarFieldEnum[]
  }

  /**
   * WhatsAppContact without action
   */
  export type WhatsAppContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppConversation
   */

  export type AggregateWhatsAppConversation = {
    _count: WhatsAppConversationCountAggregateOutputType | null
    _avg: WhatsAppConversationAvgAggregateOutputType | null
    _sum: WhatsAppConversationSumAggregateOutputType | null
    _min: WhatsAppConversationMinAggregateOutputType | null
    _max: WhatsAppConversationMaxAggregateOutputType | null
  }

  export type WhatsAppConversationAvgAggregateOutputType = {
    unreadCount: number | null
  }

  export type WhatsAppConversationSumAggregateOutputType = {
    unreadCount: number | null
  }

  export type WhatsAppConversationMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    contactId: string | null
    remoteJid: string | null
    title: string | null
    isGroup: boolean | null
    lastMessageId: string | null
    lastMessageAt: Date | null
    unreadCount: number | null
    isArchived: boolean | null
    isPinned: boolean | null
    assignedUserId: string | null
    status: $Enums.WhatsAppConversationStatus | null
    aiEnabled: boolean | null
    currentAgentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppConversationMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    contactId: string | null
    remoteJid: string | null
    title: string | null
    isGroup: boolean | null
    lastMessageId: string | null
    lastMessageAt: Date | null
    unreadCount: number | null
    isArchived: boolean | null
    isPinned: boolean | null
    assignedUserId: string | null
    status: $Enums.WhatsAppConversationStatus | null
    aiEnabled: boolean | null
    currentAgentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppConversationCountAggregateOutputType = {
    id: number
    instanceId: number
    contactId: number
    remoteJid: number
    title: number
    isGroup: number
    lastMessageId: number
    lastMessageAt: number
    unreadCount: number
    isArchived: number
    isPinned: number
    assignedUserId: number
    status: number
    aiEnabled: number
    currentAgentId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppConversationAvgAggregateInputType = {
    unreadCount?: true
  }

  export type WhatsAppConversationSumAggregateInputType = {
    unreadCount?: true
  }

  export type WhatsAppConversationMinAggregateInputType = {
    id?: true
    instanceId?: true
    contactId?: true
    remoteJid?: true
    title?: true
    isGroup?: true
    lastMessageId?: true
    lastMessageAt?: true
    unreadCount?: true
    isArchived?: true
    isPinned?: true
    assignedUserId?: true
    status?: true
    aiEnabled?: true
    currentAgentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppConversationMaxAggregateInputType = {
    id?: true
    instanceId?: true
    contactId?: true
    remoteJid?: true
    title?: true
    isGroup?: true
    lastMessageId?: true
    lastMessageAt?: true
    unreadCount?: true
    isArchived?: true
    isPinned?: true
    assignedUserId?: true
    status?: true
    aiEnabled?: true
    currentAgentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppConversationCountAggregateInputType = {
    id?: true
    instanceId?: true
    contactId?: true
    remoteJid?: true
    title?: true
    isGroup?: true
    lastMessageId?: true
    lastMessageAt?: true
    unreadCount?: true
    isArchived?: true
    isPinned?: true
    assignedUserId?: true
    status?: true
    aiEnabled?: true
    currentAgentId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppConversation to aggregate.
     */
    where?: WhatsAppConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppConversations to fetch.
     */
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppConversations
    **/
    _count?: true | WhatsAppConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppConversationMaxAggregateInputType
  }

  export type GetWhatsAppConversationAggregateType<T extends WhatsAppConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppConversation[P]>
      : GetScalarType<T[P], AggregateWhatsAppConversation[P]>
  }




  export type WhatsAppConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppConversationWhereInput
    orderBy?: WhatsAppConversationOrderByWithAggregationInput | WhatsAppConversationOrderByWithAggregationInput[]
    by: WhatsAppConversationScalarFieldEnum[] | WhatsAppConversationScalarFieldEnum
    having?: WhatsAppConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppConversationCountAggregateInputType | true
    _avg?: WhatsAppConversationAvgAggregateInputType
    _sum?: WhatsAppConversationSumAggregateInputType
    _min?: WhatsAppConversationMinAggregateInputType
    _max?: WhatsAppConversationMaxAggregateInputType
  }

  export type WhatsAppConversationGroupByOutputType = {
    id: string
    instanceId: string
    contactId: string
    remoteJid: string
    title: string | null
    isGroup: boolean
    lastMessageId: string | null
    lastMessageAt: Date | null
    unreadCount: number
    isArchived: boolean
    isPinned: boolean
    assignedUserId: string | null
    status: $Enums.WhatsAppConversationStatus
    aiEnabled: boolean
    currentAgentId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppConversationCountAggregateOutputType | null
    _avg: WhatsAppConversationAvgAggregateOutputType | null
    _sum: WhatsAppConversationSumAggregateOutputType | null
    _min: WhatsAppConversationMinAggregateOutputType | null
    _max: WhatsAppConversationMaxAggregateOutputType | null
  }

  type GetWhatsAppConversationGroupByPayload<T extends WhatsAppConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppConversationGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppConversationGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    title?: boolean
    isGroup?: boolean
    lastMessageId?: boolean
    lastMessageAt?: boolean
    unreadCount?: boolean
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: boolean
    status?: boolean
    aiEnabled?: boolean
    currentAgentId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    assignedUser?: boolean | WhatsAppConversation$assignedUserArgs<ExtArgs>
    currentAgent?: boolean | WhatsAppConversation$currentAgentArgs<ExtArgs>
    messages?: boolean | WhatsAppConversation$messagesArgs<ExtArgs>
    _count?: boolean | WhatsAppConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppConversation"]>

  export type WhatsAppConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    title?: boolean
    isGroup?: boolean
    lastMessageId?: boolean
    lastMessageAt?: boolean
    unreadCount?: boolean
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: boolean
    status?: boolean
    aiEnabled?: boolean
    currentAgentId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    assignedUser?: boolean | WhatsAppConversation$assignedUserArgs<ExtArgs>
    currentAgent?: boolean | WhatsAppConversation$currentAgentArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppConversation"]>

  export type WhatsAppConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    title?: boolean
    isGroup?: boolean
    lastMessageId?: boolean
    lastMessageAt?: boolean
    unreadCount?: boolean
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: boolean
    status?: boolean
    aiEnabled?: boolean
    currentAgentId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    assignedUser?: boolean | WhatsAppConversation$assignedUserArgs<ExtArgs>
    currentAgent?: boolean | WhatsAppConversation$currentAgentArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppConversation"]>

  export type WhatsAppConversationSelectScalar = {
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    title?: boolean
    isGroup?: boolean
    lastMessageId?: boolean
    lastMessageAt?: boolean
    unreadCount?: boolean
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: boolean
    status?: boolean
    aiEnabled?: boolean
    currentAgentId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceId" | "contactId" | "remoteJid" | "title" | "isGroup" | "lastMessageId" | "lastMessageAt" | "unreadCount" | "isArchived" | "isPinned" | "assignedUserId" | "status" | "aiEnabled" | "currentAgentId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppConversation"]>
  export type WhatsAppConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    assignedUser?: boolean | WhatsAppConversation$assignedUserArgs<ExtArgs>
    currentAgent?: boolean | WhatsAppConversation$currentAgentArgs<ExtArgs>
    messages?: boolean | WhatsAppConversation$messagesArgs<ExtArgs>
    _count?: boolean | WhatsAppConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    assignedUser?: boolean | WhatsAppConversation$assignedUserArgs<ExtArgs>
    currentAgent?: boolean | WhatsAppConversation$currentAgentArgs<ExtArgs>
  }
  export type WhatsAppConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    assignedUser?: boolean | WhatsAppConversation$assignedUserArgs<ExtArgs>
    currentAgent?: boolean | WhatsAppConversation$currentAgentArgs<ExtArgs>
  }

  export type $WhatsAppConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppConversation"
    objects: {
      instance: Prisma.$WhatsAppInstancePayload<ExtArgs>
      contact: Prisma.$WhatsAppContactPayload<ExtArgs>
      assignedUser: Prisma.$UserPayload<ExtArgs> | null
      currentAgent: Prisma.$AiAgentPayload<ExtArgs> | null
      messages: Prisma.$WhatsAppMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      contactId: string
      remoteJid: string
      title: string | null
      isGroup: boolean
      lastMessageId: string | null
      lastMessageAt: Date | null
      unreadCount: number
      isArchived: boolean
      isPinned: boolean
      assignedUserId: string | null
      status: $Enums.WhatsAppConversationStatus
      aiEnabled: boolean
      currentAgentId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppConversation"]>
    composites: {}
  }

  type WhatsAppConversationGetPayload<S extends boolean | null | undefined | WhatsAppConversationDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppConversationPayload, S>

  type WhatsAppConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppConversationCountAggregateInputType | true
    }

  export interface WhatsAppConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppConversation'], meta: { name: 'WhatsAppConversation' } }
    /**
     * Find zero or one WhatsAppConversation that matches the filter.
     * @param {WhatsAppConversationFindUniqueArgs} args - Arguments to find a WhatsAppConversation
     * @example
     * // Get one WhatsAppConversation
     * const whatsAppConversation = await prisma.whatsAppConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppConversationFindUniqueArgs>(args: SelectSubset<T, WhatsAppConversationFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppConversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppConversationFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppConversation
     * @example
     * // Get one WhatsAppConversation
     * const whatsAppConversation = await prisma.whatsAppConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppConversationFindFirstArgs} args - Arguments to find a WhatsAppConversation
     * @example
     * // Get one WhatsAppConversation
     * const whatsAppConversation = await prisma.whatsAppConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppConversationFindFirstArgs>(args?: SelectSubset<T, WhatsAppConversationFindFirstArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppConversationFindFirstOrThrowArgs} args - Arguments to find a WhatsAppConversation
     * @example
     * // Get one WhatsAppConversation
     * const whatsAppConversation = await prisma.whatsAppConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppConversations
     * const whatsAppConversations = await prisma.whatsAppConversation.findMany()
     * 
     * // Get first 10 WhatsAppConversations
     * const whatsAppConversations = await prisma.whatsAppConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppConversationWithIdOnly = await prisma.whatsAppConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppConversationFindManyArgs>(args?: SelectSubset<T, WhatsAppConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppConversation.
     * @param {WhatsAppConversationCreateArgs} args - Arguments to create a WhatsAppConversation.
     * @example
     * // Create one WhatsAppConversation
     * const WhatsAppConversation = await prisma.whatsAppConversation.create({
     *   data: {
     *     // ... data to create a WhatsAppConversation
     *   }
     * })
     * 
     */
    create<T extends WhatsAppConversationCreateArgs>(args: SelectSubset<T, WhatsAppConversationCreateArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppConversations.
     * @param {WhatsAppConversationCreateManyArgs} args - Arguments to create many WhatsAppConversations.
     * @example
     * // Create many WhatsAppConversations
     * const whatsAppConversation = await prisma.whatsAppConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppConversationCreateManyArgs>(args?: SelectSubset<T, WhatsAppConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppConversations and returns the data saved in the database.
     * @param {WhatsAppConversationCreateManyAndReturnArgs} args - Arguments to create many WhatsAppConversations.
     * @example
     * // Create many WhatsAppConversations
     * const whatsAppConversation = await prisma.whatsAppConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppConversations and only return the `id`
     * const whatsAppConversationWithIdOnly = await prisma.whatsAppConversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppConversation.
     * @param {WhatsAppConversationDeleteArgs} args - Arguments to delete one WhatsAppConversation.
     * @example
     * // Delete one WhatsAppConversation
     * const WhatsAppConversation = await prisma.whatsAppConversation.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppConversation
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppConversationDeleteArgs>(args: SelectSubset<T, WhatsAppConversationDeleteArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppConversation.
     * @param {WhatsAppConversationUpdateArgs} args - Arguments to update one WhatsAppConversation.
     * @example
     * // Update one WhatsAppConversation
     * const whatsAppConversation = await prisma.whatsAppConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppConversationUpdateArgs>(args: SelectSubset<T, WhatsAppConversationUpdateArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppConversations.
     * @param {WhatsAppConversationDeleteManyArgs} args - Arguments to filter WhatsAppConversations to delete.
     * @example
     * // Delete a few WhatsAppConversations
     * const { count } = await prisma.whatsAppConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppConversationDeleteManyArgs>(args?: SelectSubset<T, WhatsAppConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppConversations
     * const whatsAppConversation = await prisma.whatsAppConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppConversationUpdateManyArgs>(args: SelectSubset<T, WhatsAppConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppConversations and returns the data updated in the database.
     * @param {WhatsAppConversationUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppConversations.
     * @example
     * // Update many WhatsAppConversations
     * const whatsAppConversation = await prisma.whatsAppConversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppConversations and only return the `id`
     * const whatsAppConversationWithIdOnly = await prisma.whatsAppConversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppConversation.
     * @param {WhatsAppConversationUpsertArgs} args - Arguments to update or create a WhatsAppConversation.
     * @example
     * // Update or create a WhatsAppConversation
     * const whatsAppConversation = await prisma.whatsAppConversation.upsert({
     *   create: {
     *     // ... data to create a WhatsAppConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppConversation we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppConversationUpsertArgs>(args: SelectSubset<T, WhatsAppConversationUpsertArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppConversationCountArgs} args - Arguments to filter WhatsAppConversations to count.
     * @example
     * // Count the number of WhatsAppConversations
     * const count = await prisma.whatsAppConversation.count({
     *   where: {
     *     // ... the filter for the WhatsAppConversations we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppConversationCountArgs>(
      args?: Subset<T, WhatsAppConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppConversationAggregateArgs>(args: Subset<T, WhatsAppConversationAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppConversationAggregateType<T>>

    /**
     * Group by WhatsAppConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppConversationGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppConversation model
   */
  readonly fields: WhatsAppConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends WhatsAppInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstanceDefaultArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends WhatsAppContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppContactDefaultArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedUser<T extends WhatsAppConversation$assignedUserArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppConversation$assignedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currentAgent<T extends WhatsAppConversation$currentAgentArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppConversation$currentAgentArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends WhatsAppConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppConversation model
   */
  interface WhatsAppConversationFieldRefs {
    readonly id: FieldRef<"WhatsAppConversation", 'String'>
    readonly instanceId: FieldRef<"WhatsAppConversation", 'String'>
    readonly contactId: FieldRef<"WhatsAppConversation", 'String'>
    readonly remoteJid: FieldRef<"WhatsAppConversation", 'String'>
    readonly title: FieldRef<"WhatsAppConversation", 'String'>
    readonly isGroup: FieldRef<"WhatsAppConversation", 'Boolean'>
    readonly lastMessageId: FieldRef<"WhatsAppConversation", 'String'>
    readonly lastMessageAt: FieldRef<"WhatsAppConversation", 'DateTime'>
    readonly unreadCount: FieldRef<"WhatsAppConversation", 'Int'>
    readonly isArchived: FieldRef<"WhatsAppConversation", 'Boolean'>
    readonly isPinned: FieldRef<"WhatsAppConversation", 'Boolean'>
    readonly assignedUserId: FieldRef<"WhatsAppConversation", 'String'>
    readonly status: FieldRef<"WhatsAppConversation", 'WhatsAppConversationStatus'>
    readonly aiEnabled: FieldRef<"WhatsAppConversation", 'Boolean'>
    readonly currentAgentId: FieldRef<"WhatsAppConversation", 'String'>
    readonly metadata: FieldRef<"WhatsAppConversation", 'Json'>
    readonly createdAt: FieldRef<"WhatsAppConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppConversation findUnique
   */
  export type WhatsAppConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppConversation to fetch.
     */
    where: WhatsAppConversationWhereUniqueInput
  }

  /**
   * WhatsAppConversation findUniqueOrThrow
   */
  export type WhatsAppConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppConversation to fetch.
     */
    where: WhatsAppConversationWhereUniqueInput
  }

  /**
   * WhatsAppConversation findFirst
   */
  export type WhatsAppConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppConversation to fetch.
     */
    where?: WhatsAppConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppConversations to fetch.
     */
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppConversations.
     */
    cursor?: WhatsAppConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppConversations.
     */
    distinct?: WhatsAppConversationScalarFieldEnum | WhatsAppConversationScalarFieldEnum[]
  }

  /**
   * WhatsAppConversation findFirstOrThrow
   */
  export type WhatsAppConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppConversation to fetch.
     */
    where?: WhatsAppConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppConversations to fetch.
     */
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppConversations.
     */
    cursor?: WhatsAppConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppConversations.
     */
    distinct?: WhatsAppConversationScalarFieldEnum | WhatsAppConversationScalarFieldEnum[]
  }

  /**
   * WhatsAppConversation findMany
   */
  export type WhatsAppConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppConversations to fetch.
     */
    where?: WhatsAppConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppConversations to fetch.
     */
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppConversations.
     */
    cursor?: WhatsAppConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppConversations.
     */
    skip?: number
    distinct?: WhatsAppConversationScalarFieldEnum | WhatsAppConversationScalarFieldEnum[]
  }

  /**
   * WhatsAppConversation create
   */
  export type WhatsAppConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppConversation.
     */
    data: XOR<WhatsAppConversationCreateInput, WhatsAppConversationUncheckedCreateInput>
  }

  /**
   * WhatsAppConversation createMany
   */
  export type WhatsAppConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppConversations.
     */
    data: WhatsAppConversationCreateManyInput | WhatsAppConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppConversation createManyAndReturn
   */
  export type WhatsAppConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppConversations.
     */
    data: WhatsAppConversationCreateManyInput | WhatsAppConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppConversation update
   */
  export type WhatsAppConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppConversation.
     */
    data: XOR<WhatsAppConversationUpdateInput, WhatsAppConversationUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppConversation to update.
     */
    where: WhatsAppConversationWhereUniqueInput
  }

  /**
   * WhatsAppConversation updateMany
   */
  export type WhatsAppConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppConversations.
     */
    data: XOR<WhatsAppConversationUpdateManyMutationInput, WhatsAppConversationUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppConversations to update
     */
    where?: WhatsAppConversationWhereInput
    /**
     * Limit how many WhatsAppConversations to update.
     */
    limit?: number
  }

  /**
   * WhatsAppConversation updateManyAndReturn
   */
  export type WhatsAppConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppConversations.
     */
    data: XOR<WhatsAppConversationUpdateManyMutationInput, WhatsAppConversationUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppConversations to update
     */
    where?: WhatsAppConversationWhereInput
    /**
     * Limit how many WhatsAppConversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppConversation upsert
   */
  export type WhatsAppConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppConversation to update in case it exists.
     */
    where: WhatsAppConversationWhereUniqueInput
    /**
     * In case the WhatsAppConversation found by the `where` argument doesn't exist, create a new WhatsAppConversation with this data.
     */
    create: XOR<WhatsAppConversationCreateInput, WhatsAppConversationUncheckedCreateInput>
    /**
     * In case the WhatsAppConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppConversationUpdateInput, WhatsAppConversationUncheckedUpdateInput>
  }

  /**
   * WhatsAppConversation delete
   */
  export type WhatsAppConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppConversation to delete.
     */
    where: WhatsAppConversationWhereUniqueInput
  }

  /**
   * WhatsAppConversation deleteMany
   */
  export type WhatsAppConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppConversations to delete
     */
    where?: WhatsAppConversationWhereInput
    /**
     * Limit how many WhatsAppConversations to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppConversation.assignedUser
   */
  export type WhatsAppConversation$assignedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WhatsAppConversation.currentAgent
   */
  export type WhatsAppConversation$currentAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    where?: AiAgentWhereInput
  }

  /**
   * WhatsAppConversation.messages
   */
  export type WhatsAppConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    where?: WhatsAppMessageWhereInput
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    cursor?: WhatsAppMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageScalarFieldEnum | WhatsAppMessageScalarFieldEnum[]
  }

  /**
   * WhatsAppConversation without action
   */
  export type WhatsAppConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppMessage
   */

  export type AggregateWhatsAppMessage = {
    _count: WhatsAppMessageCountAggregateOutputType | null
    _avg: WhatsAppMessageAvgAggregateOutputType | null
    _sum: WhatsAppMessageSumAggregateOutputType | null
    _min: WhatsAppMessageMinAggregateOutputType | null
    _max: WhatsAppMessageMaxAggregateOutputType | null
  }

  export type WhatsAppMessageAvgAggregateOutputType = {
    mediaSize: number | null
  }

  export type WhatsAppMessageSumAggregateOutputType = {
    mediaSize: number | null
  }

  export type WhatsAppMessageMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    conversationId: string | null
    contactId: string | null
    remoteJid: string | null
    messageId: string | null
    fromMe: boolean | null
    messageType: $Enums.WhatsAppMessageType | null
    content: string | null
    quotedMessageId: string | null
    mediaUrl: string | null
    mediaSize: number | null
    mimetype: string | null
    fileName: string | null
    caption: string | null
    isForwarded: boolean | null
    timestamp: Date | null
    status: $Enums.WhatsAppMessageStatus | null
    isDeleted: boolean | null
    isEdited: boolean | null
    aiResponse: boolean | null
    toolExecutionId: string | null
    importedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppMessageMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    conversationId: string | null
    contactId: string | null
    remoteJid: string | null
    messageId: string | null
    fromMe: boolean | null
    messageType: $Enums.WhatsAppMessageType | null
    content: string | null
    quotedMessageId: string | null
    mediaUrl: string | null
    mediaSize: number | null
    mimetype: string | null
    fileName: string | null
    caption: string | null
    isForwarded: boolean | null
    timestamp: Date | null
    status: $Enums.WhatsAppMessageStatus | null
    isDeleted: boolean | null
    isEdited: boolean | null
    aiResponse: boolean | null
    toolExecutionId: string | null
    importedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppMessageCountAggregateOutputType = {
    id: number
    instanceId: number
    conversationId: number
    contactId: number
    remoteJid: number
    messageId: number
    fromMe: number
    messageType: number
    content: number
    quotedMessageId: number
    mediaUrl: number
    mediaSize: number
    mimetype: number
    fileName: number
    caption: number
    location: number
    isForwarded: number
    timestamp: number
    status: number
    isDeleted: number
    isEdited: number
    aiResponse: number
    toolExecutionId: number
    importedFrom: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppMessageAvgAggregateInputType = {
    mediaSize?: true
  }

  export type WhatsAppMessageSumAggregateInputType = {
    mediaSize?: true
  }

  export type WhatsAppMessageMinAggregateInputType = {
    id?: true
    instanceId?: true
    conversationId?: true
    contactId?: true
    remoteJid?: true
    messageId?: true
    fromMe?: true
    messageType?: true
    content?: true
    quotedMessageId?: true
    mediaUrl?: true
    mediaSize?: true
    mimetype?: true
    fileName?: true
    caption?: true
    isForwarded?: true
    timestamp?: true
    status?: true
    isDeleted?: true
    isEdited?: true
    aiResponse?: true
    toolExecutionId?: true
    importedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppMessageMaxAggregateInputType = {
    id?: true
    instanceId?: true
    conversationId?: true
    contactId?: true
    remoteJid?: true
    messageId?: true
    fromMe?: true
    messageType?: true
    content?: true
    quotedMessageId?: true
    mediaUrl?: true
    mediaSize?: true
    mimetype?: true
    fileName?: true
    caption?: true
    isForwarded?: true
    timestamp?: true
    status?: true
    isDeleted?: true
    isEdited?: true
    aiResponse?: true
    toolExecutionId?: true
    importedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppMessageCountAggregateInputType = {
    id?: true
    instanceId?: true
    conversationId?: true
    contactId?: true
    remoteJid?: true
    messageId?: true
    fromMe?: true
    messageType?: true
    content?: true
    quotedMessageId?: true
    mediaUrl?: true
    mediaSize?: true
    mimetype?: true
    fileName?: true
    caption?: true
    location?: true
    isForwarded?: true
    timestamp?: true
    status?: true
    isDeleted?: true
    isEdited?: true
    aiResponse?: true
    toolExecutionId?: true
    importedFrom?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppMessage to aggregate.
     */
    where?: WhatsAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessages to fetch.
     */
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppMessages
    **/
    _count?: true | WhatsAppMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppMessageMaxAggregateInputType
  }

  export type GetWhatsAppMessageAggregateType<T extends WhatsAppMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppMessage[P]>
      : GetScalarType<T[P], AggregateWhatsAppMessage[P]>
  }




  export type WhatsAppMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageWhereInput
    orderBy?: WhatsAppMessageOrderByWithAggregationInput | WhatsAppMessageOrderByWithAggregationInput[]
    by: WhatsAppMessageScalarFieldEnum[] | WhatsAppMessageScalarFieldEnum
    having?: WhatsAppMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppMessageCountAggregateInputType | true
    _avg?: WhatsAppMessageAvgAggregateInputType
    _sum?: WhatsAppMessageSumAggregateInputType
    _min?: WhatsAppMessageMinAggregateInputType
    _max?: WhatsAppMessageMaxAggregateInputType
  }

  export type WhatsAppMessageGroupByOutputType = {
    id: string
    instanceId: string
    conversationId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content: string | null
    quotedMessageId: string | null
    mediaUrl: string | null
    mediaSize: number | null
    mimetype: string | null
    fileName: string | null
    caption: string | null
    location: JsonValue | null
    isForwarded: boolean
    timestamp: Date
    status: $Enums.WhatsAppMessageStatus
    isDeleted: boolean
    isEdited: boolean
    aiResponse: boolean
    toolExecutionId: string | null
    importedFrom: string | null
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppMessageCountAggregateOutputType | null
    _avg: WhatsAppMessageAvgAggregateOutputType | null
    _sum: WhatsAppMessageSumAggregateOutputType | null
    _min: WhatsAppMessageMinAggregateOutputType | null
    _max: WhatsAppMessageMaxAggregateOutputType | null
  }

  type GetWhatsAppMessageGroupByPayload<T extends WhatsAppMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppMessageGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppMessageGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    conversationId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    messageId?: boolean
    fromMe?: boolean
    messageType?: boolean
    content?: boolean
    quotedMessageId?: boolean
    mediaUrl?: boolean
    mediaSize?: boolean
    mimetype?: boolean
    fileName?: boolean
    caption?: boolean
    location?: boolean
    isForwarded?: boolean
    timestamp?: boolean
    status?: boolean
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: boolean
    importedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    conversation?: boolean | WhatsAppConversationDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    toolExecution?: boolean | WhatsAppMessage$toolExecutionArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessage"]>

  export type WhatsAppMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    conversationId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    messageId?: boolean
    fromMe?: boolean
    messageType?: boolean
    content?: boolean
    quotedMessageId?: boolean
    mediaUrl?: boolean
    mediaSize?: boolean
    mimetype?: boolean
    fileName?: boolean
    caption?: boolean
    location?: boolean
    isForwarded?: boolean
    timestamp?: boolean
    status?: boolean
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: boolean
    importedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    conversation?: boolean | WhatsAppConversationDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    toolExecution?: boolean | WhatsAppMessage$toolExecutionArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessage"]>

  export type WhatsAppMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    conversationId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    messageId?: boolean
    fromMe?: boolean
    messageType?: boolean
    content?: boolean
    quotedMessageId?: boolean
    mediaUrl?: boolean
    mediaSize?: boolean
    mimetype?: boolean
    fileName?: boolean
    caption?: boolean
    location?: boolean
    isForwarded?: boolean
    timestamp?: boolean
    status?: boolean
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: boolean
    importedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    conversation?: boolean | WhatsAppConversationDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    toolExecution?: boolean | WhatsAppMessage$toolExecutionArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessage"]>

  export type WhatsAppMessageSelectScalar = {
    id?: boolean
    instanceId?: boolean
    conversationId?: boolean
    contactId?: boolean
    remoteJid?: boolean
    messageId?: boolean
    fromMe?: boolean
    messageType?: boolean
    content?: boolean
    quotedMessageId?: boolean
    mediaUrl?: boolean
    mediaSize?: boolean
    mimetype?: boolean
    fileName?: boolean
    caption?: boolean
    location?: boolean
    isForwarded?: boolean
    timestamp?: boolean
    status?: boolean
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: boolean
    importedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceId" | "conversationId" | "contactId" | "remoteJid" | "messageId" | "fromMe" | "messageType" | "content" | "quotedMessageId" | "mediaUrl" | "mediaSize" | "mimetype" | "fileName" | "caption" | "location" | "isForwarded" | "timestamp" | "status" | "isDeleted" | "isEdited" | "aiResponse" | "toolExecutionId" | "importedFrom" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppMessage"]>
  export type WhatsAppMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    conversation?: boolean | WhatsAppConversationDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    toolExecution?: boolean | WhatsAppMessage$toolExecutionArgs<ExtArgs>
  }
  export type WhatsAppMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    conversation?: boolean | WhatsAppConversationDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    toolExecution?: boolean | WhatsAppMessage$toolExecutionArgs<ExtArgs>
  }
  export type WhatsAppMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    conversation?: boolean | WhatsAppConversationDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    toolExecution?: boolean | WhatsAppMessage$toolExecutionArgs<ExtArgs>
  }

  export type $WhatsAppMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppMessage"
    objects: {
      instance: Prisma.$WhatsAppInstancePayload<ExtArgs>
      conversation: Prisma.$WhatsAppConversationPayload<ExtArgs>
      contact: Prisma.$WhatsAppContactPayload<ExtArgs>
      toolExecution: Prisma.$ToolExecutionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      conversationId: string
      contactId: string
      remoteJid: string
      messageId: string
      fromMe: boolean
      messageType: $Enums.WhatsAppMessageType
      content: string | null
      quotedMessageId: string | null
      mediaUrl: string | null
      mediaSize: number | null
      mimetype: string | null
      fileName: string | null
      caption: string | null
      location: Prisma.JsonValue | null
      isForwarded: boolean
      timestamp: Date
      status: $Enums.WhatsAppMessageStatus
      isDeleted: boolean
      isEdited: boolean
      aiResponse: boolean
      toolExecutionId: string | null
      importedFrom: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppMessage"]>
    composites: {}
  }

  type WhatsAppMessageGetPayload<S extends boolean | null | undefined | WhatsAppMessageDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppMessagePayload, S>

  type WhatsAppMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppMessageCountAggregateInputType | true
    }

  export interface WhatsAppMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppMessage'], meta: { name: 'WhatsAppMessage' } }
    /**
     * Find zero or one WhatsAppMessage that matches the filter.
     * @param {WhatsAppMessageFindUniqueArgs} args - Arguments to find a WhatsAppMessage
     * @example
     * // Get one WhatsAppMessage
     * const whatsAppMessage = await prisma.whatsAppMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppMessageFindUniqueArgs>(args: SelectSubset<T, WhatsAppMessageFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppMessageFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppMessage
     * @example
     * // Get one WhatsAppMessage
     * const whatsAppMessage = await prisma.whatsAppMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageFindFirstArgs} args - Arguments to find a WhatsAppMessage
     * @example
     * // Get one WhatsAppMessage
     * const whatsAppMessage = await prisma.whatsAppMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppMessageFindFirstArgs>(args?: SelectSubset<T, WhatsAppMessageFindFirstArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageFindFirstOrThrowArgs} args - Arguments to find a WhatsAppMessage
     * @example
     * // Get one WhatsAppMessage
     * const whatsAppMessage = await prisma.whatsAppMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppMessages
     * const whatsAppMessages = await prisma.whatsAppMessage.findMany()
     * 
     * // Get first 10 WhatsAppMessages
     * const whatsAppMessages = await prisma.whatsAppMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppMessageWithIdOnly = await prisma.whatsAppMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppMessageFindManyArgs>(args?: SelectSubset<T, WhatsAppMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppMessage.
     * @param {WhatsAppMessageCreateArgs} args - Arguments to create a WhatsAppMessage.
     * @example
     * // Create one WhatsAppMessage
     * const WhatsAppMessage = await prisma.whatsAppMessage.create({
     *   data: {
     *     // ... data to create a WhatsAppMessage
     *   }
     * })
     * 
     */
    create<T extends WhatsAppMessageCreateArgs>(args: SelectSubset<T, WhatsAppMessageCreateArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppMessages.
     * @param {WhatsAppMessageCreateManyArgs} args - Arguments to create many WhatsAppMessages.
     * @example
     * // Create many WhatsAppMessages
     * const whatsAppMessage = await prisma.whatsAppMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppMessageCreateManyArgs>(args?: SelectSubset<T, WhatsAppMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppMessages and returns the data saved in the database.
     * @param {WhatsAppMessageCreateManyAndReturnArgs} args - Arguments to create many WhatsAppMessages.
     * @example
     * // Create many WhatsAppMessages
     * const whatsAppMessage = await prisma.whatsAppMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppMessages and only return the `id`
     * const whatsAppMessageWithIdOnly = await prisma.whatsAppMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppMessage.
     * @param {WhatsAppMessageDeleteArgs} args - Arguments to delete one WhatsAppMessage.
     * @example
     * // Delete one WhatsAppMessage
     * const WhatsAppMessage = await prisma.whatsAppMessage.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppMessage
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppMessageDeleteArgs>(args: SelectSubset<T, WhatsAppMessageDeleteArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppMessage.
     * @param {WhatsAppMessageUpdateArgs} args - Arguments to update one WhatsAppMessage.
     * @example
     * // Update one WhatsAppMessage
     * const whatsAppMessage = await prisma.whatsAppMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppMessageUpdateArgs>(args: SelectSubset<T, WhatsAppMessageUpdateArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppMessages.
     * @param {WhatsAppMessageDeleteManyArgs} args - Arguments to filter WhatsAppMessages to delete.
     * @example
     * // Delete a few WhatsAppMessages
     * const { count } = await prisma.whatsAppMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppMessageDeleteManyArgs>(args?: SelectSubset<T, WhatsAppMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppMessages
     * const whatsAppMessage = await prisma.whatsAppMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppMessageUpdateManyArgs>(args: SelectSubset<T, WhatsAppMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppMessages and returns the data updated in the database.
     * @param {WhatsAppMessageUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppMessages.
     * @example
     * // Update many WhatsAppMessages
     * const whatsAppMessage = await prisma.whatsAppMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppMessages and only return the `id`
     * const whatsAppMessageWithIdOnly = await prisma.whatsAppMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppMessage.
     * @param {WhatsAppMessageUpsertArgs} args - Arguments to update or create a WhatsAppMessage.
     * @example
     * // Update or create a WhatsAppMessage
     * const whatsAppMessage = await prisma.whatsAppMessage.upsert({
     *   create: {
     *     // ... data to create a WhatsAppMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppMessage we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppMessageUpsertArgs>(args: SelectSubset<T, WhatsAppMessageUpsertArgs<ExtArgs>>): Prisma__WhatsAppMessageClient<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageCountArgs} args - Arguments to filter WhatsAppMessages to count.
     * @example
     * // Count the number of WhatsAppMessages
     * const count = await prisma.whatsAppMessage.count({
     *   where: {
     *     // ... the filter for the WhatsAppMessages we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppMessageCountArgs>(
      args?: Subset<T, WhatsAppMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppMessageAggregateArgs>(args: Subset<T, WhatsAppMessageAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppMessageAggregateType<T>>

    /**
     * Group by WhatsAppMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppMessageGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppMessage model
   */
  readonly fields: WhatsAppMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends WhatsAppInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstanceDefaultArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversation<T extends WhatsAppConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppConversationDefaultArgs<ExtArgs>>): Prisma__WhatsAppConversationClient<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends WhatsAppContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppContactDefaultArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toolExecution<T extends WhatsAppMessage$toolExecutionArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppMessage$toolExecutionArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppMessage model
   */
  interface WhatsAppMessageFieldRefs {
    readonly id: FieldRef<"WhatsAppMessage", 'String'>
    readonly instanceId: FieldRef<"WhatsAppMessage", 'String'>
    readonly conversationId: FieldRef<"WhatsAppMessage", 'String'>
    readonly contactId: FieldRef<"WhatsAppMessage", 'String'>
    readonly remoteJid: FieldRef<"WhatsAppMessage", 'String'>
    readonly messageId: FieldRef<"WhatsAppMessage", 'String'>
    readonly fromMe: FieldRef<"WhatsAppMessage", 'Boolean'>
    readonly messageType: FieldRef<"WhatsAppMessage", 'WhatsAppMessageType'>
    readonly content: FieldRef<"WhatsAppMessage", 'String'>
    readonly quotedMessageId: FieldRef<"WhatsAppMessage", 'String'>
    readonly mediaUrl: FieldRef<"WhatsAppMessage", 'String'>
    readonly mediaSize: FieldRef<"WhatsAppMessage", 'Int'>
    readonly mimetype: FieldRef<"WhatsAppMessage", 'String'>
    readonly fileName: FieldRef<"WhatsAppMessage", 'String'>
    readonly caption: FieldRef<"WhatsAppMessage", 'String'>
    readonly location: FieldRef<"WhatsAppMessage", 'Json'>
    readonly isForwarded: FieldRef<"WhatsAppMessage", 'Boolean'>
    readonly timestamp: FieldRef<"WhatsAppMessage", 'DateTime'>
    readonly status: FieldRef<"WhatsAppMessage", 'WhatsAppMessageStatus'>
    readonly isDeleted: FieldRef<"WhatsAppMessage", 'Boolean'>
    readonly isEdited: FieldRef<"WhatsAppMessage", 'Boolean'>
    readonly aiResponse: FieldRef<"WhatsAppMessage", 'Boolean'>
    readonly toolExecutionId: FieldRef<"WhatsAppMessage", 'String'>
    readonly importedFrom: FieldRef<"WhatsAppMessage", 'String'>
    readonly createdAt: FieldRef<"WhatsAppMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppMessage findUnique
   */
  export type WhatsAppMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessage to fetch.
     */
    where: WhatsAppMessageWhereUniqueInput
  }

  /**
   * WhatsAppMessage findUniqueOrThrow
   */
  export type WhatsAppMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessage to fetch.
     */
    where: WhatsAppMessageWhereUniqueInput
  }

  /**
   * WhatsAppMessage findFirst
   */
  export type WhatsAppMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessage to fetch.
     */
    where?: WhatsAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessages to fetch.
     */
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppMessages.
     */
    cursor?: WhatsAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppMessages.
     */
    distinct?: WhatsAppMessageScalarFieldEnum | WhatsAppMessageScalarFieldEnum[]
  }

  /**
   * WhatsAppMessage findFirstOrThrow
   */
  export type WhatsAppMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessage to fetch.
     */
    where?: WhatsAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessages to fetch.
     */
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppMessages.
     */
    cursor?: WhatsAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppMessages.
     */
    distinct?: WhatsAppMessageScalarFieldEnum | WhatsAppMessageScalarFieldEnum[]
  }

  /**
   * WhatsAppMessage findMany
   */
  export type WhatsAppMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessages to fetch.
     */
    where?: WhatsAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessages to fetch.
     */
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppMessages.
     */
    cursor?: WhatsAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessages.
     */
    skip?: number
    distinct?: WhatsAppMessageScalarFieldEnum | WhatsAppMessageScalarFieldEnum[]
  }

  /**
   * WhatsAppMessage create
   */
  export type WhatsAppMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppMessage.
     */
    data: XOR<WhatsAppMessageCreateInput, WhatsAppMessageUncheckedCreateInput>
  }

  /**
   * WhatsAppMessage createMany
   */
  export type WhatsAppMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppMessages.
     */
    data: WhatsAppMessageCreateManyInput | WhatsAppMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppMessage createManyAndReturn
   */
  export type WhatsAppMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppMessages.
     */
    data: WhatsAppMessageCreateManyInput | WhatsAppMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppMessage update
   */
  export type WhatsAppMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppMessage.
     */
    data: XOR<WhatsAppMessageUpdateInput, WhatsAppMessageUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppMessage to update.
     */
    where: WhatsAppMessageWhereUniqueInput
  }

  /**
   * WhatsAppMessage updateMany
   */
  export type WhatsAppMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppMessages.
     */
    data: XOR<WhatsAppMessageUpdateManyMutationInput, WhatsAppMessageUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppMessages to update
     */
    where?: WhatsAppMessageWhereInput
    /**
     * Limit how many WhatsAppMessages to update.
     */
    limit?: number
  }

  /**
   * WhatsAppMessage updateManyAndReturn
   */
  export type WhatsAppMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppMessages.
     */
    data: XOR<WhatsAppMessageUpdateManyMutationInput, WhatsAppMessageUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppMessages to update
     */
    where?: WhatsAppMessageWhereInput
    /**
     * Limit how many WhatsAppMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppMessage upsert
   */
  export type WhatsAppMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppMessage to update in case it exists.
     */
    where: WhatsAppMessageWhereUniqueInput
    /**
     * In case the WhatsAppMessage found by the `where` argument doesn't exist, create a new WhatsAppMessage with this data.
     */
    create: XOR<WhatsAppMessageCreateInput, WhatsAppMessageUncheckedCreateInput>
    /**
     * In case the WhatsAppMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppMessageUpdateInput, WhatsAppMessageUncheckedUpdateInput>
  }

  /**
   * WhatsAppMessage delete
   */
  export type WhatsAppMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppMessage to delete.
     */
    where: WhatsAppMessageWhereUniqueInput
  }

  /**
   * WhatsAppMessage deleteMany
   */
  export type WhatsAppMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppMessages to delete
     */
    where?: WhatsAppMessageWhereInput
    /**
     * Limit how many WhatsAppMessages to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppMessage.toolExecution
   */
  export type WhatsAppMessage$toolExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    where?: ToolExecutionWhereInput
  }

  /**
   * WhatsAppMessage without action
   */
  export type WhatsAppMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppImport
   */

  export type AggregateWhatsAppImport = {
    _count: WhatsAppImportCountAggregateOutputType | null
    _avg: WhatsAppImportAvgAggregateOutputType | null
    _sum: WhatsAppImportSumAggregateOutputType | null
    _min: WhatsAppImportMinAggregateOutputType | null
    _max: WhatsAppImportMaxAggregateOutputType | null
  }

  export type WhatsAppImportAvgAggregateOutputType = {
    fileSize: number | null
    totalMessages: number | null
    importedMessages: number | null
    failedMessages: number | null
  }

  export type WhatsAppImportSumAggregateOutputType = {
    fileSize: number | null
    totalMessages: number | null
    importedMessages: number | null
    failedMessages: number | null
  }

  export type WhatsAppImportMinAggregateOutputType = {
    id: string | null
    instanceId: string | null
    contactId: string | null
    fileName: string | null
    fileSize: number | null
    totalMessages: number | null
    importedMessages: number | null
    failedMessages: number | null
    status: $Enums.WhatsAppImportStatus | null
    errorMessage: string | null
    uploadedById: string | null
    importedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppImportMaxAggregateOutputType = {
    id: string | null
    instanceId: string | null
    contactId: string | null
    fileName: string | null
    fileSize: number | null
    totalMessages: number | null
    importedMessages: number | null
    failedMessages: number | null
    status: $Enums.WhatsAppImportStatus | null
    errorMessage: string | null
    uploadedById: string | null
    importedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppImportCountAggregateOutputType = {
    id: number
    instanceId: number
    contactId: number
    fileName: number
    fileSize: number
    totalMessages: number
    importedMessages: number
    failedMessages: number
    mediaFiles: number
    status: number
    errorMessage: number
    uploadedById: number
    importedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppImportAvgAggregateInputType = {
    fileSize?: true
    totalMessages?: true
    importedMessages?: true
    failedMessages?: true
  }

  export type WhatsAppImportSumAggregateInputType = {
    fileSize?: true
    totalMessages?: true
    importedMessages?: true
    failedMessages?: true
  }

  export type WhatsAppImportMinAggregateInputType = {
    id?: true
    instanceId?: true
    contactId?: true
    fileName?: true
    fileSize?: true
    totalMessages?: true
    importedMessages?: true
    failedMessages?: true
    status?: true
    errorMessage?: true
    uploadedById?: true
    importedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppImportMaxAggregateInputType = {
    id?: true
    instanceId?: true
    contactId?: true
    fileName?: true
    fileSize?: true
    totalMessages?: true
    importedMessages?: true
    failedMessages?: true
    status?: true
    errorMessage?: true
    uploadedById?: true
    importedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppImportCountAggregateInputType = {
    id?: true
    instanceId?: true
    contactId?: true
    fileName?: true
    fileSize?: true
    totalMessages?: true
    importedMessages?: true
    failedMessages?: true
    mediaFiles?: true
    status?: true
    errorMessage?: true
    uploadedById?: true
    importedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppImportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppImport to aggregate.
     */
    where?: WhatsAppImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppImports to fetch.
     */
    orderBy?: WhatsAppImportOrderByWithRelationInput | WhatsAppImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppImports
    **/
    _count?: true | WhatsAppImportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppImportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppImportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppImportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppImportMaxAggregateInputType
  }

  export type GetWhatsAppImportAggregateType<T extends WhatsAppImportAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppImport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppImport[P]>
      : GetScalarType<T[P], AggregateWhatsAppImport[P]>
  }




  export type WhatsAppImportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppImportWhereInput
    orderBy?: WhatsAppImportOrderByWithAggregationInput | WhatsAppImportOrderByWithAggregationInput[]
    by: WhatsAppImportScalarFieldEnum[] | WhatsAppImportScalarFieldEnum
    having?: WhatsAppImportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppImportCountAggregateInputType | true
    _avg?: WhatsAppImportAvgAggregateInputType
    _sum?: WhatsAppImportSumAggregateInputType
    _min?: WhatsAppImportMinAggregateInputType
    _max?: WhatsAppImportMaxAggregateInputType
  }

  export type WhatsAppImportGroupByOutputType = {
    id: string
    instanceId: string
    contactId: string
    fileName: string
    fileSize: number
    totalMessages: number
    importedMessages: number
    failedMessages: number
    mediaFiles: string[]
    status: $Enums.WhatsAppImportStatus
    errorMessage: string | null
    uploadedById: string
    importedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppImportCountAggregateOutputType | null
    _avg: WhatsAppImportAvgAggregateOutputType | null
    _sum: WhatsAppImportSumAggregateOutputType | null
    _min: WhatsAppImportMinAggregateOutputType | null
    _max: WhatsAppImportMaxAggregateOutputType | null
  }

  type GetWhatsAppImportGroupByPayload<T extends WhatsAppImportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppImportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppImportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppImportGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppImportGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppImportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalMessages?: boolean
    importedMessages?: boolean
    failedMessages?: boolean
    mediaFiles?: boolean
    status?: boolean
    errorMessage?: boolean
    uploadedById?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppImport"]>

  export type WhatsAppImportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalMessages?: boolean
    importedMessages?: boolean
    failedMessages?: boolean
    mediaFiles?: boolean
    status?: boolean
    errorMessage?: boolean
    uploadedById?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppImport"]>

  export type WhatsAppImportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalMessages?: boolean
    importedMessages?: boolean
    failedMessages?: boolean
    mediaFiles?: boolean
    status?: boolean
    errorMessage?: boolean
    uploadedById?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppImport"]>

  export type WhatsAppImportSelectScalar = {
    id?: boolean
    instanceId?: boolean
    contactId?: boolean
    fileName?: boolean
    fileSize?: boolean
    totalMessages?: boolean
    importedMessages?: boolean
    failedMessages?: boolean
    mediaFiles?: boolean
    status?: boolean
    errorMessage?: boolean
    uploadedById?: boolean
    importedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppImportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceId" | "contactId" | "fileName" | "fileSize" | "totalMessages" | "importedMessages" | "failedMessages" | "mediaFiles" | "status" | "errorMessage" | "uploadedById" | "importedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppImport"]>
  export type WhatsAppImportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppImportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppImportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | WhatsAppInstanceDefaultArgs<ExtArgs>
    contact?: boolean | WhatsAppContactDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhatsAppImportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppImport"
    objects: {
      instance: Prisma.$WhatsAppInstancePayload<ExtArgs>
      contact: Prisma.$WhatsAppContactPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceId: string
      contactId: string
      fileName: string
      fileSize: number
      totalMessages: number
      importedMessages: number
      failedMessages: number
      mediaFiles: string[]
      status: $Enums.WhatsAppImportStatus
      errorMessage: string | null
      uploadedById: string
      importedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppImport"]>
    composites: {}
  }

  type WhatsAppImportGetPayload<S extends boolean | null | undefined | WhatsAppImportDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppImportPayload, S>

  type WhatsAppImportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppImportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppImportCountAggregateInputType | true
    }

  export interface WhatsAppImportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppImport'], meta: { name: 'WhatsAppImport' } }
    /**
     * Find zero or one WhatsAppImport that matches the filter.
     * @param {WhatsAppImportFindUniqueArgs} args - Arguments to find a WhatsAppImport
     * @example
     * // Get one WhatsAppImport
     * const whatsAppImport = await prisma.whatsAppImport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppImportFindUniqueArgs>(args: SelectSubset<T, WhatsAppImportFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppImport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppImportFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppImport
     * @example
     * // Get one WhatsAppImport
     * const whatsAppImport = await prisma.whatsAppImport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppImportFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppImportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppImport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppImportFindFirstArgs} args - Arguments to find a WhatsAppImport
     * @example
     * // Get one WhatsAppImport
     * const whatsAppImport = await prisma.whatsAppImport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppImportFindFirstArgs>(args?: SelectSubset<T, WhatsAppImportFindFirstArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppImport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppImportFindFirstOrThrowArgs} args - Arguments to find a WhatsAppImport
     * @example
     * // Get one WhatsAppImport
     * const whatsAppImport = await prisma.whatsAppImport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppImportFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppImportFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppImports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppImportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppImports
     * const whatsAppImports = await prisma.whatsAppImport.findMany()
     * 
     * // Get first 10 WhatsAppImports
     * const whatsAppImports = await prisma.whatsAppImport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppImportWithIdOnly = await prisma.whatsAppImport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppImportFindManyArgs>(args?: SelectSubset<T, WhatsAppImportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppImport.
     * @param {WhatsAppImportCreateArgs} args - Arguments to create a WhatsAppImport.
     * @example
     * // Create one WhatsAppImport
     * const WhatsAppImport = await prisma.whatsAppImport.create({
     *   data: {
     *     // ... data to create a WhatsAppImport
     *   }
     * })
     * 
     */
    create<T extends WhatsAppImportCreateArgs>(args: SelectSubset<T, WhatsAppImportCreateArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppImports.
     * @param {WhatsAppImportCreateManyArgs} args - Arguments to create many WhatsAppImports.
     * @example
     * // Create many WhatsAppImports
     * const whatsAppImport = await prisma.whatsAppImport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppImportCreateManyArgs>(args?: SelectSubset<T, WhatsAppImportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppImports and returns the data saved in the database.
     * @param {WhatsAppImportCreateManyAndReturnArgs} args - Arguments to create many WhatsAppImports.
     * @example
     * // Create many WhatsAppImports
     * const whatsAppImport = await prisma.whatsAppImport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppImports and only return the `id`
     * const whatsAppImportWithIdOnly = await prisma.whatsAppImport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppImportCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppImportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppImport.
     * @param {WhatsAppImportDeleteArgs} args - Arguments to delete one WhatsAppImport.
     * @example
     * // Delete one WhatsAppImport
     * const WhatsAppImport = await prisma.whatsAppImport.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppImport
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppImportDeleteArgs>(args: SelectSubset<T, WhatsAppImportDeleteArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppImport.
     * @param {WhatsAppImportUpdateArgs} args - Arguments to update one WhatsAppImport.
     * @example
     * // Update one WhatsAppImport
     * const whatsAppImport = await prisma.whatsAppImport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppImportUpdateArgs>(args: SelectSubset<T, WhatsAppImportUpdateArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppImports.
     * @param {WhatsAppImportDeleteManyArgs} args - Arguments to filter WhatsAppImports to delete.
     * @example
     * // Delete a few WhatsAppImports
     * const { count } = await prisma.whatsAppImport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppImportDeleteManyArgs>(args?: SelectSubset<T, WhatsAppImportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppImportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppImports
     * const whatsAppImport = await prisma.whatsAppImport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppImportUpdateManyArgs>(args: SelectSubset<T, WhatsAppImportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppImports and returns the data updated in the database.
     * @param {WhatsAppImportUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppImports.
     * @example
     * // Update many WhatsAppImports
     * const whatsAppImport = await prisma.whatsAppImport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppImports and only return the `id`
     * const whatsAppImportWithIdOnly = await prisma.whatsAppImport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppImportUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppImportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppImport.
     * @param {WhatsAppImportUpsertArgs} args - Arguments to update or create a WhatsAppImport.
     * @example
     * // Update or create a WhatsAppImport
     * const whatsAppImport = await prisma.whatsAppImport.upsert({
     *   create: {
     *     // ... data to create a WhatsAppImport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppImport we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppImportUpsertArgs>(args: SelectSubset<T, WhatsAppImportUpsertArgs<ExtArgs>>): Prisma__WhatsAppImportClient<$Result.GetResult<Prisma.$WhatsAppImportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppImports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppImportCountArgs} args - Arguments to filter WhatsAppImports to count.
     * @example
     * // Count the number of WhatsAppImports
     * const count = await prisma.whatsAppImport.count({
     *   where: {
     *     // ... the filter for the WhatsAppImports we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppImportCountArgs>(
      args?: Subset<T, WhatsAppImportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppImportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppImportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppImportAggregateArgs>(args: Subset<T, WhatsAppImportAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppImportAggregateType<T>>

    /**
     * Group by WhatsAppImport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppImportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppImportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppImportGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppImportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppImportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppImportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppImport model
   */
  readonly fields: WhatsAppImportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppImport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppImportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends WhatsAppInstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppInstanceDefaultArgs<ExtArgs>>): Prisma__WhatsAppInstanceClient<$Result.GetResult<Prisma.$WhatsAppInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends WhatsAppContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppContactDefaultArgs<ExtArgs>>): Prisma__WhatsAppContactClient<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppImport model
   */
  interface WhatsAppImportFieldRefs {
    readonly id: FieldRef<"WhatsAppImport", 'String'>
    readonly instanceId: FieldRef<"WhatsAppImport", 'String'>
    readonly contactId: FieldRef<"WhatsAppImport", 'String'>
    readonly fileName: FieldRef<"WhatsAppImport", 'String'>
    readonly fileSize: FieldRef<"WhatsAppImport", 'Int'>
    readonly totalMessages: FieldRef<"WhatsAppImport", 'Int'>
    readonly importedMessages: FieldRef<"WhatsAppImport", 'Int'>
    readonly failedMessages: FieldRef<"WhatsAppImport", 'Int'>
    readonly mediaFiles: FieldRef<"WhatsAppImport", 'String[]'>
    readonly status: FieldRef<"WhatsAppImport", 'WhatsAppImportStatus'>
    readonly errorMessage: FieldRef<"WhatsAppImport", 'String'>
    readonly uploadedById: FieldRef<"WhatsAppImport", 'String'>
    readonly importedAt: FieldRef<"WhatsAppImport", 'DateTime'>
    readonly createdAt: FieldRef<"WhatsAppImport", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppImport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppImport findUnique
   */
  export type WhatsAppImportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppImport to fetch.
     */
    where: WhatsAppImportWhereUniqueInput
  }

  /**
   * WhatsAppImport findUniqueOrThrow
   */
  export type WhatsAppImportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppImport to fetch.
     */
    where: WhatsAppImportWhereUniqueInput
  }

  /**
   * WhatsAppImport findFirst
   */
  export type WhatsAppImportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppImport to fetch.
     */
    where?: WhatsAppImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppImports to fetch.
     */
    orderBy?: WhatsAppImportOrderByWithRelationInput | WhatsAppImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppImports.
     */
    cursor?: WhatsAppImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppImports.
     */
    distinct?: WhatsAppImportScalarFieldEnum | WhatsAppImportScalarFieldEnum[]
  }

  /**
   * WhatsAppImport findFirstOrThrow
   */
  export type WhatsAppImportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppImport to fetch.
     */
    where?: WhatsAppImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppImports to fetch.
     */
    orderBy?: WhatsAppImportOrderByWithRelationInput | WhatsAppImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppImports.
     */
    cursor?: WhatsAppImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppImports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppImports.
     */
    distinct?: WhatsAppImportScalarFieldEnum | WhatsAppImportScalarFieldEnum[]
  }

  /**
   * WhatsAppImport findMany
   */
  export type WhatsAppImportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppImports to fetch.
     */
    where?: WhatsAppImportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppImports to fetch.
     */
    orderBy?: WhatsAppImportOrderByWithRelationInput | WhatsAppImportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppImports.
     */
    cursor?: WhatsAppImportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppImports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppImports.
     */
    skip?: number
    distinct?: WhatsAppImportScalarFieldEnum | WhatsAppImportScalarFieldEnum[]
  }

  /**
   * WhatsAppImport create
   */
  export type WhatsAppImportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppImport.
     */
    data: XOR<WhatsAppImportCreateInput, WhatsAppImportUncheckedCreateInput>
  }

  /**
   * WhatsAppImport createMany
   */
  export type WhatsAppImportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppImports.
     */
    data: WhatsAppImportCreateManyInput | WhatsAppImportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppImport createManyAndReturn
   */
  export type WhatsAppImportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppImports.
     */
    data: WhatsAppImportCreateManyInput | WhatsAppImportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppImport update
   */
  export type WhatsAppImportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppImport.
     */
    data: XOR<WhatsAppImportUpdateInput, WhatsAppImportUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppImport to update.
     */
    where: WhatsAppImportWhereUniqueInput
  }

  /**
   * WhatsAppImport updateMany
   */
  export type WhatsAppImportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppImports.
     */
    data: XOR<WhatsAppImportUpdateManyMutationInput, WhatsAppImportUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppImports to update
     */
    where?: WhatsAppImportWhereInput
    /**
     * Limit how many WhatsAppImports to update.
     */
    limit?: number
  }

  /**
   * WhatsAppImport updateManyAndReturn
   */
  export type WhatsAppImportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppImports.
     */
    data: XOR<WhatsAppImportUpdateManyMutationInput, WhatsAppImportUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppImports to update
     */
    where?: WhatsAppImportWhereInput
    /**
     * Limit how many WhatsAppImports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppImport upsert
   */
  export type WhatsAppImportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppImport to update in case it exists.
     */
    where: WhatsAppImportWhereUniqueInput
    /**
     * In case the WhatsAppImport found by the `where` argument doesn't exist, create a new WhatsAppImport with this data.
     */
    create: XOR<WhatsAppImportCreateInput, WhatsAppImportUncheckedCreateInput>
    /**
     * In case the WhatsAppImport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppImportUpdateInput, WhatsAppImportUncheckedUpdateInput>
  }

  /**
   * WhatsAppImport delete
   */
  export type WhatsAppImportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppImport to delete.
     */
    where: WhatsAppImportWhereUniqueInput
  }

  /**
   * WhatsAppImport deleteMany
   */
  export type WhatsAppImportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppImports to delete
     */
    where?: WhatsAppImportWhereInput
    /**
     * Limit how many WhatsAppImports to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppImport without action
   */
  export type WhatsAppImportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppImport
     */
    select?: WhatsAppImportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppImport
     */
    omit?: WhatsAppImportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppImportInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    document: string | null
    notes: string | null
    isLead: boolean | null
    dateOfBirth: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    document: string | null
    notes: string | null
    isLead: boolean | null
    dateOfBirth: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    document: number
    notes: number
    isLead: number
    dateOfBirth: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    document?: true
    notes?: true
    isLead?: true
    dateOfBirth?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    document?: true
    notes?: true
    isLead?: true
    dateOfBirth?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    document?: true
    notes?: true
    isLead?: true
    dateOfBirth?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string | null
    phone: string
    email: string | null
    document: string | null
    notes: string | null
    isLead: boolean
    dateOfBirth: Date | null
    createdAt: Date
    updatedAt: Date
    officeId: string
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    document?: boolean
    notes?: boolean
    isLead?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    conversations?: boolean | Client$conversationsArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    clientTags?: boolean | Client$clientTagsArgs<ExtArgs>
    whatsappContacts?: boolean | Client$whatsappContactsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    document?: boolean
    notes?: boolean
    isLead?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    document?: boolean
    notes?: boolean
    isLead?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    document?: boolean
    notes?: boolean
    isLead?: boolean
    dateOfBirth?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "document" | "notes" | "isLead" | "dateOfBirth" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    conversations?: boolean | Client$conversationsArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    clientTags?: boolean | Client$clientTagsArgs<ExtArgs>
    whatsappContacts?: boolean | Client$whatsappContactsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      clientTags: Prisma.$ClientTagPayload<ExtArgs>[]
      whatsappContacts: Prisma.$WhatsAppContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      phone: string
      email: string | null
      document: string | null
      notes: string | null
      isLead: boolean
      dateOfBirth: Date | null
      createdAt: Date
      updatedAt: Date
      officeId: string
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversations<T extends Client$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Client$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Client$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientTags<T extends Client$clientTagsArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappContacts<T extends Client$whatsappContactsArgs<ExtArgs> = {}>(args?: Subset<T, Client$whatsappContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly document: FieldRef<"Client", 'String'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly isLead: FieldRef<"Client", 'Boolean'>
    readonly dateOfBirth: FieldRef<"Client", 'DateTime'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly officeId: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.conversations
   */
  export type Client$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Client.documents
   */
  export type Client$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Client.clientTags
   */
  export type Client$clientTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    where?: ClientTagWhereInput
    orderBy?: ClientTagOrderByWithRelationInput | ClientTagOrderByWithRelationInput[]
    cursor?: ClientTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientTagScalarFieldEnum | ClientTagScalarFieldEnum[]
  }

  /**
   * Client.whatsappContacts
   */
  export type Client$whatsappContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppContact
     */
    select?: WhatsAppContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppContact
     */
    omit?: WhatsAppContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppContactInclude<ExtArgs> | null
    where?: WhatsAppContactWhereInput
    orderBy?: WhatsAppContactOrderByWithRelationInput | WhatsAppContactOrderByWithRelationInput[]
    cursor?: WhatsAppContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppContactScalarFieldEnum | WhatsAppContactScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    title: string | null
    status: $Enums.ConversationStatus | null
    lastMessageAt: Date | null
    currentAgentType: $Enums.AgentType | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    officeId: string | null
    createdBy: string | null
    assignedTo: string | null
    whatsappConfigId: string | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    status: $Enums.ConversationStatus | null
    lastMessageAt: Date | null
    currentAgentType: $Enums.AgentType | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    officeId: string | null
    createdBy: string | null
    assignedTo: string | null
    whatsappConfigId: string | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    title: number
    status: number
    lastMessageAt: number
    metadata: number
    currentAgentType: number
    createdAt: number
    updatedAt: number
    clientId: number
    officeId: number
    createdBy: number
    assignedTo: number
    whatsappConfigId: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    title?: true
    status?: true
    lastMessageAt?: true
    currentAgentType?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    officeId?: true
    createdBy?: true
    assignedTo?: true
    whatsappConfigId?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    title?: true
    status?: true
    lastMessageAt?: true
    currentAgentType?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    officeId?: true
    createdBy?: true
    assignedTo?: true
    whatsappConfigId?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    title?: true
    status?: true
    lastMessageAt?: true
    metadata?: true
    currentAgentType?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    officeId?: true
    createdBy?: true
    assignedTo?: true
    whatsappConfigId?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    title: string | null
    status: $Enums.ConversationStatus
    lastMessageAt: Date | null
    metadata: JsonValue | null
    currentAgentType: $Enums.AgentType | null
    createdAt: Date
    updatedAt: Date
    clientId: string
    officeId: string
    createdBy: string
    assignedTo: string | null
    whatsappConfigId: string | null
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    lastMessageAt?: boolean
    metadata?: boolean
    currentAgentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
    createdBy?: boolean
    assignedTo?: boolean
    whatsappConfigId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Conversation$assigneeArgs<ExtArgs>
    whatsappConfig?: boolean | Conversation$whatsappConfigArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    conversationTags?: boolean | Conversation$conversationTagsArgs<ExtArgs>
    conversationStatus?: boolean | Conversation$conversationStatusArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    lastMessageAt?: boolean
    metadata?: boolean
    currentAgentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
    createdBy?: boolean
    assignedTo?: boolean
    whatsappConfigId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Conversation$assigneeArgs<ExtArgs>
    whatsappConfig?: boolean | Conversation$whatsappConfigArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    status?: boolean
    lastMessageAt?: boolean
    metadata?: boolean
    currentAgentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
    createdBy?: boolean
    assignedTo?: boolean
    whatsappConfigId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Conversation$assigneeArgs<ExtArgs>
    whatsappConfig?: boolean | Conversation$whatsappConfigArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    title?: boolean
    status?: boolean
    lastMessageAt?: boolean
    metadata?: boolean
    currentAgentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
    createdBy?: boolean
    assignedTo?: boolean
    whatsappConfigId?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "status" | "lastMessageAt" | "metadata" | "currentAgentType" | "createdAt" | "updatedAt" | "clientId" | "officeId" | "createdBy" | "assignedTo" | "whatsappConfigId", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Conversation$assigneeArgs<ExtArgs>
    whatsappConfig?: boolean | Conversation$whatsappConfigArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    conversationTags?: boolean | Conversation$conversationTagsArgs<ExtArgs>
    conversationStatus?: boolean | Conversation$conversationStatusArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Conversation$assigneeArgs<ExtArgs>
    whatsappConfig?: boolean | Conversation$whatsappConfigArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    assignee?: boolean | Conversation$assigneeArgs<ExtArgs>
    whatsappConfig?: boolean | Conversation$whatsappConfigArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      office: Prisma.$OfficePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs> | null
      whatsappConfig: Prisma.$WhatsappConfigPayload<ExtArgs> | null
      messages: Prisma.$MessagePayload<ExtArgs>[]
      conversationTags: Prisma.$ConversationTagPayload<ExtArgs>[]
      conversationStatus: Prisma.$ConversationCustomStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      status: $Enums.ConversationStatus
      lastMessageAt: Date | null
      metadata: Prisma.JsonValue | null
      currentAgentType: $Enums.AgentType | null
      createdAt: Date
      updatedAt: Date
      clientId: string
      officeId: string
      createdBy: string
      assignedTo: string | null
      whatsappConfigId: string | null
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignee<T extends Conversation$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    whatsappConfig<T extends Conversation$whatsappConfigArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$whatsappConfigArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationTags<T extends Conversation$conversationTagsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$conversationTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationStatus<T extends Conversation$conversationStatusArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$conversationStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly status: FieldRef<"Conversation", 'ConversationStatus'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly metadata: FieldRef<"Conversation", 'Json'>
    readonly currentAgentType: FieldRef<"Conversation", 'AgentType'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly clientId: FieldRef<"Conversation", 'String'>
    readonly officeId: FieldRef<"Conversation", 'String'>
    readonly createdBy: FieldRef<"Conversation", 'String'>
    readonly assignedTo: FieldRef<"Conversation", 'String'>
    readonly whatsappConfigId: FieldRef<"Conversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.assignee
   */
  export type Conversation$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Conversation.whatsappConfig
   */
  export type Conversation$whatsappConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    where?: WhatsappConfigWhereInput
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.conversationTags
   */
  export type Conversation$conversationTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    where?: ConversationTagWhereInput
    orderBy?: ConversationTagOrderByWithRelationInput | ConversationTagOrderByWithRelationInput[]
    cursor?: ConversationTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationTagScalarFieldEnum | ConversationTagScalarFieldEnum[]
  }

  /**
   * Conversation.conversationStatus
   */
  export type Conversation$conversationStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    where?: ConversationCustomStatusWhereInput
    orderBy?: ConversationCustomStatusOrderByWithRelationInput | ConversationCustomStatusOrderByWithRelationInput[]
    cursor?: ConversationCustomStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationCustomStatusScalarFieldEnum | ConversationCustomStatusScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    type: $Enums.MessageType | null
    isFromClient: boolean | null
    isFromAI: boolean | null
    externalId: string | null
    mediaUrl: string | null
    transcription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    conversationId: string | null
    userId: string | null
    whatsappConfigId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    type: $Enums.MessageType | null
    isFromClient: boolean | null
    isFromAI: boolean | null
    externalId: string | null
    mediaUrl: string | null
    transcription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    conversationId: string | null
    userId: string | null
    whatsappConfigId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    type: number
    isFromClient: number
    isFromAI: number
    metadata: number
    externalId: number
    mediaUrl: number
    transcription: number
    createdAt: number
    updatedAt: number
    conversationId: number
    userId: number
    whatsappConfigId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    type?: true
    isFromClient?: true
    isFromAI?: true
    externalId?: true
    mediaUrl?: true
    transcription?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    userId?: true
    whatsappConfigId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    type?: true
    isFromClient?: true
    isFromAI?: true
    externalId?: true
    mediaUrl?: true
    transcription?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    userId?: true
    whatsappConfigId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    type?: true
    isFromClient?: true
    isFromAI?: true
    metadata?: true
    externalId?: true
    mediaUrl?: true
    transcription?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    userId?: true
    whatsappConfigId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string | null
    type: $Enums.MessageType
    isFromClient: boolean
    isFromAI: boolean
    metadata: JsonValue | null
    externalId: string | null
    mediaUrl: string | null
    transcription: string | null
    createdAt: Date
    updatedAt: Date
    conversationId: string
    userId: string | null
    whatsappConfigId: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: boolean
    externalId?: boolean
    mediaUrl?: boolean
    transcription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationId?: boolean
    userId?: boolean
    whatsappConfigId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    whatsappConfig?: boolean | Message$whatsappConfigArgs<ExtArgs>
    audioTranscription?: boolean | Message$audioTranscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: boolean
    externalId?: boolean
    mediaUrl?: boolean
    transcription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationId?: boolean
    userId?: boolean
    whatsappConfigId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    whatsappConfig?: boolean | Message$whatsappConfigArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: boolean
    externalId?: boolean
    mediaUrl?: boolean
    transcription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationId?: boolean
    userId?: boolean
    whatsappConfigId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    whatsappConfig?: boolean | Message$whatsappConfigArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    type?: boolean
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: boolean
    externalId?: boolean
    mediaUrl?: boolean
    transcription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversationId?: boolean
    userId?: boolean
    whatsappConfigId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "type" | "isFromClient" | "isFromAI" | "metadata" | "externalId" | "mediaUrl" | "transcription" | "createdAt" | "updatedAt" | "conversationId" | "userId" | "whatsappConfigId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    whatsappConfig?: boolean | Message$whatsappConfigArgs<ExtArgs>
    audioTranscription?: boolean | Message$audioTranscriptionArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    whatsappConfig?: boolean | Message$whatsappConfigArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
    whatsappConfig?: boolean | Message$whatsappConfigArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      whatsappConfig: Prisma.$WhatsappConfigPayload<ExtArgs> | null
      audioTranscription: Prisma.$AudioTranscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string | null
      type: $Enums.MessageType
      isFromClient: boolean
      isFromAI: boolean
      metadata: Prisma.JsonValue | null
      externalId: string | null
      mediaUrl: string | null
      transcription: string | null
      createdAt: Date
      updatedAt: Date
      conversationId: string
      userId: string | null
      whatsappConfigId: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Message$userArgs<ExtArgs> = {}>(args?: Subset<T, Message$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    whatsappConfig<T extends Message$whatsappConfigArgs<ExtArgs> = {}>(args?: Subset<T, Message$whatsappConfigArgs<ExtArgs>>): Prisma__WhatsappConfigClient<$Result.GetResult<Prisma.$WhatsappConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audioTranscription<T extends Message$audioTranscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Message$audioTranscriptionArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly isFromClient: FieldRef<"Message", 'Boolean'>
    readonly isFromAI: FieldRef<"Message", 'Boolean'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly externalId: FieldRef<"Message", 'String'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly transcription: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly userId: FieldRef<"Message", 'String'>
    readonly whatsappConfigId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.user
   */
  export type Message$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message.whatsappConfig
   */
  export type Message$whatsappConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappConfig
     */
    select?: WhatsappConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappConfig
     */
    omit?: WhatsappConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappConfigInclude<ExtArgs> | null
    where?: WhatsappConfigWhereInput
  }

  /**
   * Message.audioTranscription
   */
  export type Message$audioTranscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    where?: AudioTranscriptionWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model AudioTranscription
   */

  export type AggregateAudioTranscription = {
    _count: AudioTranscriptionCountAggregateOutputType | null
    _avg: AudioTranscriptionAvgAggregateOutputType | null
    _sum: AudioTranscriptionSumAggregateOutputType | null
    _min: AudioTranscriptionMinAggregateOutputType | null
    _max: AudioTranscriptionMaxAggregateOutputType | null
  }

  export type AudioTranscriptionAvgAggregateOutputType = {
    confidence: number | null
    duration: number | null
  }

  export type AudioTranscriptionSumAggregateOutputType = {
    confidence: number | null
    duration: number | null
  }

  export type AudioTranscriptionMinAggregateOutputType = {
    id: string | null
    originalText: string | null
    provider: $Enums.TranscriptionProvider | null
    confidence: number | null
    duration: number | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
    messageId: string | null
  }

  export type AudioTranscriptionMaxAggregateOutputType = {
    id: string | null
    originalText: string | null
    provider: $Enums.TranscriptionProvider | null
    confidence: number | null
    duration: number | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
    messageId: string | null
  }

  export type AudioTranscriptionCountAggregateOutputType = {
    id: number
    originalText: number
    provider: number
    confidence: number
    duration: number
    language: number
    metadata: number
    createdAt: number
    updatedAt: number
    messageId: number
    _all: number
  }


  export type AudioTranscriptionAvgAggregateInputType = {
    confidence?: true
    duration?: true
  }

  export type AudioTranscriptionSumAggregateInputType = {
    confidence?: true
    duration?: true
  }

  export type AudioTranscriptionMinAggregateInputType = {
    id?: true
    originalText?: true
    provider?: true
    confidence?: true
    duration?: true
    language?: true
    createdAt?: true
    updatedAt?: true
    messageId?: true
  }

  export type AudioTranscriptionMaxAggregateInputType = {
    id?: true
    originalText?: true
    provider?: true
    confidence?: true
    duration?: true
    language?: true
    createdAt?: true
    updatedAt?: true
    messageId?: true
  }

  export type AudioTranscriptionCountAggregateInputType = {
    id?: true
    originalText?: true
    provider?: true
    confidence?: true
    duration?: true
    language?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    messageId?: true
    _all?: true
  }

  export type AudioTranscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTranscription to aggregate.
     */
    where?: AudioTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTranscriptions to fetch.
     */
    orderBy?: AudioTranscriptionOrderByWithRelationInput | AudioTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTranscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioTranscriptions
    **/
    _count?: true | AudioTranscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioTranscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioTranscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioTranscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioTranscriptionMaxAggregateInputType
  }

  export type GetAudioTranscriptionAggregateType<T extends AudioTranscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioTranscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioTranscription[P]>
      : GetScalarType<T[P], AggregateAudioTranscription[P]>
  }




  export type AudioTranscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioTranscriptionWhereInput
    orderBy?: AudioTranscriptionOrderByWithAggregationInput | AudioTranscriptionOrderByWithAggregationInput[]
    by: AudioTranscriptionScalarFieldEnum[] | AudioTranscriptionScalarFieldEnum
    having?: AudioTranscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioTranscriptionCountAggregateInputType | true
    _avg?: AudioTranscriptionAvgAggregateInputType
    _sum?: AudioTranscriptionSumAggregateInputType
    _min?: AudioTranscriptionMinAggregateInputType
    _max?: AudioTranscriptionMaxAggregateInputType
  }

  export type AudioTranscriptionGroupByOutputType = {
    id: string
    originalText: string | null
    provider: $Enums.TranscriptionProvider
    confidence: number | null
    duration: number | null
    language: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    messageId: string
    _count: AudioTranscriptionCountAggregateOutputType | null
    _avg: AudioTranscriptionAvgAggregateOutputType | null
    _sum: AudioTranscriptionSumAggregateOutputType | null
    _min: AudioTranscriptionMinAggregateOutputType | null
    _max: AudioTranscriptionMaxAggregateOutputType | null
  }

  type GetAudioTranscriptionGroupByPayload<T extends AudioTranscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioTranscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioTranscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioTranscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], AudioTranscriptionGroupByOutputType[P]>
        }
      >
    >


  export type AudioTranscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalText?: boolean
    provider?: boolean
    confidence?: boolean
    duration?: boolean
    language?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTranscription"]>

  export type AudioTranscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalText?: boolean
    provider?: boolean
    confidence?: boolean
    duration?: boolean
    language?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTranscription"]>

  export type AudioTranscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalText?: boolean
    provider?: boolean
    confidence?: boolean
    duration?: boolean
    language?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messageId?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTranscription"]>

  export type AudioTranscriptionSelectScalar = {
    id?: boolean
    originalText?: boolean
    provider?: boolean
    confidence?: boolean
    duration?: boolean
    language?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messageId?: boolean
  }

  export type AudioTranscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "originalText" | "provider" | "confidence" | "duration" | "language" | "metadata" | "createdAt" | "updatedAt" | "messageId", ExtArgs["result"]["audioTranscription"]>
  export type AudioTranscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type AudioTranscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type AudioTranscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $AudioTranscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioTranscription"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      originalText: string | null
      provider: $Enums.TranscriptionProvider
      confidence: number | null
      duration: number | null
      language: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      messageId: string
    }, ExtArgs["result"]["audioTranscription"]>
    composites: {}
  }

  type AudioTranscriptionGetPayload<S extends boolean | null | undefined | AudioTranscriptionDefaultArgs> = $Result.GetResult<Prisma.$AudioTranscriptionPayload, S>

  type AudioTranscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioTranscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudioTranscriptionCountAggregateInputType | true
    }

  export interface AudioTranscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioTranscription'], meta: { name: 'AudioTranscription' } }
    /**
     * Find zero or one AudioTranscription that matches the filter.
     * @param {AudioTranscriptionFindUniqueArgs} args - Arguments to find a AudioTranscription
     * @example
     * // Get one AudioTranscription
     * const audioTranscription = await prisma.audioTranscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioTranscriptionFindUniqueArgs>(args: SelectSubset<T, AudioTranscriptionFindUniqueArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudioTranscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioTranscriptionFindUniqueOrThrowArgs} args - Arguments to find a AudioTranscription
     * @example
     * // Get one AudioTranscription
     * const audioTranscription = await prisma.audioTranscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioTranscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioTranscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTranscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTranscriptionFindFirstArgs} args - Arguments to find a AudioTranscription
     * @example
     * // Get one AudioTranscription
     * const audioTranscription = await prisma.audioTranscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioTranscriptionFindFirstArgs>(args?: SelectSubset<T, AudioTranscriptionFindFirstArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTranscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTranscriptionFindFirstOrThrowArgs} args - Arguments to find a AudioTranscription
     * @example
     * // Get one AudioTranscription
     * const audioTranscription = await prisma.audioTranscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioTranscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioTranscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudioTranscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTranscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioTranscriptions
     * const audioTranscriptions = await prisma.audioTranscription.findMany()
     * 
     * // Get first 10 AudioTranscriptions
     * const audioTranscriptions = await prisma.audioTranscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioTranscriptionWithIdOnly = await prisma.audioTranscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioTranscriptionFindManyArgs>(args?: SelectSubset<T, AudioTranscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudioTranscription.
     * @param {AudioTranscriptionCreateArgs} args - Arguments to create a AudioTranscription.
     * @example
     * // Create one AudioTranscription
     * const AudioTranscription = await prisma.audioTranscription.create({
     *   data: {
     *     // ... data to create a AudioTranscription
     *   }
     * })
     * 
     */
    create<T extends AudioTranscriptionCreateArgs>(args: SelectSubset<T, AudioTranscriptionCreateArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudioTranscriptions.
     * @param {AudioTranscriptionCreateManyArgs} args - Arguments to create many AudioTranscriptions.
     * @example
     * // Create many AudioTranscriptions
     * const audioTranscription = await prisma.audioTranscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioTranscriptionCreateManyArgs>(args?: SelectSubset<T, AudioTranscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioTranscriptions and returns the data saved in the database.
     * @param {AudioTranscriptionCreateManyAndReturnArgs} args - Arguments to create many AudioTranscriptions.
     * @example
     * // Create many AudioTranscriptions
     * const audioTranscription = await prisma.audioTranscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioTranscriptions and only return the `id`
     * const audioTranscriptionWithIdOnly = await prisma.audioTranscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioTranscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioTranscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudioTranscription.
     * @param {AudioTranscriptionDeleteArgs} args - Arguments to delete one AudioTranscription.
     * @example
     * // Delete one AudioTranscription
     * const AudioTranscription = await prisma.audioTranscription.delete({
     *   where: {
     *     // ... filter to delete one AudioTranscription
     *   }
     * })
     * 
     */
    delete<T extends AudioTranscriptionDeleteArgs>(args: SelectSubset<T, AudioTranscriptionDeleteArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudioTranscription.
     * @param {AudioTranscriptionUpdateArgs} args - Arguments to update one AudioTranscription.
     * @example
     * // Update one AudioTranscription
     * const audioTranscription = await prisma.audioTranscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioTranscriptionUpdateArgs>(args: SelectSubset<T, AudioTranscriptionUpdateArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudioTranscriptions.
     * @param {AudioTranscriptionDeleteManyArgs} args - Arguments to filter AudioTranscriptions to delete.
     * @example
     * // Delete a few AudioTranscriptions
     * const { count } = await prisma.audioTranscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioTranscriptionDeleteManyArgs>(args?: SelectSubset<T, AudioTranscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTranscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTranscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioTranscriptions
     * const audioTranscription = await prisma.audioTranscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioTranscriptionUpdateManyArgs>(args: SelectSubset<T, AudioTranscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTranscriptions and returns the data updated in the database.
     * @param {AudioTranscriptionUpdateManyAndReturnArgs} args - Arguments to update many AudioTranscriptions.
     * @example
     * // Update many AudioTranscriptions
     * const audioTranscription = await prisma.audioTranscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudioTranscriptions and only return the `id`
     * const audioTranscriptionWithIdOnly = await prisma.audioTranscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudioTranscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, AudioTranscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudioTranscription.
     * @param {AudioTranscriptionUpsertArgs} args - Arguments to update or create a AudioTranscription.
     * @example
     * // Update or create a AudioTranscription
     * const audioTranscription = await prisma.audioTranscription.upsert({
     *   create: {
     *     // ... data to create a AudioTranscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioTranscription we want to update
     *   }
     * })
     */
    upsert<T extends AudioTranscriptionUpsertArgs>(args: SelectSubset<T, AudioTranscriptionUpsertArgs<ExtArgs>>): Prisma__AudioTranscriptionClient<$Result.GetResult<Prisma.$AudioTranscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudioTranscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTranscriptionCountArgs} args - Arguments to filter AudioTranscriptions to count.
     * @example
     * // Count the number of AudioTranscriptions
     * const count = await prisma.audioTranscription.count({
     *   where: {
     *     // ... the filter for the AudioTranscriptions we want to count
     *   }
     * })
    **/
    count<T extends AudioTranscriptionCountArgs>(
      args?: Subset<T, AudioTranscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioTranscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioTranscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTranscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioTranscriptionAggregateArgs>(args: Subset<T, AudioTranscriptionAggregateArgs>): Prisma.PrismaPromise<GetAudioTranscriptionAggregateType<T>>

    /**
     * Group by AudioTranscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTranscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioTranscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioTranscriptionGroupByArgs['orderBy'] }
        : { orderBy?: AudioTranscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioTranscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioTranscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioTranscription model
   */
  readonly fields: AudioTranscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioTranscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioTranscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioTranscription model
   */
  interface AudioTranscriptionFieldRefs {
    readonly id: FieldRef<"AudioTranscription", 'String'>
    readonly originalText: FieldRef<"AudioTranscription", 'String'>
    readonly provider: FieldRef<"AudioTranscription", 'TranscriptionProvider'>
    readonly confidence: FieldRef<"AudioTranscription", 'Float'>
    readonly duration: FieldRef<"AudioTranscription", 'Float'>
    readonly language: FieldRef<"AudioTranscription", 'String'>
    readonly metadata: FieldRef<"AudioTranscription", 'Json'>
    readonly createdAt: FieldRef<"AudioTranscription", 'DateTime'>
    readonly updatedAt: FieldRef<"AudioTranscription", 'DateTime'>
    readonly messageId: FieldRef<"AudioTranscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AudioTranscription findUnique
   */
  export type AudioTranscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AudioTranscription to fetch.
     */
    where: AudioTranscriptionWhereUniqueInput
  }

  /**
   * AudioTranscription findUniqueOrThrow
   */
  export type AudioTranscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AudioTranscription to fetch.
     */
    where: AudioTranscriptionWhereUniqueInput
  }

  /**
   * AudioTranscription findFirst
   */
  export type AudioTranscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AudioTranscription to fetch.
     */
    where?: AudioTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTranscriptions to fetch.
     */
    orderBy?: AudioTranscriptionOrderByWithRelationInput | AudioTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTranscriptions.
     */
    cursor?: AudioTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTranscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTranscriptions.
     */
    distinct?: AudioTranscriptionScalarFieldEnum | AudioTranscriptionScalarFieldEnum[]
  }

  /**
   * AudioTranscription findFirstOrThrow
   */
  export type AudioTranscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AudioTranscription to fetch.
     */
    where?: AudioTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTranscriptions to fetch.
     */
    orderBy?: AudioTranscriptionOrderByWithRelationInput | AudioTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTranscriptions.
     */
    cursor?: AudioTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTranscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTranscriptions.
     */
    distinct?: AudioTranscriptionScalarFieldEnum | AudioTranscriptionScalarFieldEnum[]
  }

  /**
   * AudioTranscription findMany
   */
  export type AudioTranscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AudioTranscriptions to fetch.
     */
    where?: AudioTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTranscriptions to fetch.
     */
    orderBy?: AudioTranscriptionOrderByWithRelationInput | AudioTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioTranscriptions.
     */
    cursor?: AudioTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTranscriptions.
     */
    skip?: number
    distinct?: AudioTranscriptionScalarFieldEnum | AudioTranscriptionScalarFieldEnum[]
  }

  /**
   * AudioTranscription create
   */
  export type AudioTranscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioTranscription.
     */
    data: XOR<AudioTranscriptionCreateInput, AudioTranscriptionUncheckedCreateInput>
  }

  /**
   * AudioTranscription createMany
   */
  export type AudioTranscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioTranscriptions.
     */
    data: AudioTranscriptionCreateManyInput | AudioTranscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AudioTranscription createManyAndReturn
   */
  export type AudioTranscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many AudioTranscriptions.
     */
    data: AudioTranscriptionCreateManyInput | AudioTranscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTranscription update
   */
  export type AudioTranscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioTranscription.
     */
    data: XOR<AudioTranscriptionUpdateInput, AudioTranscriptionUncheckedUpdateInput>
    /**
     * Choose, which AudioTranscription to update.
     */
    where: AudioTranscriptionWhereUniqueInput
  }

  /**
   * AudioTranscription updateMany
   */
  export type AudioTranscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioTranscriptions.
     */
    data: XOR<AudioTranscriptionUpdateManyMutationInput, AudioTranscriptionUncheckedUpdateManyInput>
    /**
     * Filter which AudioTranscriptions to update
     */
    where?: AudioTranscriptionWhereInput
    /**
     * Limit how many AudioTranscriptions to update.
     */
    limit?: number
  }

  /**
   * AudioTranscription updateManyAndReturn
   */
  export type AudioTranscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * The data used to update AudioTranscriptions.
     */
    data: XOR<AudioTranscriptionUpdateManyMutationInput, AudioTranscriptionUncheckedUpdateManyInput>
    /**
     * Filter which AudioTranscriptions to update
     */
    where?: AudioTranscriptionWhereInput
    /**
     * Limit how many AudioTranscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTranscription upsert
   */
  export type AudioTranscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioTranscription to update in case it exists.
     */
    where: AudioTranscriptionWhereUniqueInput
    /**
     * In case the AudioTranscription found by the `where` argument doesn't exist, create a new AudioTranscription with this data.
     */
    create: XOR<AudioTranscriptionCreateInput, AudioTranscriptionUncheckedCreateInput>
    /**
     * In case the AudioTranscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioTranscriptionUpdateInput, AudioTranscriptionUncheckedUpdateInput>
  }

  /**
   * AudioTranscription delete
   */
  export type AudioTranscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
    /**
     * Filter which AudioTranscription to delete.
     */
    where: AudioTranscriptionWhereUniqueInput
  }

  /**
   * AudioTranscription deleteMany
   */
  export type AudioTranscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTranscriptions to delete
     */
    where?: AudioTranscriptionWhereInput
    /**
     * Limit how many AudioTranscriptions to delete.
     */
    limit?: number
  }

  /**
   * AudioTranscription without action
   */
  export type AudioTranscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTranscription
     */
    select?: AudioTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTranscription
     */
    omit?: AudioTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTranscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    officeId: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    clientTags?: boolean | Tag$clientTagsArgs<ExtArgs>
    conversationTags?: boolean | Tag$conversationTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "description" | "isActive" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    clientTags?: boolean | Tag$clientTagsArgs<ExtArgs>
    conversationTags?: boolean | Tag$conversationTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      clientTags: Prisma.$ClientTagPayload<ExtArgs>[]
      conversationTags: Prisma.$ConversationTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      officeId: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientTags<T extends Tag$clientTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$clientTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationTags<T extends Tag$conversationTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$conversationTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly isActive: FieldRef<"Tag", 'Boolean'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
    readonly officeId: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.clientTags
   */
  export type Tag$clientTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    where?: ClientTagWhereInput
    orderBy?: ClientTagOrderByWithRelationInput | ClientTagOrderByWithRelationInput[]
    cursor?: ClientTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientTagScalarFieldEnum | ClientTagScalarFieldEnum[]
  }

  /**
   * Tag.conversationTags
   */
  export type Tag$conversationTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    where?: ConversationTagWhereInput
    orderBy?: ConversationTagOrderByWithRelationInput | ConversationTagOrderByWithRelationInput[]
    cursor?: ConversationTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationTagScalarFieldEnum | ConversationTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model ClientTag
   */

  export type AggregateClientTag = {
    _count: ClientTagCountAggregateOutputType | null
    _min: ClientTagMinAggregateOutputType | null
    _max: ClientTagMaxAggregateOutputType | null
  }

  export type ClientTagMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    clientId: string | null
    tagId: string | null
  }

  export type ClientTagMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    clientId: string | null
    tagId: string | null
  }

  export type ClientTagCountAggregateOutputType = {
    id: number
    createdAt: number
    clientId: number
    tagId: number
    _all: number
  }


  export type ClientTagMinAggregateInputType = {
    id?: true
    createdAt?: true
    clientId?: true
    tagId?: true
  }

  export type ClientTagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    clientId?: true
    tagId?: true
  }

  export type ClientTagCountAggregateInputType = {
    id?: true
    createdAt?: true
    clientId?: true
    tagId?: true
    _all?: true
  }

  export type ClientTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientTag to aggregate.
     */
    where?: ClientTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTags to fetch.
     */
    orderBy?: ClientTagOrderByWithRelationInput | ClientTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientTags
    **/
    _count?: true | ClientTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientTagMaxAggregateInputType
  }

  export type GetClientTagAggregateType<T extends ClientTagAggregateArgs> = {
        [P in keyof T & keyof AggregateClientTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientTag[P]>
      : GetScalarType<T[P], AggregateClientTag[P]>
  }




  export type ClientTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientTagWhereInput
    orderBy?: ClientTagOrderByWithAggregationInput | ClientTagOrderByWithAggregationInput[]
    by: ClientTagScalarFieldEnum[] | ClientTagScalarFieldEnum
    having?: ClientTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientTagCountAggregateInputType | true
    _min?: ClientTagMinAggregateInputType
    _max?: ClientTagMaxAggregateInputType
  }

  export type ClientTagGroupByOutputType = {
    id: string
    createdAt: Date
    clientId: string
    tagId: string
    _count: ClientTagCountAggregateOutputType | null
    _min: ClientTagMinAggregateOutputType | null
    _max: ClientTagMaxAggregateOutputType | null
  }

  type GetClientTagGroupByPayload<T extends ClientTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientTagGroupByOutputType[P]>
            : GetScalarType<T[P], ClientTagGroupByOutputType[P]>
        }
      >
    >


  export type ClientTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    clientId?: boolean
    tagId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientTag"]>

  export type ClientTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    clientId?: boolean
    tagId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientTag"]>

  export type ClientTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    clientId?: boolean
    tagId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientTag"]>

  export type ClientTagSelectScalar = {
    id?: boolean
    createdAt?: boolean
    clientId?: boolean
    tagId?: boolean
  }

  export type ClientTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "clientId" | "tagId", ExtArgs["result"]["clientTag"]>
  export type ClientTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ClientTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ClientTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ClientTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientTag"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      clientId: string
      tagId: string
    }, ExtArgs["result"]["clientTag"]>
    composites: {}
  }

  type ClientTagGetPayload<S extends boolean | null | undefined | ClientTagDefaultArgs> = $Result.GetResult<Prisma.$ClientTagPayload, S>

  type ClientTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientTagCountAggregateInputType | true
    }

  export interface ClientTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientTag'], meta: { name: 'ClientTag' } }
    /**
     * Find zero or one ClientTag that matches the filter.
     * @param {ClientTagFindUniqueArgs} args - Arguments to find a ClientTag
     * @example
     * // Get one ClientTag
     * const clientTag = await prisma.clientTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientTagFindUniqueArgs>(args: SelectSubset<T, ClientTagFindUniqueArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientTagFindUniqueOrThrowArgs} args - Arguments to find a ClientTag
     * @example
     * // Get one ClientTag
     * const clientTag = await prisma.clientTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTagFindFirstArgs} args - Arguments to find a ClientTag
     * @example
     * // Get one ClientTag
     * const clientTag = await prisma.clientTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientTagFindFirstArgs>(args?: SelectSubset<T, ClientTagFindFirstArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTagFindFirstOrThrowArgs} args - Arguments to find a ClientTag
     * @example
     * // Get one ClientTag
     * const clientTag = await prisma.clientTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientTags
     * const clientTags = await prisma.clientTag.findMany()
     * 
     * // Get first 10 ClientTags
     * const clientTags = await prisma.clientTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientTagWithIdOnly = await prisma.clientTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientTagFindManyArgs>(args?: SelectSubset<T, ClientTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientTag.
     * @param {ClientTagCreateArgs} args - Arguments to create a ClientTag.
     * @example
     * // Create one ClientTag
     * const ClientTag = await prisma.clientTag.create({
     *   data: {
     *     // ... data to create a ClientTag
     *   }
     * })
     * 
     */
    create<T extends ClientTagCreateArgs>(args: SelectSubset<T, ClientTagCreateArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientTags.
     * @param {ClientTagCreateManyArgs} args - Arguments to create many ClientTags.
     * @example
     * // Create many ClientTags
     * const clientTag = await prisma.clientTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientTagCreateManyArgs>(args?: SelectSubset<T, ClientTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientTags and returns the data saved in the database.
     * @param {ClientTagCreateManyAndReturnArgs} args - Arguments to create many ClientTags.
     * @example
     * // Create many ClientTags
     * const clientTag = await prisma.clientTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientTags and only return the `id`
     * const clientTagWithIdOnly = await prisma.clientTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientTag.
     * @param {ClientTagDeleteArgs} args - Arguments to delete one ClientTag.
     * @example
     * // Delete one ClientTag
     * const ClientTag = await prisma.clientTag.delete({
     *   where: {
     *     // ... filter to delete one ClientTag
     *   }
     * })
     * 
     */
    delete<T extends ClientTagDeleteArgs>(args: SelectSubset<T, ClientTagDeleteArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientTag.
     * @param {ClientTagUpdateArgs} args - Arguments to update one ClientTag.
     * @example
     * // Update one ClientTag
     * const clientTag = await prisma.clientTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientTagUpdateArgs>(args: SelectSubset<T, ClientTagUpdateArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientTags.
     * @param {ClientTagDeleteManyArgs} args - Arguments to filter ClientTags to delete.
     * @example
     * // Delete a few ClientTags
     * const { count } = await prisma.clientTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientTagDeleteManyArgs>(args?: SelectSubset<T, ClientTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientTags
     * const clientTag = await prisma.clientTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientTagUpdateManyArgs>(args: SelectSubset<T, ClientTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientTags and returns the data updated in the database.
     * @param {ClientTagUpdateManyAndReturnArgs} args - Arguments to update many ClientTags.
     * @example
     * // Update many ClientTags
     * const clientTag = await prisma.clientTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientTags and only return the `id`
     * const clientTagWithIdOnly = await prisma.clientTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientTag.
     * @param {ClientTagUpsertArgs} args - Arguments to update or create a ClientTag.
     * @example
     * // Update or create a ClientTag
     * const clientTag = await prisma.clientTag.upsert({
     *   create: {
     *     // ... data to create a ClientTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientTag we want to update
     *   }
     * })
     */
    upsert<T extends ClientTagUpsertArgs>(args: SelectSubset<T, ClientTagUpsertArgs<ExtArgs>>): Prisma__ClientTagClient<$Result.GetResult<Prisma.$ClientTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTagCountArgs} args - Arguments to filter ClientTags to count.
     * @example
     * // Count the number of ClientTags
     * const count = await prisma.clientTag.count({
     *   where: {
     *     // ... the filter for the ClientTags we want to count
     *   }
     * })
    **/
    count<T extends ClientTagCountArgs>(
      args?: Subset<T, ClientTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientTagAggregateArgs>(args: Subset<T, ClientTagAggregateArgs>): Prisma.PrismaPromise<GetClientTagAggregateType<T>>

    /**
     * Group by ClientTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientTagGroupByArgs['orderBy'] }
        : { orderBy?: ClientTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientTag model
   */
  readonly fields: ClientTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientTag model
   */
  interface ClientTagFieldRefs {
    readonly id: FieldRef<"ClientTag", 'String'>
    readonly createdAt: FieldRef<"ClientTag", 'DateTime'>
    readonly clientId: FieldRef<"ClientTag", 'String'>
    readonly tagId: FieldRef<"ClientTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientTag findUnique
   */
  export type ClientTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * Filter, which ClientTag to fetch.
     */
    where: ClientTagWhereUniqueInput
  }

  /**
   * ClientTag findUniqueOrThrow
   */
  export type ClientTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * Filter, which ClientTag to fetch.
     */
    where: ClientTagWhereUniqueInput
  }

  /**
   * ClientTag findFirst
   */
  export type ClientTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * Filter, which ClientTag to fetch.
     */
    where?: ClientTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTags to fetch.
     */
    orderBy?: ClientTagOrderByWithRelationInput | ClientTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientTags.
     */
    cursor?: ClientTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientTags.
     */
    distinct?: ClientTagScalarFieldEnum | ClientTagScalarFieldEnum[]
  }

  /**
   * ClientTag findFirstOrThrow
   */
  export type ClientTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * Filter, which ClientTag to fetch.
     */
    where?: ClientTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTags to fetch.
     */
    orderBy?: ClientTagOrderByWithRelationInput | ClientTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientTags.
     */
    cursor?: ClientTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientTags.
     */
    distinct?: ClientTagScalarFieldEnum | ClientTagScalarFieldEnum[]
  }

  /**
   * ClientTag findMany
   */
  export type ClientTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * Filter, which ClientTags to fetch.
     */
    where?: ClientTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientTags to fetch.
     */
    orderBy?: ClientTagOrderByWithRelationInput | ClientTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientTags.
     */
    cursor?: ClientTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientTags.
     */
    skip?: number
    distinct?: ClientTagScalarFieldEnum | ClientTagScalarFieldEnum[]
  }

  /**
   * ClientTag create
   */
  export type ClientTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientTag.
     */
    data: XOR<ClientTagCreateInput, ClientTagUncheckedCreateInput>
  }

  /**
   * ClientTag createMany
   */
  export type ClientTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientTags.
     */
    data: ClientTagCreateManyInput | ClientTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientTag createManyAndReturn
   */
  export type ClientTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * The data used to create many ClientTags.
     */
    data: ClientTagCreateManyInput | ClientTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientTag update
   */
  export type ClientTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientTag.
     */
    data: XOR<ClientTagUpdateInput, ClientTagUncheckedUpdateInput>
    /**
     * Choose, which ClientTag to update.
     */
    where: ClientTagWhereUniqueInput
  }

  /**
   * ClientTag updateMany
   */
  export type ClientTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientTags.
     */
    data: XOR<ClientTagUpdateManyMutationInput, ClientTagUncheckedUpdateManyInput>
    /**
     * Filter which ClientTags to update
     */
    where?: ClientTagWhereInput
    /**
     * Limit how many ClientTags to update.
     */
    limit?: number
  }

  /**
   * ClientTag updateManyAndReturn
   */
  export type ClientTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * The data used to update ClientTags.
     */
    data: XOR<ClientTagUpdateManyMutationInput, ClientTagUncheckedUpdateManyInput>
    /**
     * Filter which ClientTags to update
     */
    where?: ClientTagWhereInput
    /**
     * Limit how many ClientTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientTag upsert
   */
  export type ClientTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientTag to update in case it exists.
     */
    where: ClientTagWhereUniqueInput
    /**
     * In case the ClientTag found by the `where` argument doesn't exist, create a new ClientTag with this data.
     */
    create: XOR<ClientTagCreateInput, ClientTagUncheckedCreateInput>
    /**
     * In case the ClientTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientTagUpdateInput, ClientTagUncheckedUpdateInput>
  }

  /**
   * ClientTag delete
   */
  export type ClientTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
    /**
     * Filter which ClientTag to delete.
     */
    where: ClientTagWhereUniqueInput
  }

  /**
   * ClientTag deleteMany
   */
  export type ClientTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientTags to delete
     */
    where?: ClientTagWhereInput
    /**
     * Limit how many ClientTags to delete.
     */
    limit?: number
  }

  /**
   * ClientTag without action
   */
  export type ClientTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTag
     */
    select?: ClientTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientTag
     */
    omit?: ClientTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientTagInclude<ExtArgs> | null
  }


  /**
   * Model ConversationTag
   */

  export type AggregateConversationTag = {
    _count: ConversationTagCountAggregateOutputType | null
    _min: ConversationTagMinAggregateOutputType | null
    _max: ConversationTagMaxAggregateOutputType | null
  }

  export type ConversationTagMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    conversationId: string | null
    tagId: string | null
  }

  export type ConversationTagMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    conversationId: string | null
    tagId: string | null
  }

  export type ConversationTagCountAggregateOutputType = {
    id: number
    createdAt: number
    conversationId: number
    tagId: number
    _all: number
  }


  export type ConversationTagMinAggregateInputType = {
    id?: true
    createdAt?: true
    conversationId?: true
    tagId?: true
  }

  export type ConversationTagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    conversationId?: true
    tagId?: true
  }

  export type ConversationTagCountAggregateInputType = {
    id?: true
    createdAt?: true
    conversationId?: true
    tagId?: true
    _all?: true
  }

  export type ConversationTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationTag to aggregate.
     */
    where?: ConversationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationTags to fetch.
     */
    orderBy?: ConversationTagOrderByWithRelationInput | ConversationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationTags
    **/
    _count?: true | ConversationTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationTagMaxAggregateInputType
  }

  export type GetConversationTagAggregateType<T extends ConversationTagAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationTag[P]>
      : GetScalarType<T[P], AggregateConversationTag[P]>
  }




  export type ConversationTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationTagWhereInput
    orderBy?: ConversationTagOrderByWithAggregationInput | ConversationTagOrderByWithAggregationInput[]
    by: ConversationTagScalarFieldEnum[] | ConversationTagScalarFieldEnum
    having?: ConversationTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationTagCountAggregateInputType | true
    _min?: ConversationTagMinAggregateInputType
    _max?: ConversationTagMaxAggregateInputType
  }

  export type ConversationTagGroupByOutputType = {
    id: string
    createdAt: Date
    conversationId: string
    tagId: string
    _count: ConversationTagCountAggregateOutputType | null
    _min: ConversationTagMinAggregateOutputType | null
    _max: ConversationTagMaxAggregateOutputType | null
  }

  type GetConversationTagGroupByPayload<T extends ConversationTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationTagGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationTagGroupByOutputType[P]>
        }
      >
    >


  export type ConversationTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    tagId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationTag"]>

  export type ConversationTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    tagId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationTag"]>

  export type ConversationTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    tagId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationTag"]>

  export type ConversationTagSelectScalar = {
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    tagId?: boolean
  }

  export type ConversationTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "conversationId" | "tagId", ExtArgs["result"]["conversationTag"]>
  export type ConversationTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ConversationTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ConversationTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ConversationTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationTag"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      conversationId: string
      tagId: string
    }, ExtArgs["result"]["conversationTag"]>
    composites: {}
  }

  type ConversationTagGetPayload<S extends boolean | null | undefined | ConversationTagDefaultArgs> = $Result.GetResult<Prisma.$ConversationTagPayload, S>

  type ConversationTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationTagCountAggregateInputType | true
    }

  export interface ConversationTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationTag'], meta: { name: 'ConversationTag' } }
    /**
     * Find zero or one ConversationTag that matches the filter.
     * @param {ConversationTagFindUniqueArgs} args - Arguments to find a ConversationTag
     * @example
     * // Get one ConversationTag
     * const conversationTag = await prisma.conversationTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationTagFindUniqueArgs>(args: SelectSubset<T, ConversationTagFindUniqueArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationTagFindUniqueOrThrowArgs} args - Arguments to find a ConversationTag
     * @example
     * // Get one ConversationTag
     * const conversationTag = await prisma.conversationTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationTagFindFirstArgs} args - Arguments to find a ConversationTag
     * @example
     * // Get one ConversationTag
     * const conversationTag = await prisma.conversationTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationTagFindFirstArgs>(args?: SelectSubset<T, ConversationTagFindFirstArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationTagFindFirstOrThrowArgs} args - Arguments to find a ConversationTag
     * @example
     * // Get one ConversationTag
     * const conversationTag = await prisma.conversationTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationTags
     * const conversationTags = await prisma.conversationTag.findMany()
     * 
     * // Get first 10 ConversationTags
     * const conversationTags = await prisma.conversationTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationTagWithIdOnly = await prisma.conversationTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationTagFindManyArgs>(args?: SelectSubset<T, ConversationTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationTag.
     * @param {ConversationTagCreateArgs} args - Arguments to create a ConversationTag.
     * @example
     * // Create one ConversationTag
     * const ConversationTag = await prisma.conversationTag.create({
     *   data: {
     *     // ... data to create a ConversationTag
     *   }
     * })
     * 
     */
    create<T extends ConversationTagCreateArgs>(args: SelectSubset<T, ConversationTagCreateArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationTags.
     * @param {ConversationTagCreateManyArgs} args - Arguments to create many ConversationTags.
     * @example
     * // Create many ConversationTags
     * const conversationTag = await prisma.conversationTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationTagCreateManyArgs>(args?: SelectSubset<T, ConversationTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationTags and returns the data saved in the database.
     * @param {ConversationTagCreateManyAndReturnArgs} args - Arguments to create many ConversationTags.
     * @example
     * // Create many ConversationTags
     * const conversationTag = await prisma.conversationTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationTags and only return the `id`
     * const conversationTagWithIdOnly = await prisma.conversationTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationTag.
     * @param {ConversationTagDeleteArgs} args - Arguments to delete one ConversationTag.
     * @example
     * // Delete one ConversationTag
     * const ConversationTag = await prisma.conversationTag.delete({
     *   where: {
     *     // ... filter to delete one ConversationTag
     *   }
     * })
     * 
     */
    delete<T extends ConversationTagDeleteArgs>(args: SelectSubset<T, ConversationTagDeleteArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationTag.
     * @param {ConversationTagUpdateArgs} args - Arguments to update one ConversationTag.
     * @example
     * // Update one ConversationTag
     * const conversationTag = await prisma.conversationTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationTagUpdateArgs>(args: SelectSubset<T, ConversationTagUpdateArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationTags.
     * @param {ConversationTagDeleteManyArgs} args - Arguments to filter ConversationTags to delete.
     * @example
     * // Delete a few ConversationTags
     * const { count } = await prisma.conversationTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationTagDeleteManyArgs>(args?: SelectSubset<T, ConversationTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationTags
     * const conversationTag = await prisma.conversationTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationTagUpdateManyArgs>(args: SelectSubset<T, ConversationTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationTags and returns the data updated in the database.
     * @param {ConversationTagUpdateManyAndReturnArgs} args - Arguments to update many ConversationTags.
     * @example
     * // Update many ConversationTags
     * const conversationTag = await prisma.conversationTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationTags and only return the `id`
     * const conversationTagWithIdOnly = await prisma.conversationTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationTag.
     * @param {ConversationTagUpsertArgs} args - Arguments to update or create a ConversationTag.
     * @example
     * // Update or create a ConversationTag
     * const conversationTag = await prisma.conversationTag.upsert({
     *   create: {
     *     // ... data to create a ConversationTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationTag we want to update
     *   }
     * })
     */
    upsert<T extends ConversationTagUpsertArgs>(args: SelectSubset<T, ConversationTagUpsertArgs<ExtArgs>>): Prisma__ConversationTagClient<$Result.GetResult<Prisma.$ConversationTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationTagCountArgs} args - Arguments to filter ConversationTags to count.
     * @example
     * // Count the number of ConversationTags
     * const count = await prisma.conversationTag.count({
     *   where: {
     *     // ... the filter for the ConversationTags we want to count
     *   }
     * })
    **/
    count<T extends ConversationTagCountArgs>(
      args?: Subset<T, ConversationTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationTagAggregateArgs>(args: Subset<T, ConversationTagAggregateArgs>): Prisma.PrismaPromise<GetConversationTagAggregateType<T>>

    /**
     * Group by ConversationTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationTagGroupByArgs['orderBy'] }
        : { orderBy?: ConversationTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationTag model
   */
  readonly fields: ConversationTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationTag model
   */
  interface ConversationTagFieldRefs {
    readonly id: FieldRef<"ConversationTag", 'String'>
    readonly createdAt: FieldRef<"ConversationTag", 'DateTime'>
    readonly conversationId: FieldRef<"ConversationTag", 'String'>
    readonly tagId: FieldRef<"ConversationTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConversationTag findUnique
   */
  export type ConversationTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * Filter, which ConversationTag to fetch.
     */
    where: ConversationTagWhereUniqueInput
  }

  /**
   * ConversationTag findUniqueOrThrow
   */
  export type ConversationTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * Filter, which ConversationTag to fetch.
     */
    where: ConversationTagWhereUniqueInput
  }

  /**
   * ConversationTag findFirst
   */
  export type ConversationTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * Filter, which ConversationTag to fetch.
     */
    where?: ConversationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationTags to fetch.
     */
    orderBy?: ConversationTagOrderByWithRelationInput | ConversationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationTags.
     */
    cursor?: ConversationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationTags.
     */
    distinct?: ConversationTagScalarFieldEnum | ConversationTagScalarFieldEnum[]
  }

  /**
   * ConversationTag findFirstOrThrow
   */
  export type ConversationTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * Filter, which ConversationTag to fetch.
     */
    where?: ConversationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationTags to fetch.
     */
    orderBy?: ConversationTagOrderByWithRelationInput | ConversationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationTags.
     */
    cursor?: ConversationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationTags.
     */
    distinct?: ConversationTagScalarFieldEnum | ConversationTagScalarFieldEnum[]
  }

  /**
   * ConversationTag findMany
   */
  export type ConversationTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * Filter, which ConversationTags to fetch.
     */
    where?: ConversationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationTags to fetch.
     */
    orderBy?: ConversationTagOrderByWithRelationInput | ConversationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationTags.
     */
    cursor?: ConversationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationTags.
     */
    skip?: number
    distinct?: ConversationTagScalarFieldEnum | ConversationTagScalarFieldEnum[]
  }

  /**
   * ConversationTag create
   */
  export type ConversationTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationTag.
     */
    data: XOR<ConversationTagCreateInput, ConversationTagUncheckedCreateInput>
  }

  /**
   * ConversationTag createMany
   */
  export type ConversationTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationTags.
     */
    data: ConversationTagCreateManyInput | ConversationTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationTag createManyAndReturn
   */
  export type ConversationTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationTags.
     */
    data: ConversationTagCreateManyInput | ConversationTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationTag update
   */
  export type ConversationTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationTag.
     */
    data: XOR<ConversationTagUpdateInput, ConversationTagUncheckedUpdateInput>
    /**
     * Choose, which ConversationTag to update.
     */
    where: ConversationTagWhereUniqueInput
  }

  /**
   * ConversationTag updateMany
   */
  export type ConversationTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationTags.
     */
    data: XOR<ConversationTagUpdateManyMutationInput, ConversationTagUncheckedUpdateManyInput>
    /**
     * Filter which ConversationTags to update
     */
    where?: ConversationTagWhereInput
    /**
     * Limit how many ConversationTags to update.
     */
    limit?: number
  }

  /**
   * ConversationTag updateManyAndReturn
   */
  export type ConversationTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * The data used to update ConversationTags.
     */
    data: XOR<ConversationTagUpdateManyMutationInput, ConversationTagUncheckedUpdateManyInput>
    /**
     * Filter which ConversationTags to update
     */
    where?: ConversationTagWhereInput
    /**
     * Limit how many ConversationTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationTag upsert
   */
  export type ConversationTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationTag to update in case it exists.
     */
    where: ConversationTagWhereUniqueInput
    /**
     * In case the ConversationTag found by the `where` argument doesn't exist, create a new ConversationTag with this data.
     */
    create: XOR<ConversationTagCreateInput, ConversationTagUncheckedCreateInput>
    /**
     * In case the ConversationTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationTagUpdateInput, ConversationTagUncheckedUpdateInput>
  }

  /**
   * ConversationTag delete
   */
  export type ConversationTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
    /**
     * Filter which ConversationTag to delete.
     */
    where: ConversationTagWhereUniqueInput
  }

  /**
   * ConversationTag deleteMany
   */
  export type ConversationTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationTags to delete
     */
    where?: ConversationTagWhereInput
    /**
     * Limit how many ConversationTags to delete.
     */
    limit?: number
  }

  /**
   * ConversationTag without action
   */
  export type ConversationTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationTag
     */
    select?: ConversationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationTag
     */
    omit?: ConversationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationTagInclude<ExtArgs> | null
  }


  /**
   * Model CustomStatus
   */

  export type AggregateCustomStatus = {
    _count: CustomStatusCountAggregateOutputType | null
    _avg: CustomStatusAvgAggregateOutputType | null
    _sum: CustomStatusSumAggregateOutputType | null
    _min: CustomStatusMinAggregateOutputType | null
    _max: CustomStatusMaxAggregateOutputType | null
  }

  export type CustomStatusAvgAggregateOutputType = {
    order: number | null
  }

  export type CustomStatusSumAggregateOutputType = {
    order: number | null
  }

  export type CustomStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type CustomStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type CustomStatusCountAggregateOutputType = {
    id: number
    name: number
    color: number
    description: number
    isActive: number
    order: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type CustomStatusAvgAggregateInputType = {
    order?: true
  }

  export type CustomStatusSumAggregateInputType = {
    order?: true
  }

  export type CustomStatusMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type CustomStatusMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type CustomStatusCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type CustomStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomStatus to aggregate.
     */
    where?: CustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomStatuses to fetch.
     */
    orderBy?: CustomStatusOrderByWithRelationInput | CustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomStatuses
    **/
    _count?: true | CustomStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomStatusMaxAggregateInputType
  }

  export type GetCustomStatusAggregateType<T extends CustomStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomStatus[P]>
      : GetScalarType<T[P], AggregateCustomStatus[P]>
  }




  export type CustomStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomStatusWhereInput
    orderBy?: CustomStatusOrderByWithAggregationInput | CustomStatusOrderByWithAggregationInput[]
    by: CustomStatusScalarFieldEnum[] | CustomStatusScalarFieldEnum
    having?: CustomStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomStatusCountAggregateInputType | true
    _avg?: CustomStatusAvgAggregateInputType
    _sum?: CustomStatusSumAggregateInputType
    _min?: CustomStatusMinAggregateInputType
    _max?: CustomStatusMaxAggregateInputType
  }

  export type CustomStatusGroupByOutputType = {
    id: string
    name: string
    color: string
    description: string | null
    isActive: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    officeId: string
    _count: CustomStatusCountAggregateOutputType | null
    _avg: CustomStatusAvgAggregateOutputType | null
    _sum: CustomStatusSumAggregateOutputType | null
    _min: CustomStatusMinAggregateOutputType | null
    _max: CustomStatusMaxAggregateOutputType | null
  }

  type GetCustomStatusGroupByPayload<T extends CustomStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomStatusGroupByOutputType[P]>
            : GetScalarType<T[P], CustomStatusGroupByOutputType[P]>
        }
      >
    >


  export type CustomStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    conversationStatuses?: boolean | CustomStatus$conversationStatusesArgs<ExtArgs>
    _count?: boolean | CustomStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customStatus"]>

  export type CustomStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customStatus"]>

  export type CustomStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customStatus"]>

  export type CustomStatusSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type CustomStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "description" | "isActive" | "order" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["customStatus"]>
  export type CustomStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    conversationStatuses?: boolean | CustomStatus$conversationStatusesArgs<ExtArgs>
    _count?: boolean | CustomStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type CustomStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $CustomStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomStatus"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      conversationStatuses: Prisma.$ConversationCustomStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      description: string | null
      isActive: boolean
      order: number
      createdAt: Date
      updatedAt: Date
      officeId: string
    }, ExtArgs["result"]["customStatus"]>
    composites: {}
  }

  type CustomStatusGetPayload<S extends boolean | null | undefined | CustomStatusDefaultArgs> = $Result.GetResult<Prisma.$CustomStatusPayload, S>

  type CustomStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomStatusCountAggregateInputType | true
    }

  export interface CustomStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomStatus'], meta: { name: 'CustomStatus' } }
    /**
     * Find zero or one CustomStatus that matches the filter.
     * @param {CustomStatusFindUniqueArgs} args - Arguments to find a CustomStatus
     * @example
     * // Get one CustomStatus
     * const customStatus = await prisma.customStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomStatusFindUniqueArgs>(args: SelectSubset<T, CustomStatusFindUniqueArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomStatusFindUniqueOrThrowArgs} args - Arguments to find a CustomStatus
     * @example
     * // Get one CustomStatus
     * const customStatus = await prisma.customStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomStatusFindFirstArgs} args - Arguments to find a CustomStatus
     * @example
     * // Get one CustomStatus
     * const customStatus = await prisma.customStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomStatusFindFirstArgs>(args?: SelectSubset<T, CustomStatusFindFirstArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomStatusFindFirstOrThrowArgs} args - Arguments to find a CustomStatus
     * @example
     * // Get one CustomStatus
     * const customStatus = await prisma.customStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomStatuses
     * const customStatuses = await prisma.customStatus.findMany()
     * 
     * // Get first 10 CustomStatuses
     * const customStatuses = await prisma.customStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customStatusWithIdOnly = await prisma.customStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomStatusFindManyArgs>(args?: SelectSubset<T, CustomStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomStatus.
     * @param {CustomStatusCreateArgs} args - Arguments to create a CustomStatus.
     * @example
     * // Create one CustomStatus
     * const CustomStatus = await prisma.customStatus.create({
     *   data: {
     *     // ... data to create a CustomStatus
     *   }
     * })
     * 
     */
    create<T extends CustomStatusCreateArgs>(args: SelectSubset<T, CustomStatusCreateArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomStatuses.
     * @param {CustomStatusCreateManyArgs} args - Arguments to create many CustomStatuses.
     * @example
     * // Create many CustomStatuses
     * const customStatus = await prisma.customStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomStatusCreateManyArgs>(args?: SelectSubset<T, CustomStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomStatuses and returns the data saved in the database.
     * @param {CustomStatusCreateManyAndReturnArgs} args - Arguments to create many CustomStatuses.
     * @example
     * // Create many CustomStatuses
     * const customStatus = await prisma.customStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomStatuses and only return the `id`
     * const customStatusWithIdOnly = await prisma.customStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomStatus.
     * @param {CustomStatusDeleteArgs} args - Arguments to delete one CustomStatus.
     * @example
     * // Delete one CustomStatus
     * const CustomStatus = await prisma.customStatus.delete({
     *   where: {
     *     // ... filter to delete one CustomStatus
     *   }
     * })
     * 
     */
    delete<T extends CustomStatusDeleteArgs>(args: SelectSubset<T, CustomStatusDeleteArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomStatus.
     * @param {CustomStatusUpdateArgs} args - Arguments to update one CustomStatus.
     * @example
     * // Update one CustomStatus
     * const customStatus = await prisma.customStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomStatusUpdateArgs>(args: SelectSubset<T, CustomStatusUpdateArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomStatuses.
     * @param {CustomStatusDeleteManyArgs} args - Arguments to filter CustomStatuses to delete.
     * @example
     * // Delete a few CustomStatuses
     * const { count } = await prisma.customStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomStatusDeleteManyArgs>(args?: SelectSubset<T, CustomStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomStatuses
     * const customStatus = await prisma.customStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomStatusUpdateManyArgs>(args: SelectSubset<T, CustomStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomStatuses and returns the data updated in the database.
     * @param {CustomStatusUpdateManyAndReturnArgs} args - Arguments to update many CustomStatuses.
     * @example
     * // Update many CustomStatuses
     * const customStatus = await prisma.customStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomStatuses and only return the `id`
     * const customStatusWithIdOnly = await prisma.customStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomStatus.
     * @param {CustomStatusUpsertArgs} args - Arguments to update or create a CustomStatus.
     * @example
     * // Update or create a CustomStatus
     * const customStatus = await prisma.customStatus.upsert({
     *   create: {
     *     // ... data to create a CustomStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomStatus we want to update
     *   }
     * })
     */
    upsert<T extends CustomStatusUpsertArgs>(args: SelectSubset<T, CustomStatusUpsertArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomStatusCountArgs} args - Arguments to filter CustomStatuses to count.
     * @example
     * // Count the number of CustomStatuses
     * const count = await prisma.customStatus.count({
     *   where: {
     *     // ... the filter for the CustomStatuses we want to count
     *   }
     * })
    **/
    count<T extends CustomStatusCountArgs>(
      args?: Subset<T, CustomStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomStatusAggregateArgs>(args: Subset<T, CustomStatusAggregateArgs>): Prisma.PrismaPromise<GetCustomStatusAggregateType<T>>

    /**
     * Group by CustomStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomStatusGroupByArgs['orderBy'] }
        : { orderBy?: CustomStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomStatus model
   */
  readonly fields: CustomStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversationStatuses<T extends CustomStatus$conversationStatusesArgs<ExtArgs> = {}>(args?: Subset<T, CustomStatus$conversationStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomStatus model
   */
  interface CustomStatusFieldRefs {
    readonly id: FieldRef<"CustomStatus", 'String'>
    readonly name: FieldRef<"CustomStatus", 'String'>
    readonly color: FieldRef<"CustomStatus", 'String'>
    readonly description: FieldRef<"CustomStatus", 'String'>
    readonly isActive: FieldRef<"CustomStatus", 'Boolean'>
    readonly order: FieldRef<"CustomStatus", 'Int'>
    readonly createdAt: FieldRef<"CustomStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomStatus", 'DateTime'>
    readonly officeId: FieldRef<"CustomStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomStatus findUnique
   */
  export type CustomStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which CustomStatus to fetch.
     */
    where: CustomStatusWhereUniqueInput
  }

  /**
   * CustomStatus findUniqueOrThrow
   */
  export type CustomStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which CustomStatus to fetch.
     */
    where: CustomStatusWhereUniqueInput
  }

  /**
   * CustomStatus findFirst
   */
  export type CustomStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which CustomStatus to fetch.
     */
    where?: CustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomStatuses to fetch.
     */
    orderBy?: CustomStatusOrderByWithRelationInput | CustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomStatuses.
     */
    cursor?: CustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomStatuses.
     */
    distinct?: CustomStatusScalarFieldEnum | CustomStatusScalarFieldEnum[]
  }

  /**
   * CustomStatus findFirstOrThrow
   */
  export type CustomStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which CustomStatus to fetch.
     */
    where?: CustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomStatuses to fetch.
     */
    orderBy?: CustomStatusOrderByWithRelationInput | CustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomStatuses.
     */
    cursor?: CustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomStatuses.
     */
    distinct?: CustomStatusScalarFieldEnum | CustomStatusScalarFieldEnum[]
  }

  /**
   * CustomStatus findMany
   */
  export type CustomStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which CustomStatuses to fetch.
     */
    where?: CustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomStatuses to fetch.
     */
    orderBy?: CustomStatusOrderByWithRelationInput | CustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomStatuses.
     */
    cursor?: CustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomStatuses.
     */
    skip?: number
    distinct?: CustomStatusScalarFieldEnum | CustomStatusScalarFieldEnum[]
  }

  /**
   * CustomStatus create
   */
  export type CustomStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomStatus.
     */
    data: XOR<CustomStatusCreateInput, CustomStatusUncheckedCreateInput>
  }

  /**
   * CustomStatus createMany
   */
  export type CustomStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomStatuses.
     */
    data: CustomStatusCreateManyInput | CustomStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomStatus createManyAndReturn
   */
  export type CustomStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * The data used to create many CustomStatuses.
     */
    data: CustomStatusCreateManyInput | CustomStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomStatus update
   */
  export type CustomStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomStatus.
     */
    data: XOR<CustomStatusUpdateInput, CustomStatusUncheckedUpdateInput>
    /**
     * Choose, which CustomStatus to update.
     */
    where: CustomStatusWhereUniqueInput
  }

  /**
   * CustomStatus updateMany
   */
  export type CustomStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomStatuses.
     */
    data: XOR<CustomStatusUpdateManyMutationInput, CustomStatusUncheckedUpdateManyInput>
    /**
     * Filter which CustomStatuses to update
     */
    where?: CustomStatusWhereInput
    /**
     * Limit how many CustomStatuses to update.
     */
    limit?: number
  }

  /**
   * CustomStatus updateManyAndReturn
   */
  export type CustomStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * The data used to update CustomStatuses.
     */
    data: XOR<CustomStatusUpdateManyMutationInput, CustomStatusUncheckedUpdateManyInput>
    /**
     * Filter which CustomStatuses to update
     */
    where?: CustomStatusWhereInput
    /**
     * Limit how many CustomStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomStatus upsert
   */
  export type CustomStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomStatus to update in case it exists.
     */
    where: CustomStatusWhereUniqueInput
    /**
     * In case the CustomStatus found by the `where` argument doesn't exist, create a new CustomStatus with this data.
     */
    create: XOR<CustomStatusCreateInput, CustomStatusUncheckedCreateInput>
    /**
     * In case the CustomStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomStatusUpdateInput, CustomStatusUncheckedUpdateInput>
  }

  /**
   * CustomStatus delete
   */
  export type CustomStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
    /**
     * Filter which CustomStatus to delete.
     */
    where: CustomStatusWhereUniqueInput
  }

  /**
   * CustomStatus deleteMany
   */
  export type CustomStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomStatuses to delete
     */
    where?: CustomStatusWhereInput
    /**
     * Limit how many CustomStatuses to delete.
     */
    limit?: number
  }

  /**
   * CustomStatus.conversationStatuses
   */
  export type CustomStatus$conversationStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    where?: ConversationCustomStatusWhereInput
    orderBy?: ConversationCustomStatusOrderByWithRelationInput | ConversationCustomStatusOrderByWithRelationInput[]
    cursor?: ConversationCustomStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationCustomStatusScalarFieldEnum | ConversationCustomStatusScalarFieldEnum[]
  }

  /**
   * CustomStatus without action
   */
  export type CustomStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomStatus
     */
    select?: CustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomStatus
     */
    omit?: CustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomStatusInclude<ExtArgs> | null
  }


  /**
   * Model ConversationCustomStatus
   */

  export type AggregateConversationCustomStatus = {
    _count: ConversationCustomStatusCountAggregateOutputType | null
    _min: ConversationCustomStatusMinAggregateOutputType | null
    _max: ConversationCustomStatusMaxAggregateOutputType | null
  }

  export type ConversationCustomStatusMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    conversationId: string | null
    customStatusId: string | null
  }

  export type ConversationCustomStatusMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    conversationId: string | null
    customStatusId: string | null
  }

  export type ConversationCustomStatusCountAggregateOutputType = {
    id: number
    createdAt: number
    conversationId: number
    customStatusId: number
    _all: number
  }


  export type ConversationCustomStatusMinAggregateInputType = {
    id?: true
    createdAt?: true
    conversationId?: true
    customStatusId?: true
  }

  export type ConversationCustomStatusMaxAggregateInputType = {
    id?: true
    createdAt?: true
    conversationId?: true
    customStatusId?: true
  }

  export type ConversationCustomStatusCountAggregateInputType = {
    id?: true
    createdAt?: true
    conversationId?: true
    customStatusId?: true
    _all?: true
  }

  export type ConversationCustomStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationCustomStatus to aggregate.
     */
    where?: ConversationCustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationCustomStatuses to fetch.
     */
    orderBy?: ConversationCustomStatusOrderByWithRelationInput | ConversationCustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationCustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationCustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationCustomStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationCustomStatuses
    **/
    _count?: true | ConversationCustomStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationCustomStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationCustomStatusMaxAggregateInputType
  }

  export type GetConversationCustomStatusAggregateType<T extends ConversationCustomStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationCustomStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationCustomStatus[P]>
      : GetScalarType<T[P], AggregateConversationCustomStatus[P]>
  }




  export type ConversationCustomStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationCustomStatusWhereInput
    orderBy?: ConversationCustomStatusOrderByWithAggregationInput | ConversationCustomStatusOrderByWithAggregationInput[]
    by: ConversationCustomStatusScalarFieldEnum[] | ConversationCustomStatusScalarFieldEnum
    having?: ConversationCustomStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCustomStatusCountAggregateInputType | true
    _min?: ConversationCustomStatusMinAggregateInputType
    _max?: ConversationCustomStatusMaxAggregateInputType
  }

  export type ConversationCustomStatusGroupByOutputType = {
    id: string
    createdAt: Date
    conversationId: string
    customStatusId: string
    _count: ConversationCustomStatusCountAggregateOutputType | null
    _min: ConversationCustomStatusMinAggregateOutputType | null
    _max: ConversationCustomStatusMaxAggregateOutputType | null
  }

  type GetConversationCustomStatusGroupByPayload<T extends ConversationCustomStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationCustomStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationCustomStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationCustomStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationCustomStatusGroupByOutputType[P]>
        }
      >
    >


  export type ConversationCustomStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    customStatusId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    customStatus?: boolean | CustomStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationCustomStatus"]>

  export type ConversationCustomStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    customStatusId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    customStatus?: boolean | CustomStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationCustomStatus"]>

  export type ConversationCustomStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    customStatusId?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    customStatus?: boolean | CustomStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationCustomStatus"]>

  export type ConversationCustomStatusSelectScalar = {
    id?: boolean
    createdAt?: boolean
    conversationId?: boolean
    customStatusId?: boolean
  }

  export type ConversationCustomStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "conversationId" | "customStatusId", ExtArgs["result"]["conversationCustomStatus"]>
  export type ConversationCustomStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    customStatus?: boolean | CustomStatusDefaultArgs<ExtArgs>
  }
  export type ConversationCustomStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    customStatus?: boolean | CustomStatusDefaultArgs<ExtArgs>
  }
  export type ConversationCustomStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    customStatus?: boolean | CustomStatusDefaultArgs<ExtArgs>
  }

  export type $ConversationCustomStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationCustomStatus"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      customStatus: Prisma.$CustomStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      conversationId: string
      customStatusId: string
    }, ExtArgs["result"]["conversationCustomStatus"]>
    composites: {}
  }

  type ConversationCustomStatusGetPayload<S extends boolean | null | undefined | ConversationCustomStatusDefaultArgs> = $Result.GetResult<Prisma.$ConversationCustomStatusPayload, S>

  type ConversationCustomStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationCustomStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCustomStatusCountAggregateInputType | true
    }

  export interface ConversationCustomStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationCustomStatus'], meta: { name: 'ConversationCustomStatus' } }
    /**
     * Find zero or one ConversationCustomStatus that matches the filter.
     * @param {ConversationCustomStatusFindUniqueArgs} args - Arguments to find a ConversationCustomStatus
     * @example
     * // Get one ConversationCustomStatus
     * const conversationCustomStatus = await prisma.conversationCustomStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationCustomStatusFindUniqueArgs>(args: SelectSubset<T, ConversationCustomStatusFindUniqueArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationCustomStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationCustomStatusFindUniqueOrThrowArgs} args - Arguments to find a ConversationCustomStatus
     * @example
     * // Get one ConversationCustomStatus
     * const conversationCustomStatus = await prisma.conversationCustomStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationCustomStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationCustomStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationCustomStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCustomStatusFindFirstArgs} args - Arguments to find a ConversationCustomStatus
     * @example
     * // Get one ConversationCustomStatus
     * const conversationCustomStatus = await prisma.conversationCustomStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationCustomStatusFindFirstArgs>(args?: SelectSubset<T, ConversationCustomStatusFindFirstArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationCustomStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCustomStatusFindFirstOrThrowArgs} args - Arguments to find a ConversationCustomStatus
     * @example
     * // Get one ConversationCustomStatus
     * const conversationCustomStatus = await prisma.conversationCustomStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationCustomStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationCustomStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationCustomStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCustomStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationCustomStatuses
     * const conversationCustomStatuses = await prisma.conversationCustomStatus.findMany()
     * 
     * // Get first 10 ConversationCustomStatuses
     * const conversationCustomStatuses = await prisma.conversationCustomStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationCustomStatusWithIdOnly = await prisma.conversationCustomStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationCustomStatusFindManyArgs>(args?: SelectSubset<T, ConversationCustomStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationCustomStatus.
     * @param {ConversationCustomStatusCreateArgs} args - Arguments to create a ConversationCustomStatus.
     * @example
     * // Create one ConversationCustomStatus
     * const ConversationCustomStatus = await prisma.conversationCustomStatus.create({
     *   data: {
     *     // ... data to create a ConversationCustomStatus
     *   }
     * })
     * 
     */
    create<T extends ConversationCustomStatusCreateArgs>(args: SelectSubset<T, ConversationCustomStatusCreateArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationCustomStatuses.
     * @param {ConversationCustomStatusCreateManyArgs} args - Arguments to create many ConversationCustomStatuses.
     * @example
     * // Create many ConversationCustomStatuses
     * const conversationCustomStatus = await prisma.conversationCustomStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCustomStatusCreateManyArgs>(args?: SelectSubset<T, ConversationCustomStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationCustomStatuses and returns the data saved in the database.
     * @param {ConversationCustomStatusCreateManyAndReturnArgs} args - Arguments to create many ConversationCustomStatuses.
     * @example
     * // Create many ConversationCustomStatuses
     * const conversationCustomStatus = await prisma.conversationCustomStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationCustomStatuses and only return the `id`
     * const conversationCustomStatusWithIdOnly = await prisma.conversationCustomStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCustomStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCustomStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationCustomStatus.
     * @param {ConversationCustomStatusDeleteArgs} args - Arguments to delete one ConversationCustomStatus.
     * @example
     * // Delete one ConversationCustomStatus
     * const ConversationCustomStatus = await prisma.conversationCustomStatus.delete({
     *   where: {
     *     // ... filter to delete one ConversationCustomStatus
     *   }
     * })
     * 
     */
    delete<T extends ConversationCustomStatusDeleteArgs>(args: SelectSubset<T, ConversationCustomStatusDeleteArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationCustomStatus.
     * @param {ConversationCustomStatusUpdateArgs} args - Arguments to update one ConversationCustomStatus.
     * @example
     * // Update one ConversationCustomStatus
     * const conversationCustomStatus = await prisma.conversationCustomStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationCustomStatusUpdateArgs>(args: SelectSubset<T, ConversationCustomStatusUpdateArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationCustomStatuses.
     * @param {ConversationCustomStatusDeleteManyArgs} args - Arguments to filter ConversationCustomStatuses to delete.
     * @example
     * // Delete a few ConversationCustomStatuses
     * const { count } = await prisma.conversationCustomStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationCustomStatusDeleteManyArgs>(args?: SelectSubset<T, ConversationCustomStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationCustomStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCustomStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationCustomStatuses
     * const conversationCustomStatus = await prisma.conversationCustomStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationCustomStatusUpdateManyArgs>(args: SelectSubset<T, ConversationCustomStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationCustomStatuses and returns the data updated in the database.
     * @param {ConversationCustomStatusUpdateManyAndReturnArgs} args - Arguments to update many ConversationCustomStatuses.
     * @example
     * // Update many ConversationCustomStatuses
     * const conversationCustomStatus = await prisma.conversationCustomStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationCustomStatuses and only return the `id`
     * const conversationCustomStatusWithIdOnly = await prisma.conversationCustomStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationCustomStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationCustomStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationCustomStatus.
     * @param {ConversationCustomStatusUpsertArgs} args - Arguments to update or create a ConversationCustomStatus.
     * @example
     * // Update or create a ConversationCustomStatus
     * const conversationCustomStatus = await prisma.conversationCustomStatus.upsert({
     *   create: {
     *     // ... data to create a ConversationCustomStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationCustomStatus we want to update
     *   }
     * })
     */
    upsert<T extends ConversationCustomStatusUpsertArgs>(args: SelectSubset<T, ConversationCustomStatusUpsertArgs<ExtArgs>>): Prisma__ConversationCustomStatusClient<$Result.GetResult<Prisma.$ConversationCustomStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationCustomStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCustomStatusCountArgs} args - Arguments to filter ConversationCustomStatuses to count.
     * @example
     * // Count the number of ConversationCustomStatuses
     * const count = await prisma.conversationCustomStatus.count({
     *   where: {
     *     // ... the filter for the ConversationCustomStatuses we want to count
     *   }
     * })
    **/
    count<T extends ConversationCustomStatusCountArgs>(
      args?: Subset<T, ConversationCustomStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCustomStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationCustomStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCustomStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationCustomStatusAggregateArgs>(args: Subset<T, ConversationCustomStatusAggregateArgs>): Prisma.PrismaPromise<GetConversationCustomStatusAggregateType<T>>

    /**
     * Group by ConversationCustomStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCustomStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationCustomStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationCustomStatusGroupByArgs['orderBy'] }
        : { orderBy?: ConversationCustomStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationCustomStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationCustomStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationCustomStatus model
   */
  readonly fields: ConversationCustomStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationCustomStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationCustomStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customStatus<T extends CustomStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomStatusDefaultArgs<ExtArgs>>): Prisma__CustomStatusClient<$Result.GetResult<Prisma.$CustomStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationCustomStatus model
   */
  interface ConversationCustomStatusFieldRefs {
    readonly id: FieldRef<"ConversationCustomStatus", 'String'>
    readonly createdAt: FieldRef<"ConversationCustomStatus", 'DateTime'>
    readonly conversationId: FieldRef<"ConversationCustomStatus", 'String'>
    readonly customStatusId: FieldRef<"ConversationCustomStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConversationCustomStatus findUnique
   */
  export type ConversationCustomStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which ConversationCustomStatus to fetch.
     */
    where: ConversationCustomStatusWhereUniqueInput
  }

  /**
   * ConversationCustomStatus findUniqueOrThrow
   */
  export type ConversationCustomStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which ConversationCustomStatus to fetch.
     */
    where: ConversationCustomStatusWhereUniqueInput
  }

  /**
   * ConversationCustomStatus findFirst
   */
  export type ConversationCustomStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which ConversationCustomStatus to fetch.
     */
    where?: ConversationCustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationCustomStatuses to fetch.
     */
    orderBy?: ConversationCustomStatusOrderByWithRelationInput | ConversationCustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationCustomStatuses.
     */
    cursor?: ConversationCustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationCustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationCustomStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationCustomStatuses.
     */
    distinct?: ConversationCustomStatusScalarFieldEnum | ConversationCustomStatusScalarFieldEnum[]
  }

  /**
   * ConversationCustomStatus findFirstOrThrow
   */
  export type ConversationCustomStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which ConversationCustomStatus to fetch.
     */
    where?: ConversationCustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationCustomStatuses to fetch.
     */
    orderBy?: ConversationCustomStatusOrderByWithRelationInput | ConversationCustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationCustomStatuses.
     */
    cursor?: ConversationCustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationCustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationCustomStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationCustomStatuses.
     */
    distinct?: ConversationCustomStatusScalarFieldEnum | ConversationCustomStatusScalarFieldEnum[]
  }

  /**
   * ConversationCustomStatus findMany
   */
  export type ConversationCustomStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * Filter, which ConversationCustomStatuses to fetch.
     */
    where?: ConversationCustomStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationCustomStatuses to fetch.
     */
    orderBy?: ConversationCustomStatusOrderByWithRelationInput | ConversationCustomStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationCustomStatuses.
     */
    cursor?: ConversationCustomStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationCustomStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationCustomStatuses.
     */
    skip?: number
    distinct?: ConversationCustomStatusScalarFieldEnum | ConversationCustomStatusScalarFieldEnum[]
  }

  /**
   * ConversationCustomStatus create
   */
  export type ConversationCustomStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationCustomStatus.
     */
    data: XOR<ConversationCustomStatusCreateInput, ConversationCustomStatusUncheckedCreateInput>
  }

  /**
   * ConversationCustomStatus createMany
   */
  export type ConversationCustomStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationCustomStatuses.
     */
    data: ConversationCustomStatusCreateManyInput | ConversationCustomStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationCustomStatus createManyAndReturn
   */
  export type ConversationCustomStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationCustomStatuses.
     */
    data: ConversationCustomStatusCreateManyInput | ConversationCustomStatusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationCustomStatus update
   */
  export type ConversationCustomStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationCustomStatus.
     */
    data: XOR<ConversationCustomStatusUpdateInput, ConversationCustomStatusUncheckedUpdateInput>
    /**
     * Choose, which ConversationCustomStatus to update.
     */
    where: ConversationCustomStatusWhereUniqueInput
  }

  /**
   * ConversationCustomStatus updateMany
   */
  export type ConversationCustomStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationCustomStatuses.
     */
    data: XOR<ConversationCustomStatusUpdateManyMutationInput, ConversationCustomStatusUncheckedUpdateManyInput>
    /**
     * Filter which ConversationCustomStatuses to update
     */
    where?: ConversationCustomStatusWhereInput
    /**
     * Limit how many ConversationCustomStatuses to update.
     */
    limit?: number
  }

  /**
   * ConversationCustomStatus updateManyAndReturn
   */
  export type ConversationCustomStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * The data used to update ConversationCustomStatuses.
     */
    data: XOR<ConversationCustomStatusUpdateManyMutationInput, ConversationCustomStatusUncheckedUpdateManyInput>
    /**
     * Filter which ConversationCustomStatuses to update
     */
    where?: ConversationCustomStatusWhereInput
    /**
     * Limit how many ConversationCustomStatuses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationCustomStatus upsert
   */
  export type ConversationCustomStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationCustomStatus to update in case it exists.
     */
    where: ConversationCustomStatusWhereUniqueInput
    /**
     * In case the ConversationCustomStatus found by the `where` argument doesn't exist, create a new ConversationCustomStatus with this data.
     */
    create: XOR<ConversationCustomStatusCreateInput, ConversationCustomStatusUncheckedCreateInput>
    /**
     * In case the ConversationCustomStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationCustomStatusUpdateInput, ConversationCustomStatusUncheckedUpdateInput>
  }

  /**
   * ConversationCustomStatus delete
   */
  export type ConversationCustomStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
    /**
     * Filter which ConversationCustomStatus to delete.
     */
    where: ConversationCustomStatusWhereUniqueInput
  }

  /**
   * ConversationCustomStatus deleteMany
   */
  export type ConversationCustomStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationCustomStatuses to delete
     */
    where?: ConversationCustomStatusWhereInput
    /**
     * Limit how many ConversationCustomStatuses to delete.
     */
    limit?: number
  }

  /**
   * ConversationCustomStatus without action
   */
  export type ConversationCustomStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCustomStatus
     */
    select?: ConversationCustomStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationCustomStatus
     */
    omit?: ConversationCustomStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationCustomStatusInclude<ExtArgs> | null
  }


  /**
   * Model AiAgent
   */

  export type AggregateAiAgent = {
    _count: AiAgentCountAggregateOutputType | null
    _avg: AiAgentAvgAggregateOutputType | null
    _sum: AiAgentSumAggregateOutputType | null
    _min: AiAgentMinAggregateOutputType | null
    _max: AiAgentMaxAggregateOutputType | null
  }

  export type AiAgentAvgAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type AiAgentSumAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type AiAgentMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AgentType | null
    prompt: string | null
    model: string | null
    provider: $Enums.AIProvider | null
    aiModel: $Enums.AIModel | null
    temperature: number | null
    maxTokens: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type AiAgentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AgentType | null
    prompt: string | null
    model: string | null
    provider: $Enums.AIProvider | null
    aiModel: $Enums.AIModel | null
    temperature: number | null
    maxTokens: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type AiAgentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    prompt: number
    model: number
    provider: number
    aiModel: number
    temperature: number
    maxTokens: number
    isActive: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type AiAgentAvgAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type AiAgentSumAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type AiAgentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    prompt?: true
    model?: true
    provider?: true
    aiModel?: true
    temperature?: true
    maxTokens?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type AiAgentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    prompt?: true
    model?: true
    provider?: true
    aiModel?: true
    temperature?: true
    maxTokens?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type AiAgentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    prompt?: true
    model?: true
    provider?: true
    aiModel?: true
    temperature?: true
    maxTokens?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type AiAgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAgent to aggregate.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiAgents
    **/
    _count?: true | AiAgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiAgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiAgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiAgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiAgentMaxAggregateInputType
  }

  export type GetAiAgentAggregateType<T extends AiAgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAiAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiAgent[P]>
      : GetScalarType<T[P], AggregateAiAgent[P]>
  }




  export type AiAgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiAgentWhereInput
    orderBy?: AiAgentOrderByWithAggregationInput | AiAgentOrderByWithAggregationInput[]
    by: AiAgentScalarFieldEnum[] | AiAgentScalarFieldEnum
    having?: AiAgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiAgentCountAggregateInputType | true
    _avg?: AiAgentAvgAggregateInputType
    _sum?: AiAgentSumAggregateInputType
    _min?: AiAgentMinAggregateInputType
    _max?: AiAgentMaxAggregateInputType
  }

  export type AiAgentGroupByOutputType = {
    id: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature: number
    maxTokens: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    officeId: string
    _count: AiAgentCountAggregateOutputType | null
    _avg: AiAgentAvgAggregateOutputType | null
    _sum: AiAgentSumAggregateOutputType | null
    _min: AiAgentMinAggregateOutputType | null
    _max: AiAgentMaxAggregateOutputType | null
  }

  type GetAiAgentGroupByPayload<T extends AiAgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiAgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiAgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiAgentGroupByOutputType[P]>
            : GetScalarType<T[P], AiAgentGroupByOutputType[P]>
        }
      >
    >


  export type AiAgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    prompt?: boolean
    model?: boolean
    provider?: boolean
    aiModel?: boolean
    temperature?: boolean
    maxTokens?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    whatsappConversations?: boolean | AiAgent$whatsappConversationsArgs<ExtArgs>
    _count?: boolean | AiAgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    prompt?: boolean
    model?: boolean
    provider?: boolean
    aiModel?: boolean
    temperature?: boolean
    maxTokens?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    prompt?: boolean
    model?: boolean
    provider?: boolean
    aiModel?: boolean
    temperature?: boolean
    maxTokens?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiAgent"]>

  export type AiAgentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    prompt?: boolean
    model?: boolean
    provider?: boolean
    aiModel?: boolean
    temperature?: boolean
    maxTokens?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type AiAgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "prompt" | "model" | "provider" | "aiModel" | "temperature" | "maxTokens" | "isActive" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["aiAgent"]>
  export type AiAgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    whatsappConversations?: boolean | AiAgent$whatsappConversationsArgs<ExtArgs>
    _count?: boolean | AiAgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiAgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type AiAgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $AiAgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiAgent"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      whatsappConversations: Prisma.$WhatsAppConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.AgentType
      prompt: string
      model: string
      provider: $Enums.AIProvider
      aiModel: $Enums.AIModel
      temperature: number
      maxTokens: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      officeId: string
    }, ExtArgs["result"]["aiAgent"]>
    composites: {}
  }

  type AiAgentGetPayload<S extends boolean | null | undefined | AiAgentDefaultArgs> = $Result.GetResult<Prisma.$AiAgentPayload, S>

  type AiAgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiAgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiAgentCountAggregateInputType | true
    }

  export interface AiAgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiAgent'], meta: { name: 'AiAgent' } }
    /**
     * Find zero or one AiAgent that matches the filter.
     * @param {AiAgentFindUniqueArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiAgentFindUniqueArgs>(args: SelectSubset<T, AiAgentFindUniqueArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiAgent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiAgentFindUniqueOrThrowArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiAgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AiAgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAgent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindFirstArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiAgentFindFirstArgs>(args?: SelectSubset<T, AiAgentFindFirstArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiAgent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindFirstOrThrowArgs} args - Arguments to find a AiAgent
     * @example
     * // Get one AiAgent
     * const aiAgent = await prisma.aiAgent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiAgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AiAgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiAgents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiAgents
     * const aiAgents = await prisma.aiAgent.findMany()
     * 
     * // Get first 10 AiAgents
     * const aiAgents = await prisma.aiAgent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiAgentFindManyArgs>(args?: SelectSubset<T, AiAgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiAgent.
     * @param {AiAgentCreateArgs} args - Arguments to create a AiAgent.
     * @example
     * // Create one AiAgent
     * const AiAgent = await prisma.aiAgent.create({
     *   data: {
     *     // ... data to create a AiAgent
     *   }
     * })
     * 
     */
    create<T extends AiAgentCreateArgs>(args: SelectSubset<T, AiAgentCreateArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiAgents.
     * @param {AiAgentCreateManyArgs} args - Arguments to create many AiAgents.
     * @example
     * // Create many AiAgents
     * const aiAgent = await prisma.aiAgent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiAgentCreateManyArgs>(args?: SelectSubset<T, AiAgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiAgents and returns the data saved in the database.
     * @param {AiAgentCreateManyAndReturnArgs} args - Arguments to create many AiAgents.
     * @example
     * // Create many AiAgents
     * const aiAgent = await prisma.aiAgent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiAgents and only return the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiAgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AiAgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiAgent.
     * @param {AiAgentDeleteArgs} args - Arguments to delete one AiAgent.
     * @example
     * // Delete one AiAgent
     * const AiAgent = await prisma.aiAgent.delete({
     *   where: {
     *     // ... filter to delete one AiAgent
     *   }
     * })
     * 
     */
    delete<T extends AiAgentDeleteArgs>(args: SelectSubset<T, AiAgentDeleteArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiAgent.
     * @param {AiAgentUpdateArgs} args - Arguments to update one AiAgent.
     * @example
     * // Update one AiAgent
     * const aiAgent = await prisma.aiAgent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiAgentUpdateArgs>(args: SelectSubset<T, AiAgentUpdateArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiAgents.
     * @param {AiAgentDeleteManyArgs} args - Arguments to filter AiAgents to delete.
     * @example
     * // Delete a few AiAgents
     * const { count } = await prisma.aiAgent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiAgentDeleteManyArgs>(args?: SelectSubset<T, AiAgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiAgents
     * const aiAgent = await prisma.aiAgent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiAgentUpdateManyArgs>(args: SelectSubset<T, AiAgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiAgents and returns the data updated in the database.
     * @param {AiAgentUpdateManyAndReturnArgs} args - Arguments to update many AiAgents.
     * @example
     * // Update many AiAgents
     * const aiAgent = await prisma.aiAgent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiAgents and only return the `id`
     * const aiAgentWithIdOnly = await prisma.aiAgent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiAgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AiAgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiAgent.
     * @param {AiAgentUpsertArgs} args - Arguments to update or create a AiAgent.
     * @example
     * // Update or create a AiAgent
     * const aiAgent = await prisma.aiAgent.upsert({
     *   create: {
     *     // ... data to create a AiAgent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiAgent we want to update
     *   }
     * })
     */
    upsert<T extends AiAgentUpsertArgs>(args: SelectSubset<T, AiAgentUpsertArgs<ExtArgs>>): Prisma__AiAgentClient<$Result.GetResult<Prisma.$AiAgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiAgents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentCountArgs} args - Arguments to filter AiAgents to count.
     * @example
     * // Count the number of AiAgents
     * const count = await prisma.aiAgent.count({
     *   where: {
     *     // ... the filter for the AiAgents we want to count
     *   }
     * })
    **/
    count<T extends AiAgentCountArgs>(
      args?: Subset<T, AiAgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiAgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiAgentAggregateArgs>(args: Subset<T, AiAgentAggregateArgs>): Prisma.PrismaPromise<GetAiAgentAggregateType<T>>

    /**
     * Group by AiAgent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiAgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiAgentGroupByArgs['orderBy'] }
        : { orderBy?: AiAgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiAgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiAgent model
   */
  readonly fields: AiAgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiAgent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiAgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    whatsappConversations<T extends AiAgent$whatsappConversationsArgs<ExtArgs> = {}>(args?: Subset<T, AiAgent$whatsappConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiAgent model
   */
  interface AiAgentFieldRefs {
    readonly id: FieldRef<"AiAgent", 'String'>
    readonly name: FieldRef<"AiAgent", 'String'>
    readonly type: FieldRef<"AiAgent", 'AgentType'>
    readonly prompt: FieldRef<"AiAgent", 'String'>
    readonly model: FieldRef<"AiAgent", 'String'>
    readonly provider: FieldRef<"AiAgent", 'AIProvider'>
    readonly aiModel: FieldRef<"AiAgent", 'AIModel'>
    readonly temperature: FieldRef<"AiAgent", 'Float'>
    readonly maxTokens: FieldRef<"AiAgent", 'Int'>
    readonly isActive: FieldRef<"AiAgent", 'Boolean'>
    readonly createdAt: FieldRef<"AiAgent", 'DateTime'>
    readonly updatedAt: FieldRef<"AiAgent", 'DateTime'>
    readonly officeId: FieldRef<"AiAgent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AiAgent findUnique
   */
  export type AiAgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent findUniqueOrThrow
   */
  export type AiAgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent findFirst
   */
  export type AiAgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAgents.
     */
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent findFirstOrThrow
   */
  export type AiAgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgent to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiAgents.
     */
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent findMany
   */
  export type AiAgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter, which AiAgents to fetch.
     */
    where?: AiAgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiAgents to fetch.
     */
    orderBy?: AiAgentOrderByWithRelationInput | AiAgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiAgents.
     */
    cursor?: AiAgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiAgents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiAgents.
     */
    skip?: number
    distinct?: AiAgentScalarFieldEnum | AiAgentScalarFieldEnum[]
  }

  /**
   * AiAgent create
   */
  export type AiAgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The data needed to create a AiAgent.
     */
    data: XOR<AiAgentCreateInput, AiAgentUncheckedCreateInput>
  }

  /**
   * AiAgent createMany
   */
  export type AiAgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiAgents.
     */
    data: AiAgentCreateManyInput | AiAgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiAgent createManyAndReturn
   */
  export type AiAgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * The data used to create many AiAgents.
     */
    data: AiAgentCreateManyInput | AiAgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiAgent update
   */
  export type AiAgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The data needed to update a AiAgent.
     */
    data: XOR<AiAgentUpdateInput, AiAgentUncheckedUpdateInput>
    /**
     * Choose, which AiAgent to update.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent updateMany
   */
  export type AiAgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiAgents.
     */
    data: XOR<AiAgentUpdateManyMutationInput, AiAgentUncheckedUpdateManyInput>
    /**
     * Filter which AiAgents to update
     */
    where?: AiAgentWhereInput
    /**
     * Limit how many AiAgents to update.
     */
    limit?: number
  }

  /**
   * AiAgent updateManyAndReturn
   */
  export type AiAgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * The data used to update AiAgents.
     */
    data: XOR<AiAgentUpdateManyMutationInput, AiAgentUncheckedUpdateManyInput>
    /**
     * Filter which AiAgents to update
     */
    where?: AiAgentWhereInput
    /**
     * Limit how many AiAgents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiAgent upsert
   */
  export type AiAgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * The filter to search for the AiAgent to update in case it exists.
     */
    where: AiAgentWhereUniqueInput
    /**
     * In case the AiAgent found by the `where` argument doesn't exist, create a new AiAgent with this data.
     */
    create: XOR<AiAgentCreateInput, AiAgentUncheckedCreateInput>
    /**
     * In case the AiAgent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiAgentUpdateInput, AiAgentUncheckedUpdateInput>
  }

  /**
   * AiAgent delete
   */
  export type AiAgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
    /**
     * Filter which AiAgent to delete.
     */
    where: AiAgentWhereUniqueInput
  }

  /**
   * AiAgent deleteMany
   */
  export type AiAgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiAgents to delete
     */
    where?: AiAgentWhereInput
    /**
     * Limit how many AiAgents to delete.
     */
    limit?: number
  }

  /**
   * AiAgent.whatsappConversations
   */
  export type AiAgent$whatsappConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppConversation
     */
    select?: WhatsAppConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppConversation
     */
    omit?: WhatsAppConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppConversationInclude<ExtArgs> | null
    where?: WhatsAppConversationWhereInput
    orderBy?: WhatsAppConversationOrderByWithRelationInput | WhatsAppConversationOrderByWithRelationInput[]
    cursor?: WhatsAppConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppConversationScalarFieldEnum | WhatsAppConversationScalarFieldEnum[]
  }

  /**
   * AiAgent without action
   */
  export type AiAgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiAgent
     */
    select?: AiAgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiAgent
     */
    omit?: AiAgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAgentInclude<ExtArgs> | null
  }


  /**
   * Model AIProviderConfig
   */

  export type AggregateAIProviderConfig = {
    _count: AIProviderConfigCountAggregateOutputType | null
    _min: AIProviderConfigMinAggregateOutputType | null
    _max: AIProviderConfigMaxAggregateOutputType | null
  }

  export type AIProviderConfigMinAggregateOutputType = {
    id: string | null
    provider: $Enums.AIProvider | null
    apiKey: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type AIProviderConfigMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.AIProvider | null
    apiKey: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type AIProviderConfigCountAggregateOutputType = {
    id: number
    provider: number
    apiKey: number
    isActive: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type AIProviderConfigMinAggregateInputType = {
    id?: true
    provider?: true
    apiKey?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type AIProviderConfigMaxAggregateInputType = {
    id?: true
    provider?: true
    apiKey?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type AIProviderConfigCountAggregateInputType = {
    id?: true
    provider?: true
    apiKey?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type AIProviderConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProviderConfig to aggregate.
     */
    where?: AIProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderConfigs to fetch.
     */
    orderBy?: AIProviderConfigOrderByWithRelationInput | AIProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIProviderConfigs
    **/
    _count?: true | AIProviderConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIProviderConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIProviderConfigMaxAggregateInputType
  }

  export type GetAIProviderConfigAggregateType<T extends AIProviderConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAIProviderConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIProviderConfig[P]>
      : GetScalarType<T[P], AggregateAIProviderConfig[P]>
  }




  export type AIProviderConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIProviderConfigWhereInput
    orderBy?: AIProviderConfigOrderByWithAggregationInput | AIProviderConfigOrderByWithAggregationInput[]
    by: AIProviderConfigScalarFieldEnum[] | AIProviderConfigScalarFieldEnum
    having?: AIProviderConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIProviderConfigCountAggregateInputType | true
    _min?: AIProviderConfigMinAggregateInputType
    _max?: AIProviderConfigMaxAggregateInputType
  }

  export type AIProviderConfigGroupByOutputType = {
    id: string
    provider: $Enums.AIProvider
    apiKey: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    officeId: string
    _count: AIProviderConfigCountAggregateOutputType | null
    _min: AIProviderConfigMinAggregateOutputType | null
    _max: AIProviderConfigMaxAggregateOutputType | null
  }

  type GetAIProviderConfigGroupByPayload<T extends AIProviderConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIProviderConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIProviderConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIProviderConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AIProviderConfigGroupByOutputType[P]>
        }
      >
    >


  export type AIProviderConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    apiKey?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIProviderConfig"]>

  export type AIProviderConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    apiKey?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIProviderConfig"]>

  export type AIProviderConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    apiKey?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIProviderConfig"]>

  export type AIProviderConfigSelectScalar = {
    id?: boolean
    provider?: boolean
    apiKey?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type AIProviderConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "apiKey" | "isActive" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["aIProviderConfig"]>
  export type AIProviderConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type AIProviderConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type AIProviderConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $AIProviderConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIProviderConfig"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.AIProvider
      apiKey: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      officeId: string
    }, ExtArgs["result"]["aIProviderConfig"]>
    composites: {}
  }

  type AIProviderConfigGetPayload<S extends boolean | null | undefined | AIProviderConfigDefaultArgs> = $Result.GetResult<Prisma.$AIProviderConfigPayload, S>

  type AIProviderConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIProviderConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIProviderConfigCountAggregateInputType | true
    }

  export interface AIProviderConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIProviderConfig'], meta: { name: 'AIProviderConfig' } }
    /**
     * Find zero or one AIProviderConfig that matches the filter.
     * @param {AIProviderConfigFindUniqueArgs} args - Arguments to find a AIProviderConfig
     * @example
     * // Get one AIProviderConfig
     * const aIProviderConfig = await prisma.aIProviderConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIProviderConfigFindUniqueArgs>(args: SelectSubset<T, AIProviderConfigFindUniqueArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIProviderConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIProviderConfigFindUniqueOrThrowArgs} args - Arguments to find a AIProviderConfig
     * @example
     * // Get one AIProviderConfig
     * const aIProviderConfig = await prisma.aIProviderConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIProviderConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AIProviderConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIProviderConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderConfigFindFirstArgs} args - Arguments to find a AIProviderConfig
     * @example
     * // Get one AIProviderConfig
     * const aIProviderConfig = await prisma.aIProviderConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIProviderConfigFindFirstArgs>(args?: SelectSubset<T, AIProviderConfigFindFirstArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIProviderConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderConfigFindFirstOrThrowArgs} args - Arguments to find a AIProviderConfig
     * @example
     * // Get one AIProviderConfig
     * const aIProviderConfig = await prisma.aIProviderConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIProviderConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AIProviderConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIProviderConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIProviderConfigs
     * const aIProviderConfigs = await prisma.aIProviderConfig.findMany()
     * 
     * // Get first 10 AIProviderConfigs
     * const aIProviderConfigs = await prisma.aIProviderConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIProviderConfigWithIdOnly = await prisma.aIProviderConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIProviderConfigFindManyArgs>(args?: SelectSubset<T, AIProviderConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIProviderConfig.
     * @param {AIProviderConfigCreateArgs} args - Arguments to create a AIProviderConfig.
     * @example
     * // Create one AIProviderConfig
     * const AIProviderConfig = await prisma.aIProviderConfig.create({
     *   data: {
     *     // ... data to create a AIProviderConfig
     *   }
     * })
     * 
     */
    create<T extends AIProviderConfigCreateArgs>(args: SelectSubset<T, AIProviderConfigCreateArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIProviderConfigs.
     * @param {AIProviderConfigCreateManyArgs} args - Arguments to create many AIProviderConfigs.
     * @example
     * // Create many AIProviderConfigs
     * const aIProviderConfig = await prisma.aIProviderConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIProviderConfigCreateManyArgs>(args?: SelectSubset<T, AIProviderConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIProviderConfigs and returns the data saved in the database.
     * @param {AIProviderConfigCreateManyAndReturnArgs} args - Arguments to create many AIProviderConfigs.
     * @example
     * // Create many AIProviderConfigs
     * const aIProviderConfig = await prisma.aIProviderConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIProviderConfigs and only return the `id`
     * const aIProviderConfigWithIdOnly = await prisma.aIProviderConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIProviderConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AIProviderConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIProviderConfig.
     * @param {AIProviderConfigDeleteArgs} args - Arguments to delete one AIProviderConfig.
     * @example
     * // Delete one AIProviderConfig
     * const AIProviderConfig = await prisma.aIProviderConfig.delete({
     *   where: {
     *     // ... filter to delete one AIProviderConfig
     *   }
     * })
     * 
     */
    delete<T extends AIProviderConfigDeleteArgs>(args: SelectSubset<T, AIProviderConfigDeleteArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIProviderConfig.
     * @param {AIProviderConfigUpdateArgs} args - Arguments to update one AIProviderConfig.
     * @example
     * // Update one AIProviderConfig
     * const aIProviderConfig = await prisma.aIProviderConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIProviderConfigUpdateArgs>(args: SelectSubset<T, AIProviderConfigUpdateArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIProviderConfigs.
     * @param {AIProviderConfigDeleteManyArgs} args - Arguments to filter AIProviderConfigs to delete.
     * @example
     * // Delete a few AIProviderConfigs
     * const { count } = await prisma.aIProviderConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIProviderConfigDeleteManyArgs>(args?: SelectSubset<T, AIProviderConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIProviderConfigs
     * const aIProviderConfig = await prisma.aIProviderConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIProviderConfigUpdateManyArgs>(args: SelectSubset<T, AIProviderConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIProviderConfigs and returns the data updated in the database.
     * @param {AIProviderConfigUpdateManyAndReturnArgs} args - Arguments to update many AIProviderConfigs.
     * @example
     * // Update many AIProviderConfigs
     * const aIProviderConfig = await prisma.aIProviderConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIProviderConfigs and only return the `id`
     * const aIProviderConfigWithIdOnly = await prisma.aIProviderConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIProviderConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AIProviderConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIProviderConfig.
     * @param {AIProviderConfigUpsertArgs} args - Arguments to update or create a AIProviderConfig.
     * @example
     * // Update or create a AIProviderConfig
     * const aIProviderConfig = await prisma.aIProviderConfig.upsert({
     *   create: {
     *     // ... data to create a AIProviderConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIProviderConfig we want to update
     *   }
     * })
     */
    upsert<T extends AIProviderConfigUpsertArgs>(args: SelectSubset<T, AIProviderConfigUpsertArgs<ExtArgs>>): Prisma__AIProviderConfigClient<$Result.GetResult<Prisma.$AIProviderConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderConfigCountArgs} args - Arguments to filter AIProviderConfigs to count.
     * @example
     * // Count the number of AIProviderConfigs
     * const count = await prisma.aIProviderConfig.count({
     *   where: {
     *     // ... the filter for the AIProviderConfigs we want to count
     *   }
     * })
    **/
    count<T extends AIProviderConfigCountArgs>(
      args?: Subset<T, AIProviderConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIProviderConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIProviderConfigAggregateArgs>(args: Subset<T, AIProviderConfigAggregateArgs>): Prisma.PrismaPromise<GetAIProviderConfigAggregateType<T>>

    /**
     * Group by AIProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIProviderConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIProviderConfigGroupByArgs['orderBy'] }
        : { orderBy?: AIProviderConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIProviderConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIProviderConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIProviderConfig model
   */
  readonly fields: AIProviderConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIProviderConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIProviderConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIProviderConfig model
   */
  interface AIProviderConfigFieldRefs {
    readonly id: FieldRef<"AIProviderConfig", 'String'>
    readonly provider: FieldRef<"AIProviderConfig", 'AIProvider'>
    readonly apiKey: FieldRef<"AIProviderConfig", 'String'>
    readonly isActive: FieldRef<"AIProviderConfig", 'Boolean'>
    readonly createdAt: FieldRef<"AIProviderConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"AIProviderConfig", 'DateTime'>
    readonly officeId: FieldRef<"AIProviderConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AIProviderConfig findUnique
   */
  export type AIProviderConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIProviderConfig to fetch.
     */
    where: AIProviderConfigWhereUniqueInput
  }

  /**
   * AIProviderConfig findUniqueOrThrow
   */
  export type AIProviderConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIProviderConfig to fetch.
     */
    where: AIProviderConfigWhereUniqueInput
  }

  /**
   * AIProviderConfig findFirst
   */
  export type AIProviderConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIProviderConfig to fetch.
     */
    where?: AIProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderConfigs to fetch.
     */
    orderBy?: AIProviderConfigOrderByWithRelationInput | AIProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProviderConfigs.
     */
    cursor?: AIProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProviderConfigs.
     */
    distinct?: AIProviderConfigScalarFieldEnum | AIProviderConfigScalarFieldEnum[]
  }

  /**
   * AIProviderConfig findFirstOrThrow
   */
  export type AIProviderConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIProviderConfig to fetch.
     */
    where?: AIProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderConfigs to fetch.
     */
    orderBy?: AIProviderConfigOrderByWithRelationInput | AIProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProviderConfigs.
     */
    cursor?: AIProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProviderConfigs.
     */
    distinct?: AIProviderConfigScalarFieldEnum | AIProviderConfigScalarFieldEnum[]
  }

  /**
   * AIProviderConfig findMany
   */
  export type AIProviderConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIProviderConfigs to fetch.
     */
    where?: AIProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviderConfigs to fetch.
     */
    orderBy?: AIProviderConfigOrderByWithRelationInput | AIProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIProviderConfigs.
     */
    cursor?: AIProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviderConfigs.
     */
    skip?: number
    distinct?: AIProviderConfigScalarFieldEnum | AIProviderConfigScalarFieldEnum[]
  }

  /**
   * AIProviderConfig create
   */
  export type AIProviderConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a AIProviderConfig.
     */
    data: XOR<AIProviderConfigCreateInput, AIProviderConfigUncheckedCreateInput>
  }

  /**
   * AIProviderConfig createMany
   */
  export type AIProviderConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIProviderConfigs.
     */
    data: AIProviderConfigCreateManyInput | AIProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIProviderConfig createManyAndReturn
   */
  export type AIProviderConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AIProviderConfigs.
     */
    data: AIProviderConfigCreateManyInput | AIProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIProviderConfig update
   */
  export type AIProviderConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a AIProviderConfig.
     */
    data: XOR<AIProviderConfigUpdateInput, AIProviderConfigUncheckedUpdateInput>
    /**
     * Choose, which AIProviderConfig to update.
     */
    where: AIProviderConfigWhereUniqueInput
  }

  /**
   * AIProviderConfig updateMany
   */
  export type AIProviderConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIProviderConfigs.
     */
    data: XOR<AIProviderConfigUpdateManyMutationInput, AIProviderConfigUncheckedUpdateManyInput>
    /**
     * Filter which AIProviderConfigs to update
     */
    where?: AIProviderConfigWhereInput
    /**
     * Limit how many AIProviderConfigs to update.
     */
    limit?: number
  }

  /**
   * AIProviderConfig updateManyAndReturn
   */
  export type AIProviderConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * The data used to update AIProviderConfigs.
     */
    data: XOR<AIProviderConfigUpdateManyMutationInput, AIProviderConfigUncheckedUpdateManyInput>
    /**
     * Filter which AIProviderConfigs to update
     */
    where?: AIProviderConfigWhereInput
    /**
     * Limit how many AIProviderConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIProviderConfig upsert
   */
  export type AIProviderConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the AIProviderConfig to update in case it exists.
     */
    where: AIProviderConfigWhereUniqueInput
    /**
     * In case the AIProviderConfig found by the `where` argument doesn't exist, create a new AIProviderConfig with this data.
     */
    create: XOR<AIProviderConfigCreateInput, AIProviderConfigUncheckedCreateInput>
    /**
     * In case the AIProviderConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIProviderConfigUpdateInput, AIProviderConfigUncheckedUpdateInput>
  }

  /**
   * AIProviderConfig delete
   */
  export type AIProviderConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
    /**
     * Filter which AIProviderConfig to delete.
     */
    where: AIProviderConfigWhereUniqueInput
  }

  /**
   * AIProviderConfig deleteMany
   */
  export type AIProviderConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProviderConfigs to delete
     */
    where?: AIProviderConfigWhereInput
    /**
     * Limit how many AIProviderConfigs to delete.
     */
    limit?: number
  }

  /**
   * AIProviderConfig without action
   */
  export type AIProviderConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProviderConfig
     */
    select?: AIProviderConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProviderConfig
     */
    omit?: AIProviderConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIProviderConfigInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    officeId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    officeId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    originalName: number
    mimeType: number
    size: number
    url: number
    description: number
    createdAt: number
    updatedAt: number
    clientId: number
    officeId: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    officeId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    officeId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    officeId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    clientId: string
    officeId: string
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    officeId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "originalName" | "mimeType" | "size" | "url" | "description" | "createdAt" | "updatedAt" | "clientId" | "officeId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      office: Prisma.$OfficePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      originalName: string
      mimeType: string
      size: number
      url: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      clientId: string
      officeId: string
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly originalName: FieldRef<"Document", 'String'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly url: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly clientId: FieldRef<"Document", 'String'>
    readonly officeId: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Tool
   */

  export type AggregateTool = {
    _count: ToolCountAggregateOutputType | null
    _min: ToolMinAggregateOutputType | null
    _max: ToolMaxAggregateOutputType | null
  }

  export type ToolMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    webhookUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
    createdById: string | null
  }

  export type ToolMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    webhookUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
    createdById: string | null
  }

  export type ToolCountAggregateOutputType = {
    id: number
    name: number
    description: number
    webhookUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    officeId: number
    createdById: number
    _all: number
  }


  export type ToolMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    webhookUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    createdById?: true
  }

  export type ToolMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    webhookUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    createdById?: true
  }

  export type ToolCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    webhookUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    createdById?: true
    _all?: true
  }

  export type ToolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tool to aggregate.
     */
    where?: ToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tools to fetch.
     */
    orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tools
    **/
    _count?: true | ToolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToolMaxAggregateInputType
  }

  export type GetToolAggregateType<T extends ToolAggregateArgs> = {
        [P in keyof T & keyof AggregateTool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTool[P]>
      : GetScalarType<T[P], AggregateTool[P]>
  }




  export type ToolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToolWhereInput
    orderBy?: ToolOrderByWithAggregationInput | ToolOrderByWithAggregationInput[]
    by: ToolScalarFieldEnum[] | ToolScalarFieldEnum
    having?: ToolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToolCountAggregateInputType | true
    _min?: ToolMinAggregateInputType
    _max?: ToolMaxAggregateInputType
  }

  export type ToolGroupByOutputType = {
    id: string
    name: string
    description: string
    webhookUrl: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    officeId: string
    createdById: string
    _count: ToolCountAggregateOutputType | null
    _min: ToolMinAggregateOutputType | null
    _max: ToolMaxAggregateOutputType | null
  }

  type GetToolGroupByPayload<T extends ToolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ToolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ToolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ToolGroupByOutputType[P]>
            : GetScalarType<T[P], ToolGroupByOutputType[P]>
        }
      >
    >


  export type ToolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    createdById?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | Tool$executionsArgs<ExtArgs>
    _count?: boolean | ToolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tool"]>

  export type ToolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    createdById?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tool"]>

  export type ToolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    createdById?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tool"]>

  export type ToolSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    webhookUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    createdById?: boolean
  }

  export type ToolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "webhookUrl" | "isActive" | "createdAt" | "updatedAt" | "officeId" | "createdById", ExtArgs["result"]["tool"]>
  export type ToolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    executions?: boolean | Tool$executionsArgs<ExtArgs>
    _count?: boolean | ToolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ToolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ToolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ToolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tool"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      executions: Prisma.$ToolExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      webhookUrl: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      officeId: string
      createdById: string
    }, ExtArgs["result"]["tool"]>
    composites: {}
  }

  type ToolGetPayload<S extends boolean | null | undefined | ToolDefaultArgs> = $Result.GetResult<Prisma.$ToolPayload, S>

  type ToolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ToolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ToolCountAggregateInputType | true
    }

  export interface ToolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tool'], meta: { name: 'Tool' } }
    /**
     * Find zero or one Tool that matches the filter.
     * @param {ToolFindUniqueArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ToolFindUniqueArgs>(args: SelectSubset<T, ToolFindUniqueArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ToolFindUniqueOrThrowArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ToolFindUniqueOrThrowArgs>(args: SelectSubset<T, ToolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolFindFirstArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ToolFindFirstArgs>(args?: SelectSubset<T, ToolFindFirstArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolFindFirstOrThrowArgs} args - Arguments to find a Tool
     * @example
     * // Get one Tool
     * const tool = await prisma.tool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ToolFindFirstOrThrowArgs>(args?: SelectSubset<T, ToolFindFirstOrThrowArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tools
     * const tools = await prisma.tool.findMany()
     * 
     * // Get first 10 Tools
     * const tools = await prisma.tool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const toolWithIdOnly = await prisma.tool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ToolFindManyArgs>(args?: SelectSubset<T, ToolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tool.
     * @param {ToolCreateArgs} args - Arguments to create a Tool.
     * @example
     * // Create one Tool
     * const Tool = await prisma.tool.create({
     *   data: {
     *     // ... data to create a Tool
     *   }
     * })
     * 
     */
    create<T extends ToolCreateArgs>(args: SelectSubset<T, ToolCreateArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tools.
     * @param {ToolCreateManyArgs} args - Arguments to create many Tools.
     * @example
     * // Create many Tools
     * const tool = await prisma.tool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ToolCreateManyArgs>(args?: SelectSubset<T, ToolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tools and returns the data saved in the database.
     * @param {ToolCreateManyAndReturnArgs} args - Arguments to create many Tools.
     * @example
     * // Create many Tools
     * const tool = await prisma.tool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tools and only return the `id`
     * const toolWithIdOnly = await prisma.tool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ToolCreateManyAndReturnArgs>(args?: SelectSubset<T, ToolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tool.
     * @param {ToolDeleteArgs} args - Arguments to delete one Tool.
     * @example
     * // Delete one Tool
     * const Tool = await prisma.tool.delete({
     *   where: {
     *     // ... filter to delete one Tool
     *   }
     * })
     * 
     */
    delete<T extends ToolDeleteArgs>(args: SelectSubset<T, ToolDeleteArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tool.
     * @param {ToolUpdateArgs} args - Arguments to update one Tool.
     * @example
     * // Update one Tool
     * const tool = await prisma.tool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ToolUpdateArgs>(args: SelectSubset<T, ToolUpdateArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tools.
     * @param {ToolDeleteManyArgs} args - Arguments to filter Tools to delete.
     * @example
     * // Delete a few Tools
     * const { count } = await prisma.tool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ToolDeleteManyArgs>(args?: SelectSubset<T, ToolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tools
     * const tool = await prisma.tool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ToolUpdateManyArgs>(args: SelectSubset<T, ToolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tools and returns the data updated in the database.
     * @param {ToolUpdateManyAndReturnArgs} args - Arguments to update many Tools.
     * @example
     * // Update many Tools
     * const tool = await prisma.tool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tools and only return the `id`
     * const toolWithIdOnly = await prisma.tool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ToolUpdateManyAndReturnArgs>(args: SelectSubset<T, ToolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tool.
     * @param {ToolUpsertArgs} args - Arguments to update or create a Tool.
     * @example
     * // Update or create a Tool
     * const tool = await prisma.tool.upsert({
     *   create: {
     *     // ... data to create a Tool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tool we want to update
     *   }
     * })
     */
    upsert<T extends ToolUpsertArgs>(args: SelectSubset<T, ToolUpsertArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolCountArgs} args - Arguments to filter Tools to count.
     * @example
     * // Count the number of Tools
     * const count = await prisma.tool.count({
     *   where: {
     *     // ... the filter for the Tools we want to count
     *   }
     * })
    **/
    count<T extends ToolCountArgs>(
      args?: Subset<T, ToolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToolAggregateArgs>(args: Subset<T, ToolAggregateArgs>): Prisma.PrismaPromise<GetToolAggregateType<T>>

    /**
     * Group by Tool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToolGroupByArgs['orderBy'] }
        : { orderBy?: ToolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tool model
   */
  readonly fields: ToolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ToolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executions<T extends Tool$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Tool$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tool model
   */
  interface ToolFieldRefs {
    readonly id: FieldRef<"Tool", 'String'>
    readonly name: FieldRef<"Tool", 'String'>
    readonly description: FieldRef<"Tool", 'String'>
    readonly webhookUrl: FieldRef<"Tool", 'String'>
    readonly isActive: FieldRef<"Tool", 'Boolean'>
    readonly createdAt: FieldRef<"Tool", 'DateTime'>
    readonly updatedAt: FieldRef<"Tool", 'DateTime'>
    readonly officeId: FieldRef<"Tool", 'String'>
    readonly createdById: FieldRef<"Tool", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tool findUnique
   */
  export type ToolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * Filter, which Tool to fetch.
     */
    where: ToolWhereUniqueInput
  }

  /**
   * Tool findUniqueOrThrow
   */
  export type ToolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * Filter, which Tool to fetch.
     */
    where: ToolWhereUniqueInput
  }

  /**
   * Tool findFirst
   */
  export type ToolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * Filter, which Tool to fetch.
     */
    where?: ToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tools to fetch.
     */
    orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tools.
     */
    cursor?: ToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tools.
     */
    distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[]
  }

  /**
   * Tool findFirstOrThrow
   */
  export type ToolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * Filter, which Tool to fetch.
     */
    where?: ToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tools to fetch.
     */
    orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tools.
     */
    cursor?: ToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tools.
     */
    distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[]
  }

  /**
   * Tool findMany
   */
  export type ToolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * Filter, which Tools to fetch.
     */
    where?: ToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tools to fetch.
     */
    orderBy?: ToolOrderByWithRelationInput | ToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tools.
     */
    cursor?: ToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tools.
     */
    skip?: number
    distinct?: ToolScalarFieldEnum | ToolScalarFieldEnum[]
  }

  /**
   * Tool create
   */
  export type ToolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * The data needed to create a Tool.
     */
    data: XOR<ToolCreateInput, ToolUncheckedCreateInput>
  }

  /**
   * Tool createMany
   */
  export type ToolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tools.
     */
    data: ToolCreateManyInput | ToolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tool createManyAndReturn
   */
  export type ToolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * The data used to create many Tools.
     */
    data: ToolCreateManyInput | ToolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tool update
   */
  export type ToolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * The data needed to update a Tool.
     */
    data: XOR<ToolUpdateInput, ToolUncheckedUpdateInput>
    /**
     * Choose, which Tool to update.
     */
    where: ToolWhereUniqueInput
  }

  /**
   * Tool updateMany
   */
  export type ToolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tools.
     */
    data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyInput>
    /**
     * Filter which Tools to update
     */
    where?: ToolWhereInput
    /**
     * Limit how many Tools to update.
     */
    limit?: number
  }

  /**
   * Tool updateManyAndReturn
   */
  export type ToolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * The data used to update Tools.
     */
    data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyInput>
    /**
     * Filter which Tools to update
     */
    where?: ToolWhereInput
    /**
     * Limit how many Tools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tool upsert
   */
  export type ToolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * The filter to search for the Tool to update in case it exists.
     */
    where: ToolWhereUniqueInput
    /**
     * In case the Tool found by the `where` argument doesn't exist, create a new Tool with this data.
     */
    create: XOR<ToolCreateInput, ToolUncheckedCreateInput>
    /**
     * In case the Tool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ToolUpdateInput, ToolUncheckedUpdateInput>
  }

  /**
   * Tool delete
   */
  export type ToolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
    /**
     * Filter which Tool to delete.
     */
    where: ToolWhereUniqueInput
  }

  /**
   * Tool deleteMany
   */
  export type ToolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tools to delete
     */
    where?: ToolWhereInput
    /**
     * Limit how many Tools to delete.
     */
    limit?: number
  }

  /**
   * Tool.executions
   */
  export type Tool$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    where?: ToolExecutionWhereInput
    orderBy?: ToolExecutionOrderByWithRelationInput | ToolExecutionOrderByWithRelationInput[]
    cursor?: ToolExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ToolExecutionScalarFieldEnum | ToolExecutionScalarFieldEnum[]
  }

  /**
   * Tool without action
   */
  export type ToolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tool
     */
    select?: ToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tool
     */
    omit?: ToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolInclude<ExtArgs> | null
  }


  /**
   * Model ToolExecution
   */

  export type AggregateToolExecution = {
    _count: ToolExecutionCountAggregateOutputType | null
    _min: ToolExecutionMinAggregateOutputType | null
    _max: ToolExecutionMaxAggregateOutputType | null
  }

  export type ToolExecutionMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    description: string | null
    status: $Enums.ToolExecutionStatus | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
    conversationId: string | null
    agentId: string | null
    toolId: string | null
  }

  export type ToolExecutionMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    description: string | null
    status: $Enums.ToolExecutionStatus | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
    conversationId: string | null
    agentId: string | null
    toolId: string | null
  }

  export type ToolExecutionCountAggregateOutputType = {
    id: number
    requestId: number
    description: number
    status: number
    requestData: number
    responseData: number
    errorMessage: number
    startedAt: number
    completedAt: number
    conversationId: number
    agentId: number
    toolId: number
    _all: number
  }


  export type ToolExecutionMinAggregateInputType = {
    id?: true
    requestId?: true
    description?: true
    status?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    conversationId?: true
    agentId?: true
    toolId?: true
  }

  export type ToolExecutionMaxAggregateInputType = {
    id?: true
    requestId?: true
    description?: true
    status?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    conversationId?: true
    agentId?: true
    toolId?: true
  }

  export type ToolExecutionCountAggregateInputType = {
    id?: true
    requestId?: true
    description?: true
    status?: true
    requestData?: true
    responseData?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    conversationId?: true
    agentId?: true
    toolId?: true
    _all?: true
  }

  export type ToolExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToolExecution to aggregate.
     */
    where?: ToolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutions to fetch.
     */
    orderBy?: ToolExecutionOrderByWithRelationInput | ToolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ToolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ToolExecutions
    **/
    _count?: true | ToolExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ToolExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ToolExecutionMaxAggregateInputType
  }

  export type GetToolExecutionAggregateType<T extends ToolExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateToolExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToolExecution[P]>
      : GetScalarType<T[P], AggregateToolExecution[P]>
  }




  export type ToolExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ToolExecutionWhereInput
    orderBy?: ToolExecutionOrderByWithAggregationInput | ToolExecutionOrderByWithAggregationInput[]
    by: ToolExecutionScalarFieldEnum[] | ToolExecutionScalarFieldEnum
    having?: ToolExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ToolExecutionCountAggregateInputType | true
    _min?: ToolExecutionMinAggregateInputType
    _max?: ToolExecutionMaxAggregateInputType
  }

  export type ToolExecutionGroupByOutputType = {
    id: string
    requestId: string
    description: string
    status: $Enums.ToolExecutionStatus
    requestData: JsonValue | null
    responseData: JsonValue | null
    errorMessage: string | null
    startedAt: Date
    completedAt: Date | null
    conversationId: string | null
    agentId: string | null
    toolId: string
    _count: ToolExecutionCountAggregateOutputType | null
    _min: ToolExecutionMinAggregateOutputType | null
    _max: ToolExecutionMaxAggregateOutputType | null
  }

  type GetToolExecutionGroupByPayload<T extends ToolExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ToolExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ToolExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ToolExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], ToolExecutionGroupByOutputType[P]>
        }
      >
    >


  export type ToolExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    description?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    conversationId?: boolean
    agentId?: boolean
    toolId?: boolean
    tool?: boolean | ToolDefaultArgs<ExtArgs>
    whatsappMessages?: boolean | ToolExecution$whatsappMessagesArgs<ExtArgs>
    _count?: boolean | ToolExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toolExecution"]>

  export type ToolExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    description?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    conversationId?: boolean
    agentId?: boolean
    toolId?: boolean
    tool?: boolean | ToolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toolExecution"]>

  export type ToolExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    description?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    conversationId?: boolean
    agentId?: boolean
    toolId?: boolean
    tool?: boolean | ToolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toolExecution"]>

  export type ToolExecutionSelectScalar = {
    id?: boolean
    requestId?: boolean
    description?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    conversationId?: boolean
    agentId?: boolean
    toolId?: boolean
  }

  export type ToolExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestId" | "description" | "status" | "requestData" | "responseData" | "errorMessage" | "startedAt" | "completedAt" | "conversationId" | "agentId" | "toolId", ExtArgs["result"]["toolExecution"]>
  export type ToolExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tool?: boolean | ToolDefaultArgs<ExtArgs>
    whatsappMessages?: boolean | ToolExecution$whatsappMessagesArgs<ExtArgs>
    _count?: boolean | ToolExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ToolExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tool?: boolean | ToolDefaultArgs<ExtArgs>
  }
  export type ToolExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tool?: boolean | ToolDefaultArgs<ExtArgs>
  }

  export type $ToolExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ToolExecution"
    objects: {
      tool: Prisma.$ToolPayload<ExtArgs>
      whatsappMessages: Prisma.$WhatsAppMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      description: string
      status: $Enums.ToolExecutionStatus
      requestData: Prisma.JsonValue | null
      responseData: Prisma.JsonValue | null
      errorMessage: string | null
      startedAt: Date
      completedAt: Date | null
      conversationId: string | null
      agentId: string | null
      toolId: string
    }, ExtArgs["result"]["toolExecution"]>
    composites: {}
  }

  type ToolExecutionGetPayload<S extends boolean | null | undefined | ToolExecutionDefaultArgs> = $Result.GetResult<Prisma.$ToolExecutionPayload, S>

  type ToolExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ToolExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ToolExecutionCountAggregateInputType | true
    }

  export interface ToolExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ToolExecution'], meta: { name: 'ToolExecution' } }
    /**
     * Find zero or one ToolExecution that matches the filter.
     * @param {ToolExecutionFindUniqueArgs} args - Arguments to find a ToolExecution
     * @example
     * // Get one ToolExecution
     * const toolExecution = await prisma.toolExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ToolExecutionFindUniqueArgs>(args: SelectSubset<T, ToolExecutionFindUniqueArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ToolExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ToolExecutionFindUniqueOrThrowArgs} args - Arguments to find a ToolExecution
     * @example
     * // Get one ToolExecution
     * const toolExecution = await prisma.toolExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ToolExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ToolExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ToolExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionFindFirstArgs} args - Arguments to find a ToolExecution
     * @example
     * // Get one ToolExecution
     * const toolExecution = await prisma.toolExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ToolExecutionFindFirstArgs>(args?: SelectSubset<T, ToolExecutionFindFirstArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ToolExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionFindFirstOrThrowArgs} args - Arguments to find a ToolExecution
     * @example
     * // Get one ToolExecution
     * const toolExecution = await prisma.toolExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ToolExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ToolExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ToolExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ToolExecutions
     * const toolExecutions = await prisma.toolExecution.findMany()
     * 
     * // Get first 10 ToolExecutions
     * const toolExecutions = await prisma.toolExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const toolExecutionWithIdOnly = await prisma.toolExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ToolExecutionFindManyArgs>(args?: SelectSubset<T, ToolExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ToolExecution.
     * @param {ToolExecutionCreateArgs} args - Arguments to create a ToolExecution.
     * @example
     * // Create one ToolExecution
     * const ToolExecution = await prisma.toolExecution.create({
     *   data: {
     *     // ... data to create a ToolExecution
     *   }
     * })
     * 
     */
    create<T extends ToolExecutionCreateArgs>(args: SelectSubset<T, ToolExecutionCreateArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ToolExecutions.
     * @param {ToolExecutionCreateManyArgs} args - Arguments to create many ToolExecutions.
     * @example
     * // Create many ToolExecutions
     * const toolExecution = await prisma.toolExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ToolExecutionCreateManyArgs>(args?: SelectSubset<T, ToolExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ToolExecutions and returns the data saved in the database.
     * @param {ToolExecutionCreateManyAndReturnArgs} args - Arguments to create many ToolExecutions.
     * @example
     * // Create many ToolExecutions
     * const toolExecution = await prisma.toolExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ToolExecutions and only return the `id`
     * const toolExecutionWithIdOnly = await prisma.toolExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ToolExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ToolExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ToolExecution.
     * @param {ToolExecutionDeleteArgs} args - Arguments to delete one ToolExecution.
     * @example
     * // Delete one ToolExecution
     * const ToolExecution = await prisma.toolExecution.delete({
     *   where: {
     *     // ... filter to delete one ToolExecution
     *   }
     * })
     * 
     */
    delete<T extends ToolExecutionDeleteArgs>(args: SelectSubset<T, ToolExecutionDeleteArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ToolExecution.
     * @param {ToolExecutionUpdateArgs} args - Arguments to update one ToolExecution.
     * @example
     * // Update one ToolExecution
     * const toolExecution = await prisma.toolExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ToolExecutionUpdateArgs>(args: SelectSubset<T, ToolExecutionUpdateArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ToolExecutions.
     * @param {ToolExecutionDeleteManyArgs} args - Arguments to filter ToolExecutions to delete.
     * @example
     * // Delete a few ToolExecutions
     * const { count } = await prisma.toolExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ToolExecutionDeleteManyArgs>(args?: SelectSubset<T, ToolExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ToolExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ToolExecutions
     * const toolExecution = await prisma.toolExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ToolExecutionUpdateManyArgs>(args: SelectSubset<T, ToolExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ToolExecutions and returns the data updated in the database.
     * @param {ToolExecutionUpdateManyAndReturnArgs} args - Arguments to update many ToolExecutions.
     * @example
     * // Update many ToolExecutions
     * const toolExecution = await prisma.toolExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ToolExecutions and only return the `id`
     * const toolExecutionWithIdOnly = await prisma.toolExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ToolExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, ToolExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ToolExecution.
     * @param {ToolExecutionUpsertArgs} args - Arguments to update or create a ToolExecution.
     * @example
     * // Update or create a ToolExecution
     * const toolExecution = await prisma.toolExecution.upsert({
     *   create: {
     *     // ... data to create a ToolExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ToolExecution we want to update
     *   }
     * })
     */
    upsert<T extends ToolExecutionUpsertArgs>(args: SelectSubset<T, ToolExecutionUpsertArgs<ExtArgs>>): Prisma__ToolExecutionClient<$Result.GetResult<Prisma.$ToolExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ToolExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionCountArgs} args - Arguments to filter ToolExecutions to count.
     * @example
     * // Count the number of ToolExecutions
     * const count = await prisma.toolExecution.count({
     *   where: {
     *     // ... the filter for the ToolExecutions we want to count
     *   }
     * })
    **/
    count<T extends ToolExecutionCountArgs>(
      args?: Subset<T, ToolExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ToolExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ToolExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ToolExecutionAggregateArgs>(args: Subset<T, ToolExecutionAggregateArgs>): Prisma.PrismaPromise<GetToolExecutionAggregateType<T>>

    /**
     * Group by ToolExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ToolExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ToolExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ToolExecutionGroupByArgs['orderBy'] }
        : { orderBy?: ToolExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ToolExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToolExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ToolExecution model
   */
  readonly fields: ToolExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ToolExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ToolExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tool<T extends ToolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ToolDefaultArgs<ExtArgs>>): Prisma__ToolClient<$Result.GetResult<Prisma.$ToolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    whatsappMessages<T extends ToolExecution$whatsappMessagesArgs<ExtArgs> = {}>(args?: Subset<T, ToolExecution$whatsappMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ToolExecution model
   */
  interface ToolExecutionFieldRefs {
    readonly id: FieldRef<"ToolExecution", 'String'>
    readonly requestId: FieldRef<"ToolExecution", 'String'>
    readonly description: FieldRef<"ToolExecution", 'String'>
    readonly status: FieldRef<"ToolExecution", 'ToolExecutionStatus'>
    readonly requestData: FieldRef<"ToolExecution", 'Json'>
    readonly responseData: FieldRef<"ToolExecution", 'Json'>
    readonly errorMessage: FieldRef<"ToolExecution", 'String'>
    readonly startedAt: FieldRef<"ToolExecution", 'DateTime'>
    readonly completedAt: FieldRef<"ToolExecution", 'DateTime'>
    readonly conversationId: FieldRef<"ToolExecution", 'String'>
    readonly agentId: FieldRef<"ToolExecution", 'String'>
    readonly toolId: FieldRef<"ToolExecution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ToolExecution findUnique
   */
  export type ToolExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecution to fetch.
     */
    where: ToolExecutionWhereUniqueInput
  }

  /**
   * ToolExecution findUniqueOrThrow
   */
  export type ToolExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecution to fetch.
     */
    where: ToolExecutionWhereUniqueInput
  }

  /**
   * ToolExecution findFirst
   */
  export type ToolExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecution to fetch.
     */
    where?: ToolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutions to fetch.
     */
    orderBy?: ToolExecutionOrderByWithRelationInput | ToolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToolExecutions.
     */
    cursor?: ToolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToolExecutions.
     */
    distinct?: ToolExecutionScalarFieldEnum | ToolExecutionScalarFieldEnum[]
  }

  /**
   * ToolExecution findFirstOrThrow
   */
  export type ToolExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecution to fetch.
     */
    where?: ToolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutions to fetch.
     */
    orderBy?: ToolExecutionOrderByWithRelationInput | ToolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ToolExecutions.
     */
    cursor?: ToolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ToolExecutions.
     */
    distinct?: ToolExecutionScalarFieldEnum | ToolExecutionScalarFieldEnum[]
  }

  /**
   * ToolExecution findMany
   */
  export type ToolExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ToolExecutions to fetch.
     */
    where?: ToolExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ToolExecutions to fetch.
     */
    orderBy?: ToolExecutionOrderByWithRelationInput | ToolExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ToolExecutions.
     */
    cursor?: ToolExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ToolExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ToolExecutions.
     */
    skip?: number
    distinct?: ToolExecutionScalarFieldEnum | ToolExecutionScalarFieldEnum[]
  }

  /**
   * ToolExecution create
   */
  export type ToolExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a ToolExecution.
     */
    data: XOR<ToolExecutionCreateInput, ToolExecutionUncheckedCreateInput>
  }

  /**
   * ToolExecution createMany
   */
  export type ToolExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ToolExecutions.
     */
    data: ToolExecutionCreateManyInput | ToolExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ToolExecution createManyAndReturn
   */
  export type ToolExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many ToolExecutions.
     */
    data: ToolExecutionCreateManyInput | ToolExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ToolExecution update
   */
  export type ToolExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a ToolExecution.
     */
    data: XOR<ToolExecutionUpdateInput, ToolExecutionUncheckedUpdateInput>
    /**
     * Choose, which ToolExecution to update.
     */
    where: ToolExecutionWhereUniqueInput
  }

  /**
   * ToolExecution updateMany
   */
  export type ToolExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ToolExecutions.
     */
    data: XOR<ToolExecutionUpdateManyMutationInput, ToolExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ToolExecutions to update
     */
    where?: ToolExecutionWhereInput
    /**
     * Limit how many ToolExecutions to update.
     */
    limit?: number
  }

  /**
   * ToolExecution updateManyAndReturn
   */
  export type ToolExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * The data used to update ToolExecutions.
     */
    data: XOR<ToolExecutionUpdateManyMutationInput, ToolExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ToolExecutions to update
     */
    where?: ToolExecutionWhereInput
    /**
     * Limit how many ToolExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ToolExecution upsert
   */
  export type ToolExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the ToolExecution to update in case it exists.
     */
    where: ToolExecutionWhereUniqueInput
    /**
     * In case the ToolExecution found by the `where` argument doesn't exist, create a new ToolExecution with this data.
     */
    create: XOR<ToolExecutionCreateInput, ToolExecutionUncheckedCreateInput>
    /**
     * In case the ToolExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ToolExecutionUpdateInput, ToolExecutionUncheckedUpdateInput>
  }

  /**
   * ToolExecution delete
   */
  export type ToolExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
    /**
     * Filter which ToolExecution to delete.
     */
    where: ToolExecutionWhereUniqueInput
  }

  /**
   * ToolExecution deleteMany
   */
  export type ToolExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ToolExecutions to delete
     */
    where?: ToolExecutionWhereInput
    /**
     * Limit how many ToolExecutions to delete.
     */
    limit?: number
  }

  /**
   * ToolExecution.whatsappMessages
   */
  export type ToolExecution$whatsappMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessage
     */
    select?: WhatsAppMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessage
     */
    omit?: WhatsAppMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageInclude<ExtArgs> | null
    where?: WhatsAppMessageWhereInput
    orderBy?: WhatsAppMessageOrderByWithRelationInput | WhatsAppMessageOrderByWithRelationInput[]
    cursor?: WhatsAppMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageScalarFieldEnum | WhatsAppMessageScalarFieldEnum[]
  }

  /**
   * ToolExecution without action
   */
  export type ToolExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToolExecution
     */
    select?: ToolExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ToolExecution
     */
    omit?: ToolExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToolExecutionInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    retryCount: number | null
    timeoutMs: number | null
  }

  export type WebhookSumAggregateOutputType = {
    retryCount: number | null
    timeoutMs: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    description: string | null
    retryCount: number | null
    timeoutMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    description: string | null
    retryCount: number | null
    timeoutMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
    officeId: string | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    name: number
    url: number
    secret: number
    isActive: number
    description: number
    retryCount: number
    timeoutMs: number
    headers: number
    createdAt: number
    updatedAt: number
    officeId: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    retryCount?: true
    timeoutMs?: true
  }

  export type WebhookSumAggregateInputType = {
    retryCount?: true
    timeoutMs?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    description?: true
    retryCount?: true
    timeoutMs?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    description?: true
    retryCount?: true
    timeoutMs?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    isActive?: true
    description?: true
    retryCount?: true
    timeoutMs?: true
    headers?: true
    createdAt?: true
    updatedAt?: true
    officeId?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    name: string
    url: string
    secret: string | null
    isActive: boolean
    description: string | null
    retryCount: number
    timeoutMs: number
    headers: JsonValue | null
    createdAt: Date
    updatedAt: Date
    officeId: string
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    description?: boolean
    retryCount?: boolean
    timeoutMs?: boolean
    headers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    executions?: boolean | Webhook$executionsArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    description?: boolean
    retryCount?: boolean
    timeoutMs?: boolean
    headers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    description?: boolean
    retryCount?: boolean
    timeoutMs?: boolean
    headers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    secret?: boolean
    isActive?: boolean
    description?: boolean
    retryCount?: boolean
    timeoutMs?: boolean
    headers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeId?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "secret" | "isActive" | "description" | "retryCount" | "timeoutMs" | "headers" | "createdAt" | "updatedAt" | "officeId", ExtArgs["result"]["webhook"]>
  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
    executions?: boolean | Webhook$executionsArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      office: Prisma.$OfficePayload<ExtArgs>
      executions: Prisma.$WebhookExecutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      secret: string | null
      isActive: boolean
      description: string | null
      retryCount: number
      timeoutMs: number
      headers: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      officeId: string
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executions<T extends Webhook$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly name: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly description: FieldRef<"Webhook", 'String'>
    readonly retryCount: FieldRef<"Webhook", 'Int'>
    readonly timeoutMs: FieldRef<"Webhook", 'Int'>
    readonly headers: FieldRef<"Webhook", 'Json'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
    readonly officeId: FieldRef<"Webhook", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook.executions
   */
  export type Webhook$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    where?: WebhookExecutionWhereInput
    orderBy?: WebhookExecutionOrderByWithRelationInput | WebhookExecutionOrderByWithRelationInput[]
    cursor?: WebhookExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookExecutionScalarFieldEnum | WebhookExecutionScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookExecution
   */

  export type AggregateWebhookExecution = {
    _count: WebhookExecutionCountAggregateOutputType | null
    _avg: WebhookExecutionAvgAggregateOutputType | null
    _sum: WebhookExecutionSumAggregateOutputType | null
    _min: WebhookExecutionMinAggregateOutputType | null
    _max: WebhookExecutionMaxAggregateOutputType | null
  }

  export type WebhookExecutionAvgAggregateOutputType = {
    responseCode: number | null
    attempt: number | null
  }

  export type WebhookExecutionSumAggregateOutputType = {
    responseCode: number | null
    attempt: number | null
  }

  export type WebhookExecutionMinAggregateOutputType = {
    id: string | null
    status: string | null
    responseCode: number | null
    executedAt: Date | null
    attempt: number | null
    error: string | null
    webhookId: string | null
  }

  export type WebhookExecutionMaxAggregateOutputType = {
    id: string | null
    status: string | null
    responseCode: number | null
    executedAt: Date | null
    attempt: number | null
    error: string | null
    webhookId: string | null
  }

  export type WebhookExecutionCountAggregateOutputType = {
    id: number
    status: number
    requestBody: number
    responseBody: number
    responseCode: number
    executedAt: number
    attempt: number
    error: number
    webhookId: number
    _all: number
  }


  export type WebhookExecutionAvgAggregateInputType = {
    responseCode?: true
    attempt?: true
  }

  export type WebhookExecutionSumAggregateInputType = {
    responseCode?: true
    attempt?: true
  }

  export type WebhookExecutionMinAggregateInputType = {
    id?: true
    status?: true
    responseCode?: true
    executedAt?: true
    attempt?: true
    error?: true
    webhookId?: true
  }

  export type WebhookExecutionMaxAggregateInputType = {
    id?: true
    status?: true
    responseCode?: true
    executedAt?: true
    attempt?: true
    error?: true
    webhookId?: true
  }

  export type WebhookExecutionCountAggregateInputType = {
    id?: true
    status?: true
    requestBody?: true
    responseBody?: true
    responseCode?: true
    executedAt?: true
    attempt?: true
    error?: true
    webhookId?: true
    _all?: true
  }

  export type WebhookExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookExecution to aggregate.
     */
    where?: WebhookExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookExecutions to fetch.
     */
    orderBy?: WebhookExecutionOrderByWithRelationInput | WebhookExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookExecutions
    **/
    _count?: true | WebhookExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookExecutionMaxAggregateInputType
  }

  export type GetWebhookExecutionAggregateType<T extends WebhookExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookExecution[P]>
      : GetScalarType<T[P], AggregateWebhookExecution[P]>
  }




  export type WebhookExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookExecutionWhereInput
    orderBy?: WebhookExecutionOrderByWithAggregationInput | WebhookExecutionOrderByWithAggregationInput[]
    by: WebhookExecutionScalarFieldEnum[] | WebhookExecutionScalarFieldEnum
    having?: WebhookExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookExecutionCountAggregateInputType | true
    _avg?: WebhookExecutionAvgAggregateInputType
    _sum?: WebhookExecutionSumAggregateInputType
    _min?: WebhookExecutionMinAggregateInputType
    _max?: WebhookExecutionMaxAggregateInputType
  }

  export type WebhookExecutionGroupByOutputType = {
    id: string
    status: string
    requestBody: JsonValue
    responseBody: JsonValue | null
    responseCode: number | null
    executedAt: Date
    attempt: number
    error: string | null
    webhookId: string
    _count: WebhookExecutionCountAggregateOutputType | null
    _avg: WebhookExecutionAvgAggregateOutputType | null
    _sum: WebhookExecutionSumAggregateOutputType | null
    _min: WebhookExecutionMinAggregateOutputType | null
    _max: WebhookExecutionMaxAggregateOutputType | null
  }

  type GetWebhookExecutionGroupByPayload<T extends WebhookExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookExecutionGroupByOutputType[P]>
        }
      >
    >


  export type WebhookExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    requestBody?: boolean
    responseBody?: boolean
    responseCode?: boolean
    executedAt?: boolean
    attempt?: boolean
    error?: boolean
    webhookId?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookExecution"]>

  export type WebhookExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    requestBody?: boolean
    responseBody?: boolean
    responseCode?: boolean
    executedAt?: boolean
    attempt?: boolean
    error?: boolean
    webhookId?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookExecution"]>

  export type WebhookExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    requestBody?: boolean
    responseBody?: boolean
    responseCode?: boolean
    executedAt?: boolean
    attempt?: boolean
    error?: boolean
    webhookId?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookExecution"]>

  export type WebhookExecutionSelectScalar = {
    id?: boolean
    status?: boolean
    requestBody?: boolean
    responseBody?: boolean
    responseCode?: boolean
    executedAt?: boolean
    attempt?: boolean
    error?: boolean
    webhookId?: boolean
  }

  export type WebhookExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "requestBody" | "responseBody" | "responseCode" | "executedAt" | "attempt" | "error" | "webhookId", ExtArgs["result"]["webhookExecution"]>
  export type WebhookExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookExecution"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      requestBody: Prisma.JsonValue
      responseBody: Prisma.JsonValue | null
      responseCode: number | null
      executedAt: Date
      attempt: number
      error: string | null
      webhookId: string
    }, ExtArgs["result"]["webhookExecution"]>
    composites: {}
  }

  type WebhookExecutionGetPayload<S extends boolean | null | undefined | WebhookExecutionDefaultArgs> = $Result.GetResult<Prisma.$WebhookExecutionPayload, S>

  type WebhookExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookExecutionCountAggregateInputType | true
    }

  export interface WebhookExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookExecution'], meta: { name: 'WebhookExecution' } }
    /**
     * Find zero or one WebhookExecution that matches the filter.
     * @param {WebhookExecutionFindUniqueArgs} args - Arguments to find a WebhookExecution
     * @example
     * // Get one WebhookExecution
     * const webhookExecution = await prisma.webhookExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookExecutionFindUniqueArgs>(args: SelectSubset<T, WebhookExecutionFindUniqueArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookExecutionFindUniqueOrThrowArgs} args - Arguments to find a WebhookExecution
     * @example
     * // Get one WebhookExecution
     * const webhookExecution = await prisma.webhookExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookExecutionFindFirstArgs} args - Arguments to find a WebhookExecution
     * @example
     * // Get one WebhookExecution
     * const webhookExecution = await prisma.webhookExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookExecutionFindFirstArgs>(args?: SelectSubset<T, WebhookExecutionFindFirstArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookExecutionFindFirstOrThrowArgs} args - Arguments to find a WebhookExecution
     * @example
     * // Get one WebhookExecution
     * const webhookExecution = await prisma.webhookExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookExecutions
     * const webhookExecutions = await prisma.webhookExecution.findMany()
     * 
     * // Get first 10 WebhookExecutions
     * const webhookExecutions = await prisma.webhookExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookExecutionWithIdOnly = await prisma.webhookExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookExecutionFindManyArgs>(args?: SelectSubset<T, WebhookExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookExecution.
     * @param {WebhookExecutionCreateArgs} args - Arguments to create a WebhookExecution.
     * @example
     * // Create one WebhookExecution
     * const WebhookExecution = await prisma.webhookExecution.create({
     *   data: {
     *     // ... data to create a WebhookExecution
     *   }
     * })
     * 
     */
    create<T extends WebhookExecutionCreateArgs>(args: SelectSubset<T, WebhookExecutionCreateArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookExecutions.
     * @param {WebhookExecutionCreateManyArgs} args - Arguments to create many WebhookExecutions.
     * @example
     * // Create many WebhookExecutions
     * const webhookExecution = await prisma.webhookExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookExecutionCreateManyArgs>(args?: SelectSubset<T, WebhookExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookExecutions and returns the data saved in the database.
     * @param {WebhookExecutionCreateManyAndReturnArgs} args - Arguments to create many WebhookExecutions.
     * @example
     * // Create many WebhookExecutions
     * const webhookExecution = await prisma.webhookExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookExecutions and only return the `id`
     * const webhookExecutionWithIdOnly = await prisma.webhookExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookExecution.
     * @param {WebhookExecutionDeleteArgs} args - Arguments to delete one WebhookExecution.
     * @example
     * // Delete one WebhookExecution
     * const WebhookExecution = await prisma.webhookExecution.delete({
     *   where: {
     *     // ... filter to delete one WebhookExecution
     *   }
     * })
     * 
     */
    delete<T extends WebhookExecutionDeleteArgs>(args: SelectSubset<T, WebhookExecutionDeleteArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookExecution.
     * @param {WebhookExecutionUpdateArgs} args - Arguments to update one WebhookExecution.
     * @example
     * // Update one WebhookExecution
     * const webhookExecution = await prisma.webhookExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookExecutionUpdateArgs>(args: SelectSubset<T, WebhookExecutionUpdateArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookExecutions.
     * @param {WebhookExecutionDeleteManyArgs} args - Arguments to filter WebhookExecutions to delete.
     * @example
     * // Delete a few WebhookExecutions
     * const { count } = await prisma.webhookExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookExecutionDeleteManyArgs>(args?: SelectSubset<T, WebhookExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookExecutions
     * const webhookExecution = await prisma.webhookExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookExecutionUpdateManyArgs>(args: SelectSubset<T, WebhookExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookExecutions and returns the data updated in the database.
     * @param {WebhookExecutionUpdateManyAndReturnArgs} args - Arguments to update many WebhookExecutions.
     * @example
     * // Update many WebhookExecutions
     * const webhookExecution = await prisma.webhookExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookExecutions and only return the `id`
     * const webhookExecutionWithIdOnly = await prisma.webhookExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookExecution.
     * @param {WebhookExecutionUpsertArgs} args - Arguments to update or create a WebhookExecution.
     * @example
     * // Update or create a WebhookExecution
     * const webhookExecution = await prisma.webhookExecution.upsert({
     *   create: {
     *     // ... data to create a WebhookExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookExecution we want to update
     *   }
     * })
     */
    upsert<T extends WebhookExecutionUpsertArgs>(args: SelectSubset<T, WebhookExecutionUpsertArgs<ExtArgs>>): Prisma__WebhookExecutionClient<$Result.GetResult<Prisma.$WebhookExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookExecutionCountArgs} args - Arguments to filter WebhookExecutions to count.
     * @example
     * // Count the number of WebhookExecutions
     * const count = await prisma.webhookExecution.count({
     *   where: {
     *     // ... the filter for the WebhookExecutions we want to count
     *   }
     * })
    **/
    count<T extends WebhookExecutionCountArgs>(
      args?: Subset<T, WebhookExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookExecutionAggregateArgs>(args: Subset<T, WebhookExecutionAggregateArgs>): Prisma.PrismaPromise<GetWebhookExecutionAggregateType<T>>

    /**
     * Group by WebhookExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookExecutionGroupByArgs['orderBy'] }
        : { orderBy?: WebhookExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookExecution model
   */
  readonly fields: WebhookExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookExecution model
   */
  interface WebhookExecutionFieldRefs {
    readonly id: FieldRef<"WebhookExecution", 'String'>
    readonly status: FieldRef<"WebhookExecution", 'String'>
    readonly requestBody: FieldRef<"WebhookExecution", 'Json'>
    readonly responseBody: FieldRef<"WebhookExecution", 'Json'>
    readonly responseCode: FieldRef<"WebhookExecution", 'Int'>
    readonly executedAt: FieldRef<"WebhookExecution", 'DateTime'>
    readonly attempt: FieldRef<"WebhookExecution", 'Int'>
    readonly error: FieldRef<"WebhookExecution", 'String'>
    readonly webhookId: FieldRef<"WebhookExecution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WebhookExecution findUnique
   */
  export type WebhookExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookExecution to fetch.
     */
    where: WebhookExecutionWhereUniqueInput
  }

  /**
   * WebhookExecution findUniqueOrThrow
   */
  export type WebhookExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookExecution to fetch.
     */
    where: WebhookExecutionWhereUniqueInput
  }

  /**
   * WebhookExecution findFirst
   */
  export type WebhookExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookExecution to fetch.
     */
    where?: WebhookExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookExecutions to fetch.
     */
    orderBy?: WebhookExecutionOrderByWithRelationInput | WebhookExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookExecutions.
     */
    cursor?: WebhookExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookExecutions.
     */
    distinct?: WebhookExecutionScalarFieldEnum | WebhookExecutionScalarFieldEnum[]
  }

  /**
   * WebhookExecution findFirstOrThrow
   */
  export type WebhookExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookExecution to fetch.
     */
    where?: WebhookExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookExecutions to fetch.
     */
    orderBy?: WebhookExecutionOrderByWithRelationInput | WebhookExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookExecutions.
     */
    cursor?: WebhookExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookExecutions.
     */
    distinct?: WebhookExecutionScalarFieldEnum | WebhookExecutionScalarFieldEnum[]
  }

  /**
   * WebhookExecution findMany
   */
  export type WebhookExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WebhookExecutions to fetch.
     */
    where?: WebhookExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookExecutions to fetch.
     */
    orderBy?: WebhookExecutionOrderByWithRelationInput | WebhookExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookExecutions.
     */
    cursor?: WebhookExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookExecutions.
     */
    skip?: number
    distinct?: WebhookExecutionScalarFieldEnum | WebhookExecutionScalarFieldEnum[]
  }

  /**
   * WebhookExecution create
   */
  export type WebhookExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookExecution.
     */
    data: XOR<WebhookExecutionCreateInput, WebhookExecutionUncheckedCreateInput>
  }

  /**
   * WebhookExecution createMany
   */
  export type WebhookExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookExecutions.
     */
    data: WebhookExecutionCreateManyInput | WebhookExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookExecution createManyAndReturn
   */
  export type WebhookExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookExecutions.
     */
    data: WebhookExecutionCreateManyInput | WebhookExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookExecution update
   */
  export type WebhookExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookExecution.
     */
    data: XOR<WebhookExecutionUpdateInput, WebhookExecutionUncheckedUpdateInput>
    /**
     * Choose, which WebhookExecution to update.
     */
    where: WebhookExecutionWhereUniqueInput
  }

  /**
   * WebhookExecution updateMany
   */
  export type WebhookExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookExecutions.
     */
    data: XOR<WebhookExecutionUpdateManyMutationInput, WebhookExecutionUncheckedUpdateManyInput>
    /**
     * Filter which WebhookExecutions to update
     */
    where?: WebhookExecutionWhereInput
    /**
     * Limit how many WebhookExecutions to update.
     */
    limit?: number
  }

  /**
   * WebhookExecution updateManyAndReturn
   */
  export type WebhookExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * The data used to update WebhookExecutions.
     */
    data: XOR<WebhookExecutionUpdateManyMutationInput, WebhookExecutionUncheckedUpdateManyInput>
    /**
     * Filter which WebhookExecutions to update
     */
    where?: WebhookExecutionWhereInput
    /**
     * Limit how many WebhookExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookExecution upsert
   */
  export type WebhookExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookExecution to update in case it exists.
     */
    where: WebhookExecutionWhereUniqueInput
    /**
     * In case the WebhookExecution found by the `where` argument doesn't exist, create a new WebhookExecution with this data.
     */
    create: XOR<WebhookExecutionCreateInput, WebhookExecutionUncheckedCreateInput>
    /**
     * In case the WebhookExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookExecutionUpdateInput, WebhookExecutionUncheckedUpdateInput>
  }

  /**
   * WebhookExecution delete
   */
  export type WebhookExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
    /**
     * Filter which WebhookExecution to delete.
     */
    where: WebhookExecutionWhereUniqueInput
  }

  /**
   * WebhookExecution deleteMany
   */
  export type WebhookExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookExecutions to delete
     */
    where?: WebhookExecutionWhereInput
    /**
     * Limit how many WebhookExecutions to delete.
     */
    limit?: number
  }

  /**
   * WebhookExecution without action
   */
  export type WebhookExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookExecution
     */
    select?: WebhookExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookExecution
     */
    omit?: WebhookExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookExecutionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    userId: string | null
    officeId: string | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    userId: string | null
    officeId: string | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    oldValues: number
    newValues: number
    ipAddress: number
    userAgent: number
    createdAt: number
    userId: number
    officeId: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    userId?: true
    officeId?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    userId?: true
    officeId?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    userId?: true
    officeId?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entityType: string
    entityId: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    userId: string | null
    officeId: string
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    userId?: boolean
    officeId?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    userId?: boolean
    officeId?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    userId?: boolean
    officeId?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    userId?: boolean
    officeId?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityType" | "entityId" | "oldValues" | "newValues" | "ipAddress" | "userAgent" | "createdAt" | "userId" | "officeId", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
    office?: boolean | OfficeDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      office: Prisma.$OfficePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entityType: string
      entityId: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      userId: string | null
      officeId: string
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    office<T extends OfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfficeDefaultArgs<ExtArgs>>): Prisma__OfficeClient<$Result.GetResult<Prisma.$OfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly officeId: FieldRef<"AuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model GlobalConfig
   */

  export type AggregateGlobalConfig = {
    _count: GlobalConfigCountAggregateOutputType | null
    _min: GlobalConfigMinAggregateOutputType | null
    _max: GlobalConfigMaxAggregateOutputType | null
  }

  export type GlobalConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlobalConfigMinAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalConfigMaxAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlobalConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalConfig to aggregate.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalConfigs
    **/
    _count?: true | GlobalConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalConfigMaxAggregateInputType
  }

  export type GetGlobalConfigAggregateType<T extends GlobalConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalConfig[P]>
      : GetScalarType<T[P], AggregateGlobalConfig[P]>
  }




  export type GlobalConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalConfigWhereInput
    orderBy?: GlobalConfigOrderByWithAggregationInput | GlobalConfigOrderByWithAggregationInput[]
    by: GlobalConfigScalarFieldEnum[] | GlobalConfigScalarFieldEnum
    having?: GlobalConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalConfigCountAggregateInputType | true
    _min?: GlobalConfigMinAggregateInputType
    _max?: GlobalConfigMaxAggregateInputType
  }

  export type GlobalConfigGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: GlobalConfigCountAggregateOutputType | null
    _min: GlobalConfigMinAggregateOutputType | null
    _max: GlobalConfigMaxAggregateOutputType | null
  }

  type GetGlobalConfigGroupByPayload<T extends GlobalConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalConfigGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalConfigGroupByOutputType[P]>
        }
      >
    >


  export type GlobalConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalConfig"]>

  export type GlobalConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalConfig"]>

  export type GlobalConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalConfig"]>

  export type GlobalConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GlobalConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["globalConfig"]>

  export type $GlobalConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["globalConfig"]>
    composites: {}
  }

  type GlobalConfigGetPayload<S extends boolean | null | undefined | GlobalConfigDefaultArgs> = $Result.GetResult<Prisma.$GlobalConfigPayload, S>

  type GlobalConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GlobalConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GlobalConfigCountAggregateInputType | true
    }

  export interface GlobalConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalConfig'], meta: { name: 'GlobalConfig' } }
    /**
     * Find zero or one GlobalConfig that matches the filter.
     * @param {GlobalConfigFindUniqueArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalConfigFindUniqueArgs>(args: SelectSubset<T, GlobalConfigFindUniqueArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GlobalConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GlobalConfigFindUniqueOrThrowArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigFindFirstArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalConfigFindFirstArgs>(args?: SelectSubset<T, GlobalConfigFindFirstArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigFindFirstOrThrowArgs} args - Arguments to find a GlobalConfig
     * @example
     * // Get one GlobalConfig
     * const globalConfig = await prisma.globalConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GlobalConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalConfigs
     * const globalConfigs = await prisma.globalConfig.findMany()
     * 
     * // Get first 10 GlobalConfigs
     * const globalConfigs = await prisma.globalConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalConfigWithIdOnly = await prisma.globalConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalConfigFindManyArgs>(args?: SelectSubset<T, GlobalConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GlobalConfig.
     * @param {GlobalConfigCreateArgs} args - Arguments to create a GlobalConfig.
     * @example
     * // Create one GlobalConfig
     * const GlobalConfig = await prisma.globalConfig.create({
     *   data: {
     *     // ... data to create a GlobalConfig
     *   }
     * })
     * 
     */
    create<T extends GlobalConfigCreateArgs>(args: SelectSubset<T, GlobalConfigCreateArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GlobalConfigs.
     * @param {GlobalConfigCreateManyArgs} args - Arguments to create many GlobalConfigs.
     * @example
     * // Create many GlobalConfigs
     * const globalConfig = await prisma.globalConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalConfigCreateManyArgs>(args?: SelectSubset<T, GlobalConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalConfigs and returns the data saved in the database.
     * @param {GlobalConfigCreateManyAndReturnArgs} args - Arguments to create many GlobalConfigs.
     * @example
     * // Create many GlobalConfigs
     * const globalConfig = await prisma.globalConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalConfigs and only return the `id`
     * const globalConfigWithIdOnly = await prisma.globalConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GlobalConfig.
     * @param {GlobalConfigDeleteArgs} args - Arguments to delete one GlobalConfig.
     * @example
     * // Delete one GlobalConfig
     * const GlobalConfig = await prisma.globalConfig.delete({
     *   where: {
     *     // ... filter to delete one GlobalConfig
     *   }
     * })
     * 
     */
    delete<T extends GlobalConfigDeleteArgs>(args: SelectSubset<T, GlobalConfigDeleteArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GlobalConfig.
     * @param {GlobalConfigUpdateArgs} args - Arguments to update one GlobalConfig.
     * @example
     * // Update one GlobalConfig
     * const globalConfig = await prisma.globalConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalConfigUpdateArgs>(args: SelectSubset<T, GlobalConfigUpdateArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GlobalConfigs.
     * @param {GlobalConfigDeleteManyArgs} args - Arguments to filter GlobalConfigs to delete.
     * @example
     * // Delete a few GlobalConfigs
     * const { count } = await prisma.globalConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalConfigDeleteManyArgs>(args?: SelectSubset<T, GlobalConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalConfigs
     * const globalConfig = await prisma.globalConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalConfigUpdateManyArgs>(args: SelectSubset<T, GlobalConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalConfigs and returns the data updated in the database.
     * @param {GlobalConfigUpdateManyAndReturnArgs} args - Arguments to update many GlobalConfigs.
     * @example
     * // Update many GlobalConfigs
     * const globalConfig = await prisma.globalConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GlobalConfigs and only return the `id`
     * const globalConfigWithIdOnly = await prisma.globalConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GlobalConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, GlobalConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GlobalConfig.
     * @param {GlobalConfigUpsertArgs} args - Arguments to update or create a GlobalConfig.
     * @example
     * // Update or create a GlobalConfig
     * const globalConfig = await prisma.globalConfig.upsert({
     *   create: {
     *     // ... data to create a GlobalConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalConfig we want to update
     *   }
     * })
     */
    upsert<T extends GlobalConfigUpsertArgs>(args: SelectSubset<T, GlobalConfigUpsertArgs<ExtArgs>>): Prisma__GlobalConfigClient<$Result.GetResult<Prisma.$GlobalConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GlobalConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigCountArgs} args - Arguments to filter GlobalConfigs to count.
     * @example
     * // Count the number of GlobalConfigs
     * const count = await prisma.globalConfig.count({
     *   where: {
     *     // ... the filter for the GlobalConfigs we want to count
     *   }
     * })
    **/
    count<T extends GlobalConfigCountArgs>(
      args?: Subset<T, GlobalConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalConfigAggregateArgs>(args: Subset<T, GlobalConfigAggregateArgs>): Prisma.PrismaPromise<GetGlobalConfigAggregateType<T>>

    /**
     * Group by GlobalConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalConfigGroupByArgs['orderBy'] }
        : { orderBy?: GlobalConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalConfig model
   */
  readonly fields: GlobalConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalConfig model
   */
  interface GlobalConfigFieldRefs {
    readonly id: FieldRef<"GlobalConfig", 'String'>
    readonly key: FieldRef<"GlobalConfig", 'String'>
    readonly value: FieldRef<"GlobalConfig", 'Json'>
    readonly createdAt: FieldRef<"GlobalConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"GlobalConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlobalConfig findUnique
   */
  export type GlobalConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig findUniqueOrThrow
   */
  export type GlobalConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig findFirst
   */
  export type GlobalConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalConfigs.
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalConfigs.
     */
    distinct?: GlobalConfigScalarFieldEnum | GlobalConfigScalarFieldEnum[]
  }

  /**
   * GlobalConfig findFirstOrThrow
   */
  export type GlobalConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * Filter, which GlobalConfig to fetch.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalConfigs.
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalConfigs.
     */
    distinct?: GlobalConfigScalarFieldEnum | GlobalConfigScalarFieldEnum[]
  }

  /**
   * GlobalConfig findMany
   */
  export type GlobalConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * Filter, which GlobalConfigs to fetch.
     */
    where?: GlobalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalConfigs to fetch.
     */
    orderBy?: GlobalConfigOrderByWithRelationInput | GlobalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalConfigs.
     */
    cursor?: GlobalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalConfigs.
     */
    skip?: number
    distinct?: GlobalConfigScalarFieldEnum | GlobalConfigScalarFieldEnum[]
  }

  /**
   * GlobalConfig create
   */
  export type GlobalConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a GlobalConfig.
     */
    data: XOR<GlobalConfigCreateInput, GlobalConfigUncheckedCreateInput>
  }

  /**
   * GlobalConfig createMany
   */
  export type GlobalConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalConfigs.
     */
    data: GlobalConfigCreateManyInput | GlobalConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalConfig createManyAndReturn
   */
  export type GlobalConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * The data used to create many GlobalConfigs.
     */
    data: GlobalConfigCreateManyInput | GlobalConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalConfig update
   */
  export type GlobalConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a GlobalConfig.
     */
    data: XOR<GlobalConfigUpdateInput, GlobalConfigUncheckedUpdateInput>
    /**
     * Choose, which GlobalConfig to update.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig updateMany
   */
  export type GlobalConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalConfigs.
     */
    data: XOR<GlobalConfigUpdateManyMutationInput, GlobalConfigUncheckedUpdateManyInput>
    /**
     * Filter which GlobalConfigs to update
     */
    where?: GlobalConfigWhereInput
    /**
     * Limit how many GlobalConfigs to update.
     */
    limit?: number
  }

  /**
   * GlobalConfig updateManyAndReturn
   */
  export type GlobalConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * The data used to update GlobalConfigs.
     */
    data: XOR<GlobalConfigUpdateManyMutationInput, GlobalConfigUncheckedUpdateManyInput>
    /**
     * Filter which GlobalConfigs to update
     */
    where?: GlobalConfigWhereInput
    /**
     * Limit how many GlobalConfigs to update.
     */
    limit?: number
  }

  /**
   * GlobalConfig upsert
   */
  export type GlobalConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the GlobalConfig to update in case it exists.
     */
    where: GlobalConfigWhereUniqueInput
    /**
     * In case the GlobalConfig found by the `where` argument doesn't exist, create a new GlobalConfig with this data.
     */
    create: XOR<GlobalConfigCreateInput, GlobalConfigUncheckedCreateInput>
    /**
     * In case the GlobalConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalConfigUpdateInput, GlobalConfigUncheckedUpdateInput>
  }

  /**
   * GlobalConfig delete
   */
  export type GlobalConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
    /**
     * Filter which GlobalConfig to delete.
     */
    where: GlobalConfigWhereUniqueInput
  }

  /**
   * GlobalConfig deleteMany
   */
  export type GlobalConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalConfigs to delete
     */
    where?: GlobalConfigWhereInput
    /**
     * Limit how many GlobalConfigs to delete.
     */
    limit?: number
  }

  /**
   * GlobalConfig without action
   */
  export type GlobalConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalConfig
     */
    select?: GlobalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalConfig
     */
    omit?: GlobalConfigOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const OfficeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cnpj: 'cnpj',
    phone: 'phone',
    email: 'email',
    address: 'address',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfficeScalarFieldEnum = (typeof OfficeScalarFieldEnum)[keyof typeof OfficeScalarFieldEnum]


  export const WhatsappConfigScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    phone: 'phone',
    qrCode: 'qrCode',
    isActive: 'isActive',
    apiUrl: 'apiUrl',
    apiKey: 'apiKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type WhatsappConfigScalarFieldEnum = (typeof WhatsappConfigScalarFieldEnum)[keyof typeof WhatsappConfigScalarFieldEnum]


  export const WhatsAppInstanceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phoneNumber: 'phoneNumber',
    status: 'status',
    qrCode: 'qrCode',
    webhookUrl: 'webhookUrl',
    officeId: 'officeId',
    createdById: 'createdById',
    connectionData: 'connectionData',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppInstanceScalarFieldEnum = (typeof WhatsAppInstanceScalarFieldEnum)[keyof typeof WhatsAppInstanceScalarFieldEnum]


  export const WhatsAppContactScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    remoteJid: 'remoteJid',
    phoneNumber: 'phoneNumber',
    name: 'name',
    pushName: 'pushName',
    profilePicUrl: 'profilePicUrl',
    isGroup: 'isGroup',
    lastSeen: 'lastSeen',
    isBlocked: 'isBlocked',
    clientId: 'clientId',
    tags: 'tags',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppContactScalarFieldEnum = (typeof WhatsAppContactScalarFieldEnum)[keyof typeof WhatsAppContactScalarFieldEnum]


  export const WhatsAppConversationScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    contactId: 'contactId',
    remoteJid: 'remoteJid',
    title: 'title',
    isGroup: 'isGroup',
    lastMessageId: 'lastMessageId',
    lastMessageAt: 'lastMessageAt',
    unreadCount: 'unreadCount',
    isArchived: 'isArchived',
    isPinned: 'isPinned',
    assignedUserId: 'assignedUserId',
    status: 'status',
    aiEnabled: 'aiEnabled',
    currentAgentId: 'currentAgentId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppConversationScalarFieldEnum = (typeof WhatsAppConversationScalarFieldEnum)[keyof typeof WhatsAppConversationScalarFieldEnum]


  export const WhatsAppMessageScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    conversationId: 'conversationId',
    contactId: 'contactId',
    remoteJid: 'remoteJid',
    messageId: 'messageId',
    fromMe: 'fromMe',
    messageType: 'messageType',
    content: 'content',
    quotedMessageId: 'quotedMessageId',
    mediaUrl: 'mediaUrl',
    mediaSize: 'mediaSize',
    mimetype: 'mimetype',
    fileName: 'fileName',
    caption: 'caption',
    location: 'location',
    isForwarded: 'isForwarded',
    timestamp: 'timestamp',
    status: 'status',
    isDeleted: 'isDeleted',
    isEdited: 'isEdited',
    aiResponse: 'aiResponse',
    toolExecutionId: 'toolExecutionId',
    importedFrom: 'importedFrom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppMessageScalarFieldEnum = (typeof WhatsAppMessageScalarFieldEnum)[keyof typeof WhatsAppMessageScalarFieldEnum]


  export const WhatsAppImportScalarFieldEnum: {
    id: 'id',
    instanceId: 'instanceId',
    contactId: 'contactId',
    fileName: 'fileName',
    fileSize: 'fileSize',
    totalMessages: 'totalMessages',
    importedMessages: 'importedMessages',
    failedMessages: 'failedMessages',
    mediaFiles: 'mediaFiles',
    status: 'status',
    errorMessage: 'errorMessage',
    uploadedById: 'uploadedById',
    importedAt: 'importedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppImportScalarFieldEnum = (typeof WhatsAppImportScalarFieldEnum)[keyof typeof WhatsAppImportScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    document: 'document',
    notes: 'notes',
    isLead: 'isLead',
    dateOfBirth: 'dateOfBirth',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    status: 'status',
    lastMessageAt: 'lastMessageAt',
    metadata: 'metadata',
    currentAgentType: 'currentAgentType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    officeId: 'officeId',
    createdBy: 'createdBy',
    assignedTo: 'assignedTo',
    whatsappConfigId: 'whatsappConfigId'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    type: 'type',
    isFromClient: 'isFromClient',
    isFromAI: 'isFromAI',
    metadata: 'metadata',
    externalId: 'externalId',
    mediaUrl: 'mediaUrl',
    transcription: 'transcription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    conversationId: 'conversationId',
    userId: 'userId',
    whatsappConfigId: 'whatsappConfigId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const AudioTranscriptionScalarFieldEnum: {
    id: 'id',
    originalText: 'originalText',
    provider: 'provider',
    confidence: 'confidence',
    duration: 'duration',
    language: 'language',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    messageId: 'messageId'
  };

  export type AudioTranscriptionScalarFieldEnum = (typeof AudioTranscriptionScalarFieldEnum)[keyof typeof AudioTranscriptionScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ClientTagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    clientId: 'clientId',
    tagId: 'tagId'
  };

  export type ClientTagScalarFieldEnum = (typeof ClientTagScalarFieldEnum)[keyof typeof ClientTagScalarFieldEnum]


  export const ConversationTagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    conversationId: 'conversationId',
    tagId: 'tagId'
  };

  export type ConversationTagScalarFieldEnum = (typeof ConversationTagScalarFieldEnum)[keyof typeof ConversationTagScalarFieldEnum]


  export const CustomStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    description: 'description',
    isActive: 'isActive',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type CustomStatusScalarFieldEnum = (typeof CustomStatusScalarFieldEnum)[keyof typeof CustomStatusScalarFieldEnum]


  export const ConversationCustomStatusScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    conversationId: 'conversationId',
    customStatusId: 'customStatusId'
  };

  export type ConversationCustomStatusScalarFieldEnum = (typeof ConversationCustomStatusScalarFieldEnum)[keyof typeof ConversationCustomStatusScalarFieldEnum]


  export const AiAgentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    prompt: 'prompt',
    model: 'model',
    provider: 'provider',
    aiModel: 'aiModel',
    temperature: 'temperature',
    maxTokens: 'maxTokens',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type AiAgentScalarFieldEnum = (typeof AiAgentScalarFieldEnum)[keyof typeof AiAgentScalarFieldEnum]


  export const AIProviderConfigScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    apiKey: 'apiKey',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type AIProviderConfigScalarFieldEnum = (typeof AIProviderConfigScalarFieldEnum)[keyof typeof AIProviderConfigScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    officeId: 'officeId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ToolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    webhookUrl: 'webhookUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId',
    createdById: 'createdById'
  };

  export type ToolScalarFieldEnum = (typeof ToolScalarFieldEnum)[keyof typeof ToolScalarFieldEnum]


  export const ToolExecutionScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    description: 'description',
    status: 'status',
    requestData: 'requestData',
    responseData: 'responseData',
    errorMessage: 'errorMessage',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    conversationId: 'conversationId',
    agentId: 'agentId',
    toolId: 'toolId'
  };

  export type ToolExecutionScalarFieldEnum = (typeof ToolExecutionScalarFieldEnum)[keyof typeof ToolExecutionScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    secret: 'secret',
    isActive: 'isActive',
    description: 'description',
    retryCount: 'retryCount',
    timeoutMs: 'timeoutMs',
    headers: 'headers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    officeId: 'officeId'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookExecutionScalarFieldEnum: {
    id: 'id',
    status: 'status',
    requestBody: 'requestBody',
    responseBody: 'responseBody',
    responseCode: 'responseCode',
    executedAt: 'executedAt',
    attempt: 'attempt',
    error: 'error',
    webhookId: 'webhookId'
  };

  export type WebhookExecutionScalarFieldEnum = (typeof WebhookExecutionScalarFieldEnum)[keyof typeof WebhookExecutionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    userId: 'userId',
    officeId: 'officeId'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const GlobalConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlobalConfigScalarFieldEnum = (typeof GlobalConfigScalarFieldEnum)[keyof typeof GlobalConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'WhatsAppInstanceStatus'
   */
  export type EnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppInstanceStatus'>
    


  /**
   * Reference to a field of type 'WhatsAppInstanceStatus[]'
   */
  export type ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppInstanceStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'WhatsAppConversationStatus'
   */
  export type EnumWhatsAppConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppConversationStatus'>
    


  /**
   * Reference to a field of type 'WhatsAppConversationStatus[]'
   */
  export type ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppConversationStatus[]'>
    


  /**
   * Reference to a field of type 'WhatsAppMessageType'
   */
  export type EnumWhatsAppMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppMessageType'>
    


  /**
   * Reference to a field of type 'WhatsAppMessageType[]'
   */
  export type ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppMessageType[]'>
    


  /**
   * Reference to a field of type 'WhatsAppMessageStatus'
   */
  export type EnumWhatsAppMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppMessageStatus'>
    


  /**
   * Reference to a field of type 'WhatsAppMessageStatus[]'
   */
  export type ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppMessageStatus[]'>
    


  /**
   * Reference to a field of type 'WhatsAppImportStatus'
   */
  export type EnumWhatsAppImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppImportStatus'>
    


  /**
   * Reference to a field of type 'WhatsAppImportStatus[]'
   */
  export type ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhatsAppImportStatus[]'>
    


  /**
   * Reference to a field of type 'ConversationStatus'
   */
  export type EnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus'>
    


  /**
   * Reference to a field of type 'ConversationStatus[]'
   */
  export type ListEnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus[]'>
    


  /**
   * Reference to a field of type 'AgentType'
   */
  export type EnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType'>
    


  /**
   * Reference to a field of type 'AgentType[]'
   */
  export type ListEnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'TranscriptionProvider'
   */
  export type EnumTranscriptionProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptionProvider'>
    


  /**
   * Reference to a field of type 'TranscriptionProvider[]'
   */
  export type ListEnumTranscriptionProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptionProvider[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AIProvider'
   */
  export type EnumAIProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIProvider'>
    


  /**
   * Reference to a field of type 'AIProvider[]'
   */
  export type ListEnumAIProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIProvider[]'>
    


  /**
   * Reference to a field of type 'AIModel'
   */
  export type EnumAIModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIModel'>
    


  /**
   * Reference to a field of type 'AIModel[]'
   */
  export type ListEnumAIModelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIModel[]'>
    


  /**
   * Reference to a field of type 'ToolExecutionStatus'
   */
  export type EnumToolExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToolExecutionStatus'>
    


  /**
   * Reference to a field of type 'ToolExecutionStatus[]'
   */
  export type ListEnumToolExecutionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ToolExecutionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    officeId?: StringNullableFilter<"User"> | string | null
    office?: XOR<OfficeNullableScalarRelationFilter, OfficeWhereInput> | null
    createdConversations?: ConversationListRelationFilter
    assignedConversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    logs?: AuditLogListRelationFilter
    sessions?: SessionListRelationFilter
    toolsCreated?: ToolListRelationFilter
    whatsappInstancesCreated?: WhatsAppInstanceListRelationFilter
    whatsappImportsUploaded?: WhatsAppImportListRelationFilter
    whatsappConversationsAssigned?: WhatsAppConversationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrderInput | SortOrder
    office?: OfficeOrderByWithRelationInput
    createdConversations?: ConversationOrderByRelationAggregateInput
    assignedConversations?: ConversationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    logs?: AuditLogOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    toolsCreated?: ToolOrderByRelationAggregateInput
    whatsappInstancesCreated?: WhatsAppInstanceOrderByRelationAggregateInput
    whatsappImportsUploaded?: WhatsAppImportOrderByRelationAggregateInput
    whatsappConversationsAssigned?: WhatsAppConversationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    officeId?: StringNullableFilter<"User"> | string | null
    office?: XOR<OfficeNullableScalarRelationFilter, OfficeWhereInput> | null
    createdConversations?: ConversationListRelationFilter
    assignedConversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
    logs?: AuditLogListRelationFilter
    sessions?: SessionListRelationFilter
    toolsCreated?: ToolListRelationFilter
    whatsappInstancesCreated?: WhatsAppInstanceListRelationFilter
    whatsappImportsUploaded?: WhatsAppImportListRelationFilter
    whatsappConversationsAssigned?: WhatsAppConversationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    officeId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type OfficeWhereInput = {
    AND?: OfficeWhereInput | OfficeWhereInput[]
    OR?: OfficeWhereInput[]
    NOT?: OfficeWhereInput | OfficeWhereInput[]
    id?: StringFilter<"Office"> | string
    name?: StringFilter<"Office"> | string
    cnpj?: StringNullableFilter<"Office"> | string | null
    phone?: StringNullableFilter<"Office"> | string | null
    email?: StringNullableFilter<"Office"> | string | null
    address?: StringNullableFilter<"Office"> | string | null
    isActive?: BoolFilter<"Office"> | boolean
    createdAt?: DateTimeFilter<"Office"> | Date | string
    updatedAt?: DateTimeFilter<"Office"> | Date | string
    users?: UserListRelationFilter
    clients?: ClientListRelationFilter
    conversations?: ConversationListRelationFilter
    tags?: TagListRelationFilter
    customStatuses?: CustomStatusListRelationFilter
    aiAgents?: AiAgentListRelationFilter
    whatsappConfigs?: WhatsappConfigListRelationFilter
    documents?: DocumentListRelationFilter
    tools?: ToolListRelationFilter
    webhooks?: WebhookListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    aiConfigs?: AIProviderConfigListRelationFilter
    whatsappInstances?: WhatsAppInstanceListRelationFilter
  }

  export type OfficeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    customStatuses?: CustomStatusOrderByRelationAggregateInput
    aiAgents?: AiAgentOrderByRelationAggregateInput
    whatsappConfigs?: WhatsappConfigOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    tools?: ToolOrderByRelationAggregateInput
    webhooks?: WebhookOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    aiConfigs?: AIProviderConfigOrderByRelationAggregateInput
    whatsappInstances?: WhatsAppInstanceOrderByRelationAggregateInput
  }

  export type OfficeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cnpj?: string
    AND?: OfficeWhereInput | OfficeWhereInput[]
    OR?: OfficeWhereInput[]
    NOT?: OfficeWhereInput | OfficeWhereInput[]
    name?: StringFilter<"Office"> | string
    phone?: StringNullableFilter<"Office"> | string | null
    email?: StringNullableFilter<"Office"> | string | null
    address?: StringNullableFilter<"Office"> | string | null
    isActive?: BoolFilter<"Office"> | boolean
    createdAt?: DateTimeFilter<"Office"> | Date | string
    updatedAt?: DateTimeFilter<"Office"> | Date | string
    users?: UserListRelationFilter
    clients?: ClientListRelationFilter
    conversations?: ConversationListRelationFilter
    tags?: TagListRelationFilter
    customStatuses?: CustomStatusListRelationFilter
    aiAgents?: AiAgentListRelationFilter
    whatsappConfigs?: WhatsappConfigListRelationFilter
    documents?: DocumentListRelationFilter
    tools?: ToolListRelationFilter
    webhooks?: WebhookListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    aiConfigs?: AIProviderConfigListRelationFilter
    whatsappInstances?: WhatsAppInstanceListRelationFilter
  }, "id" | "cnpj">

  export type OfficeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfficeCountOrderByAggregateInput
    _max?: OfficeMaxOrderByAggregateInput
    _min?: OfficeMinOrderByAggregateInput
  }

  export type OfficeScalarWhereWithAggregatesInput = {
    AND?: OfficeScalarWhereWithAggregatesInput | OfficeScalarWhereWithAggregatesInput[]
    OR?: OfficeScalarWhereWithAggregatesInput[]
    NOT?: OfficeScalarWhereWithAggregatesInput | OfficeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Office"> | string
    name?: StringWithAggregatesFilter<"Office"> | string
    cnpj?: StringNullableWithAggregatesFilter<"Office"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Office"> | string | null
    email?: StringNullableWithAggregatesFilter<"Office"> | string | null
    address?: StringNullableWithAggregatesFilter<"Office"> | string | null
    isActive?: BoolWithAggregatesFilter<"Office"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Office"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Office"> | Date | string
  }

  export type WhatsappConfigWhereInput = {
    AND?: WhatsappConfigWhereInput | WhatsappConfigWhereInput[]
    OR?: WhatsappConfigWhereInput[]
    NOT?: WhatsappConfigWhereInput | WhatsappConfigWhereInput[]
    id?: StringFilter<"WhatsappConfig"> | string
    instanceId?: StringFilter<"WhatsappConfig"> | string
    phone?: StringFilter<"WhatsappConfig"> | string
    qrCode?: StringNullableFilter<"WhatsappConfig"> | string | null
    isActive?: BoolFilter<"WhatsappConfig"> | boolean
    apiUrl?: StringNullableFilter<"WhatsappConfig"> | string | null
    apiKey?: StringNullableFilter<"WhatsappConfig"> | string | null
    createdAt?: DateTimeFilter<"WhatsappConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappConfig"> | Date | string
    officeId?: StringFilter<"WhatsappConfig"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type WhatsappConfigOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    phone?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    office?: OfficeOrderByWithRelationInput
    conversations?: ConversationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type WhatsappConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: WhatsappConfigWhereInput | WhatsappConfigWhereInput[]
    OR?: WhatsappConfigWhereInput[]
    NOT?: WhatsappConfigWhereInput | WhatsappConfigWhereInput[]
    phone?: StringFilter<"WhatsappConfig"> | string
    qrCode?: StringNullableFilter<"WhatsappConfig"> | string | null
    isActive?: BoolFilter<"WhatsappConfig"> | boolean
    apiUrl?: StringNullableFilter<"WhatsappConfig"> | string | null
    apiKey?: StringNullableFilter<"WhatsappConfig"> | string | null
    createdAt?: DateTimeFilter<"WhatsappConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappConfig"> | Date | string
    officeId?: StringFilter<"WhatsappConfig"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
  }, "id" | "instanceId">

  export type WhatsappConfigOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    phone?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    _count?: WhatsappConfigCountOrderByAggregateInput
    _max?: WhatsappConfigMaxOrderByAggregateInput
    _min?: WhatsappConfigMinOrderByAggregateInput
  }

  export type WhatsappConfigScalarWhereWithAggregatesInput = {
    AND?: WhatsappConfigScalarWhereWithAggregatesInput | WhatsappConfigScalarWhereWithAggregatesInput[]
    OR?: WhatsappConfigScalarWhereWithAggregatesInput[]
    NOT?: WhatsappConfigScalarWhereWithAggregatesInput | WhatsappConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsappConfig"> | string
    instanceId?: StringWithAggregatesFilter<"WhatsappConfig"> | string
    phone?: StringWithAggregatesFilter<"WhatsappConfig"> | string
    qrCode?: StringNullableWithAggregatesFilter<"WhatsappConfig"> | string | null
    isActive?: BoolWithAggregatesFilter<"WhatsappConfig"> | boolean
    apiUrl?: StringNullableWithAggregatesFilter<"WhatsappConfig"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"WhatsappConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsappConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsappConfig"> | Date | string
    officeId?: StringWithAggregatesFilter<"WhatsappConfig"> | string
  }

  export type WhatsAppInstanceWhereInput = {
    AND?: WhatsAppInstanceWhereInput | WhatsAppInstanceWhereInput[]
    OR?: WhatsAppInstanceWhereInput[]
    NOT?: WhatsAppInstanceWhereInput | WhatsAppInstanceWhereInput[]
    id?: StringFilter<"WhatsAppInstance"> | string
    name?: StringFilter<"WhatsAppInstance"> | string
    phoneNumber?: StringNullableFilter<"WhatsAppInstance"> | string | null
    status?: EnumWhatsAppInstanceStatusFilter<"WhatsAppInstance"> | $Enums.WhatsAppInstanceStatus
    qrCode?: StringNullableFilter<"WhatsAppInstance"> | string | null
    webhookUrl?: StringNullableFilter<"WhatsAppInstance"> | string | null
    officeId?: StringFilter<"WhatsAppInstance"> | string
    createdById?: StringFilter<"WhatsAppInstance"> | string
    connectionData?: JsonNullableFilter<"WhatsAppInstance">
    isActive?: BoolFilter<"WhatsAppInstance"> | boolean
    createdAt?: DateTimeFilter<"WhatsAppInstance"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppInstance"> | Date | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    contacts?: WhatsAppContactListRelationFilter
    conversations?: WhatsAppConversationListRelationFilter
    messages?: WhatsAppMessageListRelationFilter
    imports?: WhatsAppImportListRelationFilter
  }

  export type WhatsAppInstanceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
    connectionData?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    office?: OfficeOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    contacts?: WhatsAppContactOrderByRelationAggregateInput
    conversations?: WhatsAppConversationOrderByRelationAggregateInput
    messages?: WhatsAppMessageOrderByRelationAggregateInput
    imports?: WhatsAppImportOrderByRelationAggregateInput
  }

  export type WhatsAppInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppInstanceWhereInput | WhatsAppInstanceWhereInput[]
    OR?: WhatsAppInstanceWhereInput[]
    NOT?: WhatsAppInstanceWhereInput | WhatsAppInstanceWhereInput[]
    name?: StringFilter<"WhatsAppInstance"> | string
    phoneNumber?: StringNullableFilter<"WhatsAppInstance"> | string | null
    status?: EnumWhatsAppInstanceStatusFilter<"WhatsAppInstance"> | $Enums.WhatsAppInstanceStatus
    qrCode?: StringNullableFilter<"WhatsAppInstance"> | string | null
    webhookUrl?: StringNullableFilter<"WhatsAppInstance"> | string | null
    officeId?: StringFilter<"WhatsAppInstance"> | string
    createdById?: StringFilter<"WhatsAppInstance"> | string
    connectionData?: JsonNullableFilter<"WhatsAppInstance">
    isActive?: BoolFilter<"WhatsAppInstance"> | boolean
    createdAt?: DateTimeFilter<"WhatsAppInstance"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppInstance"> | Date | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    contacts?: WhatsAppContactListRelationFilter
    conversations?: WhatsAppConversationListRelationFilter
    messages?: WhatsAppMessageListRelationFilter
    imports?: WhatsAppImportListRelationFilter
  }, "id">

  export type WhatsAppInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
    connectionData?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppInstanceCountOrderByAggregateInput
    _max?: WhatsAppInstanceMaxOrderByAggregateInput
    _min?: WhatsAppInstanceMinOrderByAggregateInput
  }

  export type WhatsAppInstanceScalarWhereWithAggregatesInput = {
    AND?: WhatsAppInstanceScalarWhereWithAggregatesInput | WhatsAppInstanceScalarWhereWithAggregatesInput[]
    OR?: WhatsAppInstanceScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppInstanceScalarWhereWithAggregatesInput | WhatsAppInstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppInstance"> | string
    name?: StringWithAggregatesFilter<"WhatsAppInstance"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"WhatsAppInstance"> | string | null
    status?: EnumWhatsAppInstanceStatusWithAggregatesFilter<"WhatsAppInstance"> | $Enums.WhatsAppInstanceStatus
    qrCode?: StringNullableWithAggregatesFilter<"WhatsAppInstance"> | string | null
    webhookUrl?: StringNullableWithAggregatesFilter<"WhatsAppInstance"> | string | null
    officeId?: StringWithAggregatesFilter<"WhatsAppInstance"> | string
    createdById?: StringWithAggregatesFilter<"WhatsAppInstance"> | string
    connectionData?: JsonNullableWithAggregatesFilter<"WhatsAppInstance">
    isActive?: BoolWithAggregatesFilter<"WhatsAppInstance"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppInstance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppInstance"> | Date | string
  }

  export type WhatsAppContactWhereInput = {
    AND?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    OR?: WhatsAppContactWhereInput[]
    NOT?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    id?: StringFilter<"WhatsAppContact"> | string
    instanceId?: StringFilter<"WhatsAppContact"> | string
    remoteJid?: StringFilter<"WhatsAppContact"> | string
    phoneNumber?: StringFilter<"WhatsAppContact"> | string
    name?: StringNullableFilter<"WhatsAppContact"> | string | null
    pushName?: StringNullableFilter<"WhatsAppContact"> | string | null
    profilePicUrl?: StringNullableFilter<"WhatsAppContact"> | string | null
    isGroup?: BoolFilter<"WhatsAppContact"> | boolean
    lastSeen?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    isBlocked?: BoolFilter<"WhatsAppContact"> | boolean
    clientId?: StringNullableFilter<"WhatsAppContact"> | string | null
    tags?: StringNullableListFilter<"WhatsAppContact">
    notes?: StringNullableFilter<"WhatsAppContact"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppContact"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppContact"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    conversations?: WhatsAppConversationListRelationFilter
    messages?: WhatsAppMessageListRelationFilter
    imports?: WhatsAppImportListRelationFilter
  }

  export type WhatsAppContactOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    remoteJid?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    pushName?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    isBlocked?: SortOrder
    clientId?: SortOrderInput | SortOrder
    tags?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: WhatsAppInstanceOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    conversations?: WhatsAppConversationOrderByRelationAggregateInput
    messages?: WhatsAppMessageOrderByRelationAggregateInput
    imports?: WhatsAppImportOrderByRelationAggregateInput
  }

  export type WhatsAppContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId_remoteJid?: WhatsAppContactInstanceIdRemoteJidCompoundUniqueInput
    AND?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    OR?: WhatsAppContactWhereInput[]
    NOT?: WhatsAppContactWhereInput | WhatsAppContactWhereInput[]
    instanceId?: StringFilter<"WhatsAppContact"> | string
    remoteJid?: StringFilter<"WhatsAppContact"> | string
    phoneNumber?: StringFilter<"WhatsAppContact"> | string
    name?: StringNullableFilter<"WhatsAppContact"> | string | null
    pushName?: StringNullableFilter<"WhatsAppContact"> | string | null
    profilePicUrl?: StringNullableFilter<"WhatsAppContact"> | string | null
    isGroup?: BoolFilter<"WhatsAppContact"> | boolean
    lastSeen?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    isBlocked?: BoolFilter<"WhatsAppContact"> | boolean
    clientId?: StringNullableFilter<"WhatsAppContact"> | string | null
    tags?: StringNullableListFilter<"WhatsAppContact">
    notes?: StringNullableFilter<"WhatsAppContact"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppContact"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppContact"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    conversations?: WhatsAppConversationListRelationFilter
    messages?: WhatsAppMessageListRelationFilter
    imports?: WhatsAppImportListRelationFilter
  }, "id" | "instanceId_remoteJid">

  export type WhatsAppContactOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    remoteJid?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrderInput | SortOrder
    pushName?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    isBlocked?: SortOrder
    clientId?: SortOrderInput | SortOrder
    tags?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppContactCountOrderByAggregateInput
    _max?: WhatsAppContactMaxOrderByAggregateInput
    _min?: WhatsAppContactMinOrderByAggregateInput
  }

  export type WhatsAppContactScalarWhereWithAggregatesInput = {
    AND?: WhatsAppContactScalarWhereWithAggregatesInput | WhatsAppContactScalarWhereWithAggregatesInput[]
    OR?: WhatsAppContactScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppContactScalarWhereWithAggregatesInput | WhatsAppContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppContact"> | string
    instanceId?: StringWithAggregatesFilter<"WhatsAppContact"> | string
    remoteJid?: StringWithAggregatesFilter<"WhatsAppContact"> | string
    phoneNumber?: StringWithAggregatesFilter<"WhatsAppContact"> | string
    name?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    pushName?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    profilePicUrl?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    isGroup?: BoolWithAggregatesFilter<"WhatsAppContact"> | boolean
    lastSeen?: DateTimeNullableWithAggregatesFilter<"WhatsAppContact"> | Date | string | null
    isBlocked?: BoolWithAggregatesFilter<"WhatsAppContact"> | boolean
    clientId?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    tags?: StringNullableListFilter<"WhatsAppContact">
    notes?: StringNullableWithAggregatesFilter<"WhatsAppContact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppContact"> | Date | string
  }

  export type WhatsAppConversationWhereInput = {
    AND?: WhatsAppConversationWhereInput | WhatsAppConversationWhereInput[]
    OR?: WhatsAppConversationWhereInput[]
    NOT?: WhatsAppConversationWhereInput | WhatsAppConversationWhereInput[]
    id?: StringFilter<"WhatsAppConversation"> | string
    instanceId?: StringFilter<"WhatsAppConversation"> | string
    contactId?: StringFilter<"WhatsAppConversation"> | string
    remoteJid?: StringFilter<"WhatsAppConversation"> | string
    title?: StringNullableFilter<"WhatsAppConversation"> | string | null
    isGroup?: BoolFilter<"WhatsAppConversation"> | boolean
    lastMessageId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"WhatsAppConversation"> | Date | string | null
    unreadCount?: IntFilter<"WhatsAppConversation"> | number
    isArchived?: BoolFilter<"WhatsAppConversation"> | boolean
    isPinned?: BoolFilter<"WhatsAppConversation"> | boolean
    assignedUserId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    status?: EnumWhatsAppConversationStatusFilter<"WhatsAppConversation"> | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFilter<"WhatsAppConversation"> | boolean
    currentAgentId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    metadata?: JsonNullableFilter<"WhatsAppConversation">
    createdAt?: DateTimeFilter<"WhatsAppConversation"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppConversation"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    contact?: XOR<WhatsAppContactScalarRelationFilter, WhatsAppContactWhereInput>
    assignedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    currentAgent?: XOR<AiAgentNullableScalarRelationFilter, AiAgentWhereInput> | null
    messages?: WhatsAppMessageListRelationFilter
  }

  export type WhatsAppConversationOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    title?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    lastMessageId?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    unreadCount?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    status?: SortOrder
    aiEnabled?: SortOrder
    currentAgentId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: WhatsAppInstanceOrderByWithRelationInput
    contact?: WhatsAppContactOrderByWithRelationInput
    assignedUser?: UserOrderByWithRelationInput
    currentAgent?: AiAgentOrderByWithRelationInput
    messages?: WhatsAppMessageOrderByRelationAggregateInput
  }

  export type WhatsAppConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId_remoteJid?: WhatsAppConversationInstanceIdRemoteJidCompoundUniqueInput
    AND?: WhatsAppConversationWhereInput | WhatsAppConversationWhereInput[]
    OR?: WhatsAppConversationWhereInput[]
    NOT?: WhatsAppConversationWhereInput | WhatsAppConversationWhereInput[]
    instanceId?: StringFilter<"WhatsAppConversation"> | string
    contactId?: StringFilter<"WhatsAppConversation"> | string
    remoteJid?: StringFilter<"WhatsAppConversation"> | string
    title?: StringNullableFilter<"WhatsAppConversation"> | string | null
    isGroup?: BoolFilter<"WhatsAppConversation"> | boolean
    lastMessageId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"WhatsAppConversation"> | Date | string | null
    unreadCount?: IntFilter<"WhatsAppConversation"> | number
    isArchived?: BoolFilter<"WhatsAppConversation"> | boolean
    isPinned?: BoolFilter<"WhatsAppConversation"> | boolean
    assignedUserId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    status?: EnumWhatsAppConversationStatusFilter<"WhatsAppConversation"> | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFilter<"WhatsAppConversation"> | boolean
    currentAgentId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    metadata?: JsonNullableFilter<"WhatsAppConversation">
    createdAt?: DateTimeFilter<"WhatsAppConversation"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppConversation"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    contact?: XOR<WhatsAppContactScalarRelationFilter, WhatsAppContactWhereInput>
    assignedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    currentAgent?: XOR<AiAgentNullableScalarRelationFilter, AiAgentWhereInput> | null
    messages?: WhatsAppMessageListRelationFilter
  }, "id" | "instanceId_remoteJid">

  export type WhatsAppConversationOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    title?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    lastMessageId?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    unreadCount?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    status?: SortOrder
    aiEnabled?: SortOrder
    currentAgentId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppConversationCountOrderByAggregateInput
    _avg?: WhatsAppConversationAvgOrderByAggregateInput
    _max?: WhatsAppConversationMaxOrderByAggregateInput
    _min?: WhatsAppConversationMinOrderByAggregateInput
    _sum?: WhatsAppConversationSumOrderByAggregateInput
  }

  export type WhatsAppConversationScalarWhereWithAggregatesInput = {
    AND?: WhatsAppConversationScalarWhereWithAggregatesInput | WhatsAppConversationScalarWhereWithAggregatesInput[]
    OR?: WhatsAppConversationScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppConversationScalarWhereWithAggregatesInput | WhatsAppConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppConversation"> | string
    instanceId?: StringWithAggregatesFilter<"WhatsAppConversation"> | string
    contactId?: StringWithAggregatesFilter<"WhatsAppConversation"> | string
    remoteJid?: StringWithAggregatesFilter<"WhatsAppConversation"> | string
    title?: StringNullableWithAggregatesFilter<"WhatsAppConversation"> | string | null
    isGroup?: BoolWithAggregatesFilter<"WhatsAppConversation"> | boolean
    lastMessageId?: StringNullableWithAggregatesFilter<"WhatsAppConversation"> | string | null
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppConversation"> | Date | string | null
    unreadCount?: IntWithAggregatesFilter<"WhatsAppConversation"> | number
    isArchived?: BoolWithAggregatesFilter<"WhatsAppConversation"> | boolean
    isPinned?: BoolWithAggregatesFilter<"WhatsAppConversation"> | boolean
    assignedUserId?: StringNullableWithAggregatesFilter<"WhatsAppConversation"> | string | null
    status?: EnumWhatsAppConversationStatusWithAggregatesFilter<"WhatsAppConversation"> | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolWithAggregatesFilter<"WhatsAppConversation"> | boolean
    currentAgentId?: StringNullableWithAggregatesFilter<"WhatsAppConversation"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"WhatsAppConversation">
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppConversation"> | Date | string
  }

  export type WhatsAppMessageWhereInput = {
    AND?: WhatsAppMessageWhereInput | WhatsAppMessageWhereInput[]
    OR?: WhatsAppMessageWhereInput[]
    NOT?: WhatsAppMessageWhereInput | WhatsAppMessageWhereInput[]
    id?: StringFilter<"WhatsAppMessage"> | string
    instanceId?: StringFilter<"WhatsAppMessage"> | string
    conversationId?: StringFilter<"WhatsAppMessage"> | string
    contactId?: StringFilter<"WhatsAppMessage"> | string
    remoteJid?: StringFilter<"WhatsAppMessage"> | string
    messageId?: StringFilter<"WhatsAppMessage"> | string
    fromMe?: BoolFilter<"WhatsAppMessage"> | boolean
    messageType?: EnumWhatsAppMessageTypeFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageType
    content?: StringNullableFilter<"WhatsAppMessage"> | string | null
    quotedMessageId?: StringNullableFilter<"WhatsAppMessage"> | string | null
    mediaUrl?: StringNullableFilter<"WhatsAppMessage"> | string | null
    mediaSize?: IntNullableFilter<"WhatsAppMessage"> | number | null
    mimetype?: StringNullableFilter<"WhatsAppMessage"> | string | null
    fileName?: StringNullableFilter<"WhatsAppMessage"> | string | null
    caption?: StringNullableFilter<"WhatsAppMessage"> | string | null
    location?: JsonNullableFilter<"WhatsAppMessage">
    isForwarded?: BoolFilter<"WhatsAppMessage"> | boolean
    timestamp?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    status?: EnumWhatsAppMessageStatusFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFilter<"WhatsAppMessage"> | boolean
    isEdited?: BoolFilter<"WhatsAppMessage"> | boolean
    aiResponse?: BoolFilter<"WhatsAppMessage"> | boolean
    toolExecutionId?: StringNullableFilter<"WhatsAppMessage"> | string | null
    importedFrom?: StringNullableFilter<"WhatsAppMessage"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    conversation?: XOR<WhatsAppConversationScalarRelationFilter, WhatsAppConversationWhereInput>
    contact?: XOR<WhatsAppContactScalarRelationFilter, WhatsAppContactWhereInput>
    toolExecution?: XOR<ToolExecutionNullableScalarRelationFilter, ToolExecutionWhereInput> | null
  }

  export type WhatsAppMessageOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    messageId?: SortOrder
    fromMe?: SortOrder
    messageType?: SortOrder
    content?: SortOrderInput | SortOrder
    quotedMessageId?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaSize?: SortOrderInput | SortOrder
    mimetype?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isForwarded?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    isEdited?: SortOrder
    aiResponse?: SortOrder
    toolExecutionId?: SortOrderInput | SortOrder
    importedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: WhatsAppInstanceOrderByWithRelationInput
    conversation?: WhatsAppConversationOrderByWithRelationInput
    contact?: WhatsAppContactOrderByWithRelationInput
    toolExecution?: ToolExecutionOrderByWithRelationInput
  }

  export type WhatsAppMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId_messageId?: WhatsAppMessageInstanceIdMessageIdCompoundUniqueInput
    AND?: WhatsAppMessageWhereInput | WhatsAppMessageWhereInput[]
    OR?: WhatsAppMessageWhereInput[]
    NOT?: WhatsAppMessageWhereInput | WhatsAppMessageWhereInput[]
    instanceId?: StringFilter<"WhatsAppMessage"> | string
    conversationId?: StringFilter<"WhatsAppMessage"> | string
    contactId?: StringFilter<"WhatsAppMessage"> | string
    remoteJid?: StringFilter<"WhatsAppMessage"> | string
    messageId?: StringFilter<"WhatsAppMessage"> | string
    fromMe?: BoolFilter<"WhatsAppMessage"> | boolean
    messageType?: EnumWhatsAppMessageTypeFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageType
    content?: StringNullableFilter<"WhatsAppMessage"> | string | null
    quotedMessageId?: StringNullableFilter<"WhatsAppMessage"> | string | null
    mediaUrl?: StringNullableFilter<"WhatsAppMessage"> | string | null
    mediaSize?: IntNullableFilter<"WhatsAppMessage"> | number | null
    mimetype?: StringNullableFilter<"WhatsAppMessage"> | string | null
    fileName?: StringNullableFilter<"WhatsAppMessage"> | string | null
    caption?: StringNullableFilter<"WhatsAppMessage"> | string | null
    location?: JsonNullableFilter<"WhatsAppMessage">
    isForwarded?: BoolFilter<"WhatsAppMessage"> | boolean
    timestamp?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    status?: EnumWhatsAppMessageStatusFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFilter<"WhatsAppMessage"> | boolean
    isEdited?: BoolFilter<"WhatsAppMessage"> | boolean
    aiResponse?: BoolFilter<"WhatsAppMessage"> | boolean
    toolExecutionId?: StringNullableFilter<"WhatsAppMessage"> | string | null
    importedFrom?: StringNullableFilter<"WhatsAppMessage"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    conversation?: XOR<WhatsAppConversationScalarRelationFilter, WhatsAppConversationWhereInput>
    contact?: XOR<WhatsAppContactScalarRelationFilter, WhatsAppContactWhereInput>
    toolExecution?: XOR<ToolExecutionNullableScalarRelationFilter, ToolExecutionWhereInput> | null
  }, "id" | "instanceId_messageId">

  export type WhatsAppMessageOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    messageId?: SortOrder
    fromMe?: SortOrder
    messageType?: SortOrder
    content?: SortOrderInput | SortOrder
    quotedMessageId?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaSize?: SortOrderInput | SortOrder
    mimetype?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isForwarded?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    isEdited?: SortOrder
    aiResponse?: SortOrder
    toolExecutionId?: SortOrderInput | SortOrder
    importedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppMessageCountOrderByAggregateInput
    _avg?: WhatsAppMessageAvgOrderByAggregateInput
    _max?: WhatsAppMessageMaxOrderByAggregateInput
    _min?: WhatsAppMessageMinOrderByAggregateInput
    _sum?: WhatsAppMessageSumOrderByAggregateInput
  }

  export type WhatsAppMessageScalarWhereWithAggregatesInput = {
    AND?: WhatsAppMessageScalarWhereWithAggregatesInput | WhatsAppMessageScalarWhereWithAggregatesInput[]
    OR?: WhatsAppMessageScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppMessageScalarWhereWithAggregatesInput | WhatsAppMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppMessage"> | string
    instanceId?: StringWithAggregatesFilter<"WhatsAppMessage"> | string
    conversationId?: StringWithAggregatesFilter<"WhatsAppMessage"> | string
    contactId?: StringWithAggregatesFilter<"WhatsAppMessage"> | string
    remoteJid?: StringWithAggregatesFilter<"WhatsAppMessage"> | string
    messageId?: StringWithAggregatesFilter<"WhatsAppMessage"> | string
    fromMe?: BoolWithAggregatesFilter<"WhatsAppMessage"> | boolean
    messageType?: EnumWhatsAppMessageTypeWithAggregatesFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageType
    content?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    quotedMessageId?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    mediaSize?: IntNullableWithAggregatesFilter<"WhatsAppMessage"> | number | null
    mimetype?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    caption?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    location?: JsonNullableWithAggregatesFilter<"WhatsAppMessage">
    isForwarded?: BoolWithAggregatesFilter<"WhatsAppMessage"> | boolean
    timestamp?: DateTimeWithAggregatesFilter<"WhatsAppMessage"> | Date | string
    status?: EnumWhatsAppMessageStatusWithAggregatesFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolWithAggregatesFilter<"WhatsAppMessage"> | boolean
    isEdited?: BoolWithAggregatesFilter<"WhatsAppMessage"> | boolean
    aiResponse?: BoolWithAggregatesFilter<"WhatsAppMessage"> | boolean
    toolExecutionId?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    importedFrom?: StringNullableWithAggregatesFilter<"WhatsAppMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppMessage"> | Date | string
  }

  export type WhatsAppImportWhereInput = {
    AND?: WhatsAppImportWhereInput | WhatsAppImportWhereInput[]
    OR?: WhatsAppImportWhereInput[]
    NOT?: WhatsAppImportWhereInput | WhatsAppImportWhereInput[]
    id?: StringFilter<"WhatsAppImport"> | string
    instanceId?: StringFilter<"WhatsAppImport"> | string
    contactId?: StringFilter<"WhatsAppImport"> | string
    fileName?: StringFilter<"WhatsAppImport"> | string
    fileSize?: IntFilter<"WhatsAppImport"> | number
    totalMessages?: IntFilter<"WhatsAppImport"> | number
    importedMessages?: IntFilter<"WhatsAppImport"> | number
    failedMessages?: IntFilter<"WhatsAppImport"> | number
    mediaFiles?: StringNullableListFilter<"WhatsAppImport">
    status?: EnumWhatsAppImportStatusFilter<"WhatsAppImport"> | $Enums.WhatsAppImportStatus
    errorMessage?: StringNullableFilter<"WhatsAppImport"> | string | null
    uploadedById?: StringFilter<"WhatsAppImport"> | string
    importedAt?: DateTimeNullableFilter<"WhatsAppImport"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppImport"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppImport"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    contact?: XOR<WhatsAppContactScalarRelationFilter, WhatsAppContactWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WhatsAppImportOrderByWithRelationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalMessages?: SortOrder
    importedMessages?: SortOrder
    failedMessages?: SortOrder
    mediaFiles?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    importedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: WhatsAppInstanceOrderByWithRelationInput
    contact?: WhatsAppContactOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type WhatsAppImportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppImportWhereInput | WhatsAppImportWhereInput[]
    OR?: WhatsAppImportWhereInput[]
    NOT?: WhatsAppImportWhereInput | WhatsAppImportWhereInput[]
    instanceId?: StringFilter<"WhatsAppImport"> | string
    contactId?: StringFilter<"WhatsAppImport"> | string
    fileName?: StringFilter<"WhatsAppImport"> | string
    fileSize?: IntFilter<"WhatsAppImport"> | number
    totalMessages?: IntFilter<"WhatsAppImport"> | number
    importedMessages?: IntFilter<"WhatsAppImport"> | number
    failedMessages?: IntFilter<"WhatsAppImport"> | number
    mediaFiles?: StringNullableListFilter<"WhatsAppImport">
    status?: EnumWhatsAppImportStatusFilter<"WhatsAppImport"> | $Enums.WhatsAppImportStatus
    errorMessage?: StringNullableFilter<"WhatsAppImport"> | string | null
    uploadedById?: StringFilter<"WhatsAppImport"> | string
    importedAt?: DateTimeNullableFilter<"WhatsAppImport"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppImport"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppImport"> | Date | string
    instance?: XOR<WhatsAppInstanceScalarRelationFilter, WhatsAppInstanceWhereInput>
    contact?: XOR<WhatsAppContactScalarRelationFilter, WhatsAppContactWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WhatsAppImportOrderByWithAggregationInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalMessages?: SortOrder
    importedMessages?: SortOrder
    failedMessages?: SortOrder
    mediaFiles?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    importedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppImportCountOrderByAggregateInput
    _avg?: WhatsAppImportAvgOrderByAggregateInput
    _max?: WhatsAppImportMaxOrderByAggregateInput
    _min?: WhatsAppImportMinOrderByAggregateInput
    _sum?: WhatsAppImportSumOrderByAggregateInput
  }

  export type WhatsAppImportScalarWhereWithAggregatesInput = {
    AND?: WhatsAppImportScalarWhereWithAggregatesInput | WhatsAppImportScalarWhereWithAggregatesInput[]
    OR?: WhatsAppImportScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppImportScalarWhereWithAggregatesInput | WhatsAppImportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppImport"> | string
    instanceId?: StringWithAggregatesFilter<"WhatsAppImport"> | string
    contactId?: StringWithAggregatesFilter<"WhatsAppImport"> | string
    fileName?: StringWithAggregatesFilter<"WhatsAppImport"> | string
    fileSize?: IntWithAggregatesFilter<"WhatsAppImport"> | number
    totalMessages?: IntWithAggregatesFilter<"WhatsAppImport"> | number
    importedMessages?: IntWithAggregatesFilter<"WhatsAppImport"> | number
    failedMessages?: IntWithAggregatesFilter<"WhatsAppImport"> | number
    mediaFiles?: StringNullableListFilter<"WhatsAppImport">
    status?: EnumWhatsAppImportStatusWithAggregatesFilter<"WhatsAppImport"> | $Enums.WhatsAppImportStatus
    errorMessage?: StringNullableWithAggregatesFilter<"WhatsAppImport"> | string | null
    uploadedById?: StringWithAggregatesFilter<"WhatsAppImport"> | string
    importedAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppImport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppImport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppImport"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringNullableFilter<"Client"> | string | null
    phone?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    document?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    isLead?: BoolFilter<"Client"> | boolean
    dateOfBirth?: DateTimeNullableFilter<"Client"> | Date | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    officeId?: StringFilter<"Client"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    conversations?: ConversationListRelationFilter
    documents?: DocumentListRelationFilter
    clientTags?: ClientTagListRelationFilter
    whatsappContacts?: WhatsAppContactListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isLead?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    office?: OfficeOrderByWithRelationInput
    conversations?: ConversationOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    clientTags?: ClientTagOrderByRelationAggregateInput
    whatsappContacts?: WhatsAppContactOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    document?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    isLead?: BoolFilter<"Client"> | boolean
    dateOfBirth?: DateTimeNullableFilter<"Client"> | Date | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    officeId?: StringFilter<"Client"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    conversations?: ConversationListRelationFilter
    documents?: DocumentListRelationFilter
    clientTags?: ClientTagListRelationFilter
    whatsappContacts?: WhatsAppContactListRelationFilter
  }, "id" | "phone">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isLead?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    document?: StringNullableWithAggregatesFilter<"Client"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    isLead?: BoolWithAggregatesFilter<"Client"> | boolean
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    officeId?: StringWithAggregatesFilter<"Client"> | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableFilter<"Conversation">
    currentAgentType?: EnumAgentTypeNullableFilter<"Conversation"> | $Enums.AgentType | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    clientId?: StringFilter<"Conversation"> | string
    officeId?: StringFilter<"Conversation"> | string
    createdBy?: StringFilter<"Conversation"> | string
    assignedTo?: StringNullableFilter<"Conversation"> | string | null
    whatsappConfigId?: StringNullableFilter<"Conversation"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    whatsappConfig?: XOR<WhatsappConfigNullableScalarRelationFilter, WhatsappConfigWhereInput> | null
    messages?: MessageListRelationFilter
    conversationTags?: ConversationTagListRelationFilter
    conversationStatus?: ConversationCustomStatusListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    currentAgentType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
    createdBy?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    whatsappConfigId?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    office?: OfficeOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
    whatsappConfig?: WhatsappConfigOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    conversationTags?: ConversationTagOrderByRelationAggregateInput
    conversationStatus?: ConversationCustomStatusOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    title?: StringNullableFilter<"Conversation"> | string | null
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableFilter<"Conversation">
    currentAgentType?: EnumAgentTypeNullableFilter<"Conversation"> | $Enums.AgentType | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    clientId?: StringFilter<"Conversation"> | string
    officeId?: StringFilter<"Conversation"> | string
    createdBy?: StringFilter<"Conversation"> | string
    assignedTo?: StringNullableFilter<"Conversation"> | string | null
    whatsappConfigId?: StringNullableFilter<"Conversation"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    whatsappConfig?: XOR<WhatsappConfigNullableScalarRelationFilter, WhatsappConfigWhereInput> | null
    messages?: MessageListRelationFilter
    conversationTags?: ConversationTagListRelationFilter
    conversationStatus?: ConversationCustomStatusListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    currentAgentType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
    createdBy?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    whatsappConfigId?: SortOrderInput | SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    status?: EnumConversationStatusWithAggregatesFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Conversation">
    currentAgentType?: EnumAgentTypeNullableWithAggregatesFilter<"Conversation"> | $Enums.AgentType | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    clientId?: StringWithAggregatesFilter<"Conversation"> | string
    officeId?: StringWithAggregatesFilter<"Conversation"> | string
    createdBy?: StringWithAggregatesFilter<"Conversation"> | string
    assignedTo?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    whatsappConfigId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isFromClient?: BoolFilter<"Message"> | boolean
    isFromAI?: BoolFilter<"Message"> | boolean
    metadata?: JsonNullableFilter<"Message">
    externalId?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    transcription?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    userId?: StringNullableFilter<"Message"> | string | null
    whatsappConfigId?: StringNullableFilter<"Message"> | string | null
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    whatsappConfig?: XOR<WhatsappConfigNullableScalarRelationFilter, WhatsappConfigWhereInput> | null
    audioTranscription?: XOR<AudioTranscriptionNullableScalarRelationFilter, AudioTranscriptionWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    isFromClient?: SortOrder
    isFromAI?: SortOrder
    metadata?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    transcription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    whatsappConfigId?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    whatsappConfig?: WhatsappConfigOrderByWithRelationInput
    audioTranscription?: AudioTranscriptionOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringNullableFilter<"Message"> | string | null
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isFromClient?: BoolFilter<"Message"> | boolean
    isFromAI?: BoolFilter<"Message"> | boolean
    metadata?: JsonNullableFilter<"Message">
    externalId?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    transcription?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    userId?: StringNullableFilter<"Message"> | string | null
    whatsappConfigId?: StringNullableFilter<"Message"> | string | null
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    whatsappConfig?: XOR<WhatsappConfigNullableScalarRelationFilter, WhatsappConfigWhereInput> | null
    audioTranscription?: XOR<AudioTranscriptionNullableScalarRelationFilter, AudioTranscriptionWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    isFromClient?: SortOrder
    isFromAI?: SortOrder
    metadata?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    transcription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    whatsappConfigId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    isFromClient?: BoolWithAggregatesFilter<"Message"> | boolean
    isFromAI?: BoolWithAggregatesFilter<"Message"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    externalId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    transcription?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    userId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    whatsappConfigId?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type AudioTranscriptionWhereInput = {
    AND?: AudioTranscriptionWhereInput | AudioTranscriptionWhereInput[]
    OR?: AudioTranscriptionWhereInput[]
    NOT?: AudioTranscriptionWhereInput | AudioTranscriptionWhereInput[]
    id?: StringFilter<"AudioTranscription"> | string
    originalText?: StringNullableFilter<"AudioTranscription"> | string | null
    provider?: EnumTranscriptionProviderFilter<"AudioTranscription"> | $Enums.TranscriptionProvider
    confidence?: FloatNullableFilter<"AudioTranscription"> | number | null
    duration?: FloatNullableFilter<"AudioTranscription"> | number | null
    language?: StringNullableFilter<"AudioTranscription"> | string | null
    metadata?: JsonNullableFilter<"AudioTranscription">
    createdAt?: DateTimeFilter<"AudioTranscription"> | Date | string
    updatedAt?: DateTimeFilter<"AudioTranscription"> | Date | string
    messageId?: StringFilter<"AudioTranscription"> | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type AudioTranscriptionOrderByWithRelationInput = {
    id?: SortOrder
    originalText?: SortOrderInput | SortOrder
    provider?: SortOrder
    confidence?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messageId?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type AudioTranscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: AudioTranscriptionWhereInput | AudioTranscriptionWhereInput[]
    OR?: AudioTranscriptionWhereInput[]
    NOT?: AudioTranscriptionWhereInput | AudioTranscriptionWhereInput[]
    originalText?: StringNullableFilter<"AudioTranscription"> | string | null
    provider?: EnumTranscriptionProviderFilter<"AudioTranscription"> | $Enums.TranscriptionProvider
    confidence?: FloatNullableFilter<"AudioTranscription"> | number | null
    duration?: FloatNullableFilter<"AudioTranscription"> | number | null
    language?: StringNullableFilter<"AudioTranscription"> | string | null
    metadata?: JsonNullableFilter<"AudioTranscription">
    createdAt?: DateTimeFilter<"AudioTranscription"> | Date | string
    updatedAt?: DateTimeFilter<"AudioTranscription"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id" | "messageId">

  export type AudioTranscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    originalText?: SortOrderInput | SortOrder
    provider?: SortOrder
    confidence?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messageId?: SortOrder
    _count?: AudioTranscriptionCountOrderByAggregateInput
    _avg?: AudioTranscriptionAvgOrderByAggregateInput
    _max?: AudioTranscriptionMaxOrderByAggregateInput
    _min?: AudioTranscriptionMinOrderByAggregateInput
    _sum?: AudioTranscriptionSumOrderByAggregateInput
  }

  export type AudioTranscriptionScalarWhereWithAggregatesInput = {
    AND?: AudioTranscriptionScalarWhereWithAggregatesInput | AudioTranscriptionScalarWhereWithAggregatesInput[]
    OR?: AudioTranscriptionScalarWhereWithAggregatesInput[]
    NOT?: AudioTranscriptionScalarWhereWithAggregatesInput | AudioTranscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioTranscription"> | string
    originalText?: StringNullableWithAggregatesFilter<"AudioTranscription"> | string | null
    provider?: EnumTranscriptionProviderWithAggregatesFilter<"AudioTranscription"> | $Enums.TranscriptionProvider
    confidence?: FloatNullableWithAggregatesFilter<"AudioTranscription"> | number | null
    duration?: FloatNullableWithAggregatesFilter<"AudioTranscription"> | number | null
    language?: StringNullableWithAggregatesFilter<"AudioTranscription"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AudioTranscription">
    createdAt?: DateTimeWithAggregatesFilter<"AudioTranscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AudioTranscription"> | Date | string
    messageId?: StringWithAggregatesFilter<"AudioTranscription"> | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    isActive?: BoolFilter<"Tag"> | boolean
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    officeId?: StringFilter<"Tag"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    clientTags?: ClientTagListRelationFilter
    conversationTags?: ConversationTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    office?: OfficeOrderByWithRelationInput
    clientTags?: ClientTagOrderByRelationAggregateInput
    conversationTags?: ConversationTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_officeId?: TagNameOfficeIdCompoundUniqueInput
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    isActive?: BoolFilter<"Tag"> | boolean
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    officeId?: StringFilter<"Tag"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    clientTags?: ClientTagListRelationFilter
    conversationTags?: ConversationTagListRelationFilter
  }, "id" | "name_officeId">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    isActive?: BoolWithAggregatesFilter<"Tag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    officeId?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type ClientTagWhereInput = {
    AND?: ClientTagWhereInput | ClientTagWhereInput[]
    OR?: ClientTagWhereInput[]
    NOT?: ClientTagWhereInput | ClientTagWhereInput[]
    id?: StringFilter<"ClientTag"> | string
    createdAt?: DateTimeFilter<"ClientTag"> | Date | string
    clientId?: StringFilter<"ClientTag"> | string
    tagId?: StringFilter<"ClientTag"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ClientTagOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    clientId?: SortOrder
    tagId?: SortOrder
    client?: ClientOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ClientTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_tagId?: ClientTagClientIdTagIdCompoundUniqueInput
    AND?: ClientTagWhereInput | ClientTagWhereInput[]
    OR?: ClientTagWhereInput[]
    NOT?: ClientTagWhereInput | ClientTagWhereInput[]
    createdAt?: DateTimeFilter<"ClientTag"> | Date | string
    clientId?: StringFilter<"ClientTag"> | string
    tagId?: StringFilter<"ClientTag"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "clientId_tagId">

  export type ClientTagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    clientId?: SortOrder
    tagId?: SortOrder
    _count?: ClientTagCountOrderByAggregateInput
    _max?: ClientTagMaxOrderByAggregateInput
    _min?: ClientTagMinOrderByAggregateInput
  }

  export type ClientTagScalarWhereWithAggregatesInput = {
    AND?: ClientTagScalarWhereWithAggregatesInput | ClientTagScalarWhereWithAggregatesInput[]
    OR?: ClientTagScalarWhereWithAggregatesInput[]
    NOT?: ClientTagScalarWhereWithAggregatesInput | ClientTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientTag"> | Date | string
    clientId?: StringWithAggregatesFilter<"ClientTag"> | string
    tagId?: StringWithAggregatesFilter<"ClientTag"> | string
  }

  export type ConversationTagWhereInput = {
    AND?: ConversationTagWhereInput | ConversationTagWhereInput[]
    OR?: ConversationTagWhereInput[]
    NOT?: ConversationTagWhereInput | ConversationTagWhereInput[]
    id?: StringFilter<"ConversationTag"> | string
    createdAt?: DateTimeFilter<"ConversationTag"> | Date | string
    conversationId?: StringFilter<"ConversationTag"> | string
    tagId?: StringFilter<"ConversationTag"> | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ConversationTagOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    tagId?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ConversationTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_tagId?: ConversationTagConversationIdTagIdCompoundUniqueInput
    AND?: ConversationTagWhereInput | ConversationTagWhereInput[]
    OR?: ConversationTagWhereInput[]
    NOT?: ConversationTagWhereInput | ConversationTagWhereInput[]
    createdAt?: DateTimeFilter<"ConversationTag"> | Date | string
    conversationId?: StringFilter<"ConversationTag"> | string
    tagId?: StringFilter<"ConversationTag"> | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "conversationId_tagId">

  export type ConversationTagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    tagId?: SortOrder
    _count?: ConversationTagCountOrderByAggregateInput
    _max?: ConversationTagMaxOrderByAggregateInput
    _min?: ConversationTagMinOrderByAggregateInput
  }

  export type ConversationTagScalarWhereWithAggregatesInput = {
    AND?: ConversationTagScalarWhereWithAggregatesInput | ConversationTagScalarWhereWithAggregatesInput[]
    OR?: ConversationTagScalarWhereWithAggregatesInput[]
    NOT?: ConversationTagScalarWhereWithAggregatesInput | ConversationTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConversationTag"> | Date | string
    conversationId?: StringWithAggregatesFilter<"ConversationTag"> | string
    tagId?: StringWithAggregatesFilter<"ConversationTag"> | string
  }

  export type CustomStatusWhereInput = {
    AND?: CustomStatusWhereInput | CustomStatusWhereInput[]
    OR?: CustomStatusWhereInput[]
    NOT?: CustomStatusWhereInput | CustomStatusWhereInput[]
    id?: StringFilter<"CustomStatus"> | string
    name?: StringFilter<"CustomStatus"> | string
    color?: StringFilter<"CustomStatus"> | string
    description?: StringNullableFilter<"CustomStatus"> | string | null
    isActive?: BoolFilter<"CustomStatus"> | boolean
    order?: IntFilter<"CustomStatus"> | number
    createdAt?: DateTimeFilter<"CustomStatus"> | Date | string
    updatedAt?: DateTimeFilter<"CustomStatus"> | Date | string
    officeId?: StringFilter<"CustomStatus"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    conversationStatuses?: ConversationCustomStatusListRelationFilter
  }

  export type CustomStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    office?: OfficeOrderByWithRelationInput
    conversationStatuses?: ConversationCustomStatusOrderByRelationAggregateInput
  }

  export type CustomStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_officeId?: CustomStatusNameOfficeIdCompoundUniqueInput
    AND?: CustomStatusWhereInput | CustomStatusWhereInput[]
    OR?: CustomStatusWhereInput[]
    NOT?: CustomStatusWhereInput | CustomStatusWhereInput[]
    name?: StringFilter<"CustomStatus"> | string
    color?: StringFilter<"CustomStatus"> | string
    description?: StringNullableFilter<"CustomStatus"> | string | null
    isActive?: BoolFilter<"CustomStatus"> | boolean
    order?: IntFilter<"CustomStatus"> | number
    createdAt?: DateTimeFilter<"CustomStatus"> | Date | string
    updatedAt?: DateTimeFilter<"CustomStatus"> | Date | string
    officeId?: StringFilter<"CustomStatus"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    conversationStatuses?: ConversationCustomStatusListRelationFilter
  }, "id" | "name_officeId">

  export type CustomStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    _count?: CustomStatusCountOrderByAggregateInput
    _avg?: CustomStatusAvgOrderByAggregateInput
    _max?: CustomStatusMaxOrderByAggregateInput
    _min?: CustomStatusMinOrderByAggregateInput
    _sum?: CustomStatusSumOrderByAggregateInput
  }

  export type CustomStatusScalarWhereWithAggregatesInput = {
    AND?: CustomStatusScalarWhereWithAggregatesInput | CustomStatusScalarWhereWithAggregatesInput[]
    OR?: CustomStatusScalarWhereWithAggregatesInput[]
    NOT?: CustomStatusScalarWhereWithAggregatesInput | CustomStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomStatus"> | string
    name?: StringWithAggregatesFilter<"CustomStatus"> | string
    color?: StringWithAggregatesFilter<"CustomStatus"> | string
    description?: StringNullableWithAggregatesFilter<"CustomStatus"> | string | null
    isActive?: BoolWithAggregatesFilter<"CustomStatus"> | boolean
    order?: IntWithAggregatesFilter<"CustomStatus"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomStatus"> | Date | string
    officeId?: StringWithAggregatesFilter<"CustomStatus"> | string
  }

  export type ConversationCustomStatusWhereInput = {
    AND?: ConversationCustomStatusWhereInput | ConversationCustomStatusWhereInput[]
    OR?: ConversationCustomStatusWhereInput[]
    NOT?: ConversationCustomStatusWhereInput | ConversationCustomStatusWhereInput[]
    id?: StringFilter<"ConversationCustomStatus"> | string
    createdAt?: DateTimeFilter<"ConversationCustomStatus"> | Date | string
    conversationId?: StringFilter<"ConversationCustomStatus"> | string
    customStatusId?: StringFilter<"ConversationCustomStatus"> | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    customStatus?: XOR<CustomStatusScalarRelationFilter, CustomStatusWhereInput>
  }

  export type ConversationCustomStatusOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    customStatusId?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    customStatus?: CustomStatusOrderByWithRelationInput
  }

  export type ConversationCustomStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_customStatusId?: ConversationCustomStatusConversationIdCustomStatusIdCompoundUniqueInput
    AND?: ConversationCustomStatusWhereInput | ConversationCustomStatusWhereInput[]
    OR?: ConversationCustomStatusWhereInput[]
    NOT?: ConversationCustomStatusWhereInput | ConversationCustomStatusWhereInput[]
    createdAt?: DateTimeFilter<"ConversationCustomStatus"> | Date | string
    conversationId?: StringFilter<"ConversationCustomStatus"> | string
    customStatusId?: StringFilter<"ConversationCustomStatus"> | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    customStatus?: XOR<CustomStatusScalarRelationFilter, CustomStatusWhereInput>
  }, "id" | "conversationId_customStatusId">

  export type ConversationCustomStatusOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    customStatusId?: SortOrder
    _count?: ConversationCustomStatusCountOrderByAggregateInput
    _max?: ConversationCustomStatusMaxOrderByAggregateInput
    _min?: ConversationCustomStatusMinOrderByAggregateInput
  }

  export type ConversationCustomStatusScalarWhereWithAggregatesInput = {
    AND?: ConversationCustomStatusScalarWhereWithAggregatesInput | ConversationCustomStatusScalarWhereWithAggregatesInput[]
    OR?: ConversationCustomStatusScalarWhereWithAggregatesInput[]
    NOT?: ConversationCustomStatusScalarWhereWithAggregatesInput | ConversationCustomStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationCustomStatus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConversationCustomStatus"> | Date | string
    conversationId?: StringWithAggregatesFilter<"ConversationCustomStatus"> | string
    customStatusId?: StringWithAggregatesFilter<"ConversationCustomStatus"> | string
  }

  export type AiAgentWhereInput = {
    AND?: AiAgentWhereInput | AiAgentWhereInput[]
    OR?: AiAgentWhereInput[]
    NOT?: AiAgentWhereInput | AiAgentWhereInput[]
    id?: StringFilter<"AiAgent"> | string
    name?: StringFilter<"AiAgent"> | string
    type?: EnumAgentTypeFilter<"AiAgent"> | $Enums.AgentType
    prompt?: StringFilter<"AiAgent"> | string
    model?: StringFilter<"AiAgent"> | string
    provider?: EnumAIProviderFilter<"AiAgent"> | $Enums.AIProvider
    aiModel?: EnumAIModelFilter<"AiAgent"> | $Enums.AIModel
    temperature?: FloatFilter<"AiAgent"> | number
    maxTokens?: IntFilter<"AiAgent"> | number
    isActive?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
    officeId?: StringFilter<"AiAgent"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    whatsappConversations?: WhatsAppConversationListRelationFilter
  }

  export type AiAgentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    aiModel?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    office?: OfficeOrderByWithRelationInput
    whatsappConversations?: WhatsAppConversationOrderByRelationAggregateInput
  }

  export type AiAgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiAgentWhereInput | AiAgentWhereInput[]
    OR?: AiAgentWhereInput[]
    NOT?: AiAgentWhereInput | AiAgentWhereInput[]
    name?: StringFilter<"AiAgent"> | string
    type?: EnumAgentTypeFilter<"AiAgent"> | $Enums.AgentType
    prompt?: StringFilter<"AiAgent"> | string
    model?: StringFilter<"AiAgent"> | string
    provider?: EnumAIProviderFilter<"AiAgent"> | $Enums.AIProvider
    aiModel?: EnumAIModelFilter<"AiAgent"> | $Enums.AIModel
    temperature?: FloatFilter<"AiAgent"> | number
    maxTokens?: IntFilter<"AiAgent"> | number
    isActive?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
    officeId?: StringFilter<"AiAgent"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    whatsappConversations?: WhatsAppConversationListRelationFilter
  }, "id">

  export type AiAgentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    aiModel?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    _count?: AiAgentCountOrderByAggregateInput
    _avg?: AiAgentAvgOrderByAggregateInput
    _max?: AiAgentMaxOrderByAggregateInput
    _min?: AiAgentMinOrderByAggregateInput
    _sum?: AiAgentSumOrderByAggregateInput
  }

  export type AiAgentScalarWhereWithAggregatesInput = {
    AND?: AiAgentScalarWhereWithAggregatesInput | AiAgentScalarWhereWithAggregatesInput[]
    OR?: AiAgentScalarWhereWithAggregatesInput[]
    NOT?: AiAgentScalarWhereWithAggregatesInput | AiAgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiAgent"> | string
    name?: StringWithAggregatesFilter<"AiAgent"> | string
    type?: EnumAgentTypeWithAggregatesFilter<"AiAgent"> | $Enums.AgentType
    prompt?: StringWithAggregatesFilter<"AiAgent"> | string
    model?: StringWithAggregatesFilter<"AiAgent"> | string
    provider?: EnumAIProviderWithAggregatesFilter<"AiAgent"> | $Enums.AIProvider
    aiModel?: EnumAIModelWithAggregatesFilter<"AiAgent"> | $Enums.AIModel
    temperature?: FloatWithAggregatesFilter<"AiAgent"> | number
    maxTokens?: IntWithAggregatesFilter<"AiAgent"> | number
    isActive?: BoolWithAggregatesFilter<"AiAgent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiAgent"> | Date | string
    officeId?: StringWithAggregatesFilter<"AiAgent"> | string
  }

  export type AIProviderConfigWhereInput = {
    AND?: AIProviderConfigWhereInput | AIProviderConfigWhereInput[]
    OR?: AIProviderConfigWhereInput[]
    NOT?: AIProviderConfigWhereInput | AIProviderConfigWhereInput[]
    id?: StringFilter<"AIProviderConfig"> | string
    provider?: EnumAIProviderFilter<"AIProviderConfig"> | $Enums.AIProvider
    apiKey?: StringFilter<"AIProviderConfig"> | string
    isActive?: BoolFilter<"AIProviderConfig"> | boolean
    createdAt?: DateTimeFilter<"AIProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIProviderConfig"> | Date | string
    officeId?: StringFilter<"AIProviderConfig"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
  }

  export type AIProviderConfigOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    office?: OfficeOrderByWithRelationInput
  }

  export type AIProviderConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    officeId_provider?: AIProviderConfigOfficeIdProviderCompoundUniqueInput
    AND?: AIProviderConfigWhereInput | AIProviderConfigWhereInput[]
    OR?: AIProviderConfigWhereInput[]
    NOT?: AIProviderConfigWhereInput | AIProviderConfigWhereInput[]
    provider?: EnumAIProviderFilter<"AIProviderConfig"> | $Enums.AIProvider
    apiKey?: StringFilter<"AIProviderConfig"> | string
    isActive?: BoolFilter<"AIProviderConfig"> | boolean
    createdAt?: DateTimeFilter<"AIProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIProviderConfig"> | Date | string
    officeId?: StringFilter<"AIProviderConfig"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
  }, "id" | "officeId_provider">

  export type AIProviderConfigOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    _count?: AIProviderConfigCountOrderByAggregateInput
    _max?: AIProviderConfigMaxOrderByAggregateInput
    _min?: AIProviderConfigMinOrderByAggregateInput
  }

  export type AIProviderConfigScalarWhereWithAggregatesInput = {
    AND?: AIProviderConfigScalarWhereWithAggregatesInput | AIProviderConfigScalarWhereWithAggregatesInput[]
    OR?: AIProviderConfigScalarWhereWithAggregatesInput[]
    NOT?: AIProviderConfigScalarWhereWithAggregatesInput | AIProviderConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIProviderConfig"> | string
    provider?: EnumAIProviderWithAggregatesFilter<"AIProviderConfig"> | $Enums.AIProvider
    apiKey?: StringWithAggregatesFilter<"AIProviderConfig"> | string
    isActive?: BoolWithAggregatesFilter<"AIProviderConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIProviderConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIProviderConfig"> | Date | string
    officeId?: StringWithAggregatesFilter<"AIProviderConfig"> | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    mimeType?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    url?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    clientId?: StringFilter<"Document"> | string
    officeId?: StringFilter<"Document"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
    client?: ClientOrderByWithRelationInput
    office?: OfficeOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    name?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    mimeType?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    url?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    clientId?: StringFilter<"Document"> | string
    officeId?: StringFilter<"Document"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    originalName?: StringWithAggregatesFilter<"Document"> | string
    mimeType?: StringWithAggregatesFilter<"Document"> | string
    size?: IntWithAggregatesFilter<"Document"> | number
    url?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    clientId?: StringWithAggregatesFilter<"Document"> | string
    officeId?: StringWithAggregatesFilter<"Document"> | string
  }

  export type ToolWhereInput = {
    AND?: ToolWhereInput | ToolWhereInput[]
    OR?: ToolWhereInput[]
    NOT?: ToolWhereInput | ToolWhereInput[]
    id?: StringFilter<"Tool"> | string
    name?: StringFilter<"Tool"> | string
    description?: StringFilter<"Tool"> | string
    webhookUrl?: StringFilter<"Tool"> | string
    isActive?: BoolFilter<"Tool"> | boolean
    createdAt?: DateTimeFilter<"Tool"> | Date | string
    updatedAt?: DateTimeFilter<"Tool"> | Date | string
    officeId?: StringFilter<"Tool"> | string
    createdById?: StringFilter<"Tool"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    executions?: ToolExecutionListRelationFilter
  }

  export type ToolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
    office?: OfficeOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    executions?: ToolExecutionOrderByRelationAggregateInput
  }

  export type ToolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ToolWhereInput | ToolWhereInput[]
    OR?: ToolWhereInput[]
    NOT?: ToolWhereInput | ToolWhereInput[]
    name?: StringFilter<"Tool"> | string
    description?: StringFilter<"Tool"> | string
    webhookUrl?: StringFilter<"Tool"> | string
    isActive?: BoolFilter<"Tool"> | boolean
    createdAt?: DateTimeFilter<"Tool"> | Date | string
    updatedAt?: DateTimeFilter<"Tool"> | Date | string
    officeId?: StringFilter<"Tool"> | string
    createdById?: StringFilter<"Tool"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    executions?: ToolExecutionListRelationFilter
  }, "id">

  export type ToolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
    _count?: ToolCountOrderByAggregateInput
    _max?: ToolMaxOrderByAggregateInput
    _min?: ToolMinOrderByAggregateInput
  }

  export type ToolScalarWhereWithAggregatesInput = {
    AND?: ToolScalarWhereWithAggregatesInput | ToolScalarWhereWithAggregatesInput[]
    OR?: ToolScalarWhereWithAggregatesInput[]
    NOT?: ToolScalarWhereWithAggregatesInput | ToolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tool"> | string
    name?: StringWithAggregatesFilter<"Tool"> | string
    description?: StringWithAggregatesFilter<"Tool"> | string
    webhookUrl?: StringWithAggregatesFilter<"Tool"> | string
    isActive?: BoolWithAggregatesFilter<"Tool"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tool"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tool"> | Date | string
    officeId?: StringWithAggregatesFilter<"Tool"> | string
    createdById?: StringWithAggregatesFilter<"Tool"> | string
  }

  export type ToolExecutionWhereInput = {
    AND?: ToolExecutionWhereInput | ToolExecutionWhereInput[]
    OR?: ToolExecutionWhereInput[]
    NOT?: ToolExecutionWhereInput | ToolExecutionWhereInput[]
    id?: StringFilter<"ToolExecution"> | string
    requestId?: StringFilter<"ToolExecution"> | string
    description?: StringFilter<"ToolExecution"> | string
    status?: EnumToolExecutionStatusFilter<"ToolExecution"> | $Enums.ToolExecutionStatus
    requestData?: JsonNullableFilter<"ToolExecution">
    responseData?: JsonNullableFilter<"ToolExecution">
    errorMessage?: StringNullableFilter<"ToolExecution"> | string | null
    startedAt?: DateTimeFilter<"ToolExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"ToolExecution"> | Date | string | null
    conversationId?: StringNullableFilter<"ToolExecution"> | string | null
    agentId?: StringNullableFilter<"ToolExecution"> | string | null
    toolId?: StringFilter<"ToolExecution"> | string
    tool?: XOR<ToolScalarRelationFilter, ToolWhereInput>
    whatsappMessages?: WhatsAppMessageListRelationFilter
  }

  export type ToolExecutionOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    conversationId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    toolId?: SortOrder
    tool?: ToolOrderByWithRelationInput
    whatsappMessages?: WhatsAppMessageOrderByRelationAggregateInput
  }

  export type ToolExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requestId?: string
    AND?: ToolExecutionWhereInput | ToolExecutionWhereInput[]
    OR?: ToolExecutionWhereInput[]
    NOT?: ToolExecutionWhereInput | ToolExecutionWhereInput[]
    description?: StringFilter<"ToolExecution"> | string
    status?: EnumToolExecutionStatusFilter<"ToolExecution"> | $Enums.ToolExecutionStatus
    requestData?: JsonNullableFilter<"ToolExecution">
    responseData?: JsonNullableFilter<"ToolExecution">
    errorMessage?: StringNullableFilter<"ToolExecution"> | string | null
    startedAt?: DateTimeFilter<"ToolExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"ToolExecution"> | Date | string | null
    conversationId?: StringNullableFilter<"ToolExecution"> | string | null
    agentId?: StringNullableFilter<"ToolExecution"> | string | null
    toolId?: StringFilter<"ToolExecution"> | string
    tool?: XOR<ToolScalarRelationFilter, ToolWhereInput>
    whatsappMessages?: WhatsAppMessageListRelationFilter
  }, "id" | "requestId">

  export type ToolExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    conversationId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    toolId?: SortOrder
    _count?: ToolExecutionCountOrderByAggregateInput
    _max?: ToolExecutionMaxOrderByAggregateInput
    _min?: ToolExecutionMinOrderByAggregateInput
  }

  export type ToolExecutionScalarWhereWithAggregatesInput = {
    AND?: ToolExecutionScalarWhereWithAggregatesInput | ToolExecutionScalarWhereWithAggregatesInput[]
    OR?: ToolExecutionScalarWhereWithAggregatesInput[]
    NOT?: ToolExecutionScalarWhereWithAggregatesInput | ToolExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ToolExecution"> | string
    requestId?: StringWithAggregatesFilter<"ToolExecution"> | string
    description?: StringWithAggregatesFilter<"ToolExecution"> | string
    status?: EnumToolExecutionStatusWithAggregatesFilter<"ToolExecution"> | $Enums.ToolExecutionStatus
    requestData?: JsonNullableWithAggregatesFilter<"ToolExecution">
    responseData?: JsonNullableWithAggregatesFilter<"ToolExecution">
    errorMessage?: StringNullableWithAggregatesFilter<"ToolExecution"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"ToolExecution"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ToolExecution"> | Date | string | null
    conversationId?: StringNullableWithAggregatesFilter<"ToolExecution"> | string | null
    agentId?: StringNullableWithAggregatesFilter<"ToolExecution"> | string | null
    toolId?: StringWithAggregatesFilter<"ToolExecution"> | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    description?: StringNullableFilter<"Webhook"> | string | null
    retryCount?: IntFilter<"Webhook"> | number
    timeoutMs?: IntFilter<"Webhook"> | number
    headers?: JsonNullableFilter<"Webhook">
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    officeId?: StringFilter<"Webhook"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    executions?: WebhookExecutionListRelationFilter
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    timeoutMs?: SortOrder
    headers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    office?: OfficeOrderByWithRelationInput
    executions?: WebhookExecutionOrderByRelationAggregateInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    description?: StringNullableFilter<"Webhook"> | string | null
    retryCount?: IntFilter<"Webhook"> | number
    timeoutMs?: IntFilter<"Webhook"> | number
    headers?: JsonNullableFilter<"Webhook">
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    officeId?: StringFilter<"Webhook"> | string
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
    executions?: WebhookExecutionListRelationFilter
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrderInput | SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    timeoutMs?: SortOrder
    headers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    name?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    secret?: StringNullableWithAggregatesFilter<"Webhook"> | string | null
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    description?: StringNullableWithAggregatesFilter<"Webhook"> | string | null
    retryCount?: IntWithAggregatesFilter<"Webhook"> | number
    timeoutMs?: IntWithAggregatesFilter<"Webhook"> | number
    headers?: JsonNullableWithAggregatesFilter<"Webhook">
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    officeId?: StringWithAggregatesFilter<"Webhook"> | string
  }

  export type WebhookExecutionWhereInput = {
    AND?: WebhookExecutionWhereInput | WebhookExecutionWhereInput[]
    OR?: WebhookExecutionWhereInput[]
    NOT?: WebhookExecutionWhereInput | WebhookExecutionWhereInput[]
    id?: StringFilter<"WebhookExecution"> | string
    status?: StringFilter<"WebhookExecution"> | string
    requestBody?: JsonFilter<"WebhookExecution">
    responseBody?: JsonNullableFilter<"WebhookExecution">
    responseCode?: IntNullableFilter<"WebhookExecution"> | number | null
    executedAt?: DateTimeFilter<"WebhookExecution"> | Date | string
    attempt?: IntFilter<"WebhookExecution"> | number
    error?: StringNullableFilter<"WebhookExecution"> | string | null
    webhookId?: StringFilter<"WebhookExecution"> | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }

  export type WebhookExecutionOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseCode?: SortOrderInput | SortOrder
    executedAt?: SortOrder
    attempt?: SortOrder
    error?: SortOrderInput | SortOrder
    webhookId?: SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookExecutionWhereInput | WebhookExecutionWhereInput[]
    OR?: WebhookExecutionWhereInput[]
    NOT?: WebhookExecutionWhereInput | WebhookExecutionWhereInput[]
    status?: StringFilter<"WebhookExecution"> | string
    requestBody?: JsonFilter<"WebhookExecution">
    responseBody?: JsonNullableFilter<"WebhookExecution">
    responseCode?: IntNullableFilter<"WebhookExecution"> | number | null
    executedAt?: DateTimeFilter<"WebhookExecution"> | Date | string
    attempt?: IntFilter<"WebhookExecution"> | number
    error?: StringNullableFilter<"WebhookExecution"> | string | null
    webhookId?: StringFilter<"WebhookExecution"> | string
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseCode?: SortOrderInput | SortOrder
    executedAt?: SortOrder
    attempt?: SortOrder
    error?: SortOrderInput | SortOrder
    webhookId?: SortOrder
    _count?: WebhookExecutionCountOrderByAggregateInput
    _avg?: WebhookExecutionAvgOrderByAggregateInput
    _max?: WebhookExecutionMaxOrderByAggregateInput
    _min?: WebhookExecutionMinOrderByAggregateInput
    _sum?: WebhookExecutionSumOrderByAggregateInput
  }

  export type WebhookExecutionScalarWhereWithAggregatesInput = {
    AND?: WebhookExecutionScalarWhereWithAggregatesInput | WebhookExecutionScalarWhereWithAggregatesInput[]
    OR?: WebhookExecutionScalarWhereWithAggregatesInput[]
    NOT?: WebhookExecutionScalarWhereWithAggregatesInput | WebhookExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookExecution"> | string
    status?: StringWithAggregatesFilter<"WebhookExecution"> | string
    requestBody?: JsonWithAggregatesFilter<"WebhookExecution">
    responseBody?: JsonNullableWithAggregatesFilter<"WebhookExecution">
    responseCode?: IntNullableWithAggregatesFilter<"WebhookExecution"> | number | null
    executedAt?: DateTimeWithAggregatesFilter<"WebhookExecution"> | Date | string
    attempt?: IntWithAggregatesFilter<"WebhookExecution"> | number
    error?: StringNullableWithAggregatesFilter<"WebhookExecution"> | string | null
    webhookId?: StringWithAggregatesFilter<"WebhookExecution"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    officeId?: StringFilter<"AuditLog"> | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    officeId?: SortOrder
    user?: UserOrderByWithRelationInput
    office?: OfficeOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    officeId?: StringFilter<"AuditLog"> | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    office?: XOR<OfficeScalarRelationFilter, OfficeWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    officeId?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    officeId?: StringWithAggregatesFilter<"AuditLog"> | string
  }

  export type GlobalConfigWhereInput = {
    AND?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    OR?: GlobalConfigWhereInput[]
    NOT?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    id?: StringFilter<"GlobalConfig"> | string
    key?: StringFilter<"GlobalConfig"> | string
    value?: JsonFilter<"GlobalConfig">
    createdAt?: DateTimeFilter<"GlobalConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalConfig"> | Date | string
  }

  export type GlobalConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    OR?: GlobalConfigWhereInput[]
    NOT?: GlobalConfigWhereInput | GlobalConfigWhereInput[]
    value?: JsonFilter<"GlobalConfig">
    createdAt?: DateTimeFilter<"GlobalConfig"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalConfig"> | Date | string
  }, "id" | "key">

  export type GlobalConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlobalConfigCountOrderByAggregateInput
    _max?: GlobalConfigMaxOrderByAggregateInput
    _min?: GlobalConfigMinOrderByAggregateInput
  }

  export type GlobalConfigScalarWhereWithAggregatesInput = {
    AND?: GlobalConfigScalarWhereWithAggregatesInput | GlobalConfigScalarWhereWithAggregatesInput[]
    OR?: GlobalConfigScalarWhereWithAggregatesInput[]
    NOT?: GlobalConfigScalarWhereWithAggregatesInput | GlobalConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlobalConfig"> | string
    key?: StringWithAggregatesFilter<"GlobalConfig"> | string
    value?: JsonWithAggregatesFilter<"GlobalConfig">
    createdAt?: DateTimeWithAggregatesFilter<"GlobalConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalConfig"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfficeCreateInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeCreateManyInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfficeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfficeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappConfigCreateInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappConfigsInput
    conversations?: ConversationCreateNestedManyWithoutWhatsappConfigInput
    messages?: MessageCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigUncheckedCreateInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutWhatsappConfigInput
    messages?: MessageUncheckedCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappConfigsNestedInput
    conversations?: ConversationUpdateManyWithoutWhatsappConfigNestedInput
    messages?: MessageUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type WhatsappConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutWhatsappConfigNestedInput
    messages?: MessageUncheckedUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type WhatsappConfigCreateManyInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type WhatsappConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppInstanceCreateInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappInstancesInput
    createdBy: UserCreateNestedOneWithoutWhatsappInstancesCreatedInput
    contacts?: WhatsAppContactCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUncheckedCreateInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: WhatsAppContactUncheckedCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappInstancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutWhatsappInstancesCreatedNestedInput
    contacts?: WhatsAppContactUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: WhatsAppContactUncheckedUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceCreateManyInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppContactCreateInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutContactsInput
    client?: ClientCreateNestedOneWithoutWhatsappContactsInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactUncheckedCreateInput = {
    id?: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    clientId?: string | null
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutContactsNestedInput
    client?: ClientUpdateOneWithoutWhatsappContactsNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactCreateManyInput = {
    id?: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    clientId?: string | null
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppConversationCreateInput = {
    id?: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutConversationsInput
    contact: WhatsAppContactCreateNestedOneWithoutConversationsInput
    assignedUser?: UserCreateNestedOneWithoutWhatsappConversationsAssignedInput
    currentAgent?: AiAgentCreateNestedOneWithoutWhatsappConversationsInput
    messages?: WhatsAppMessageCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationUncheckedCreateInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutConversationsNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutConversationsNestedInput
    assignedUser?: UserUpdateOneWithoutWhatsappConversationsAssignedNestedInput
    currentAgent?: AiAgentUpdateOneWithoutWhatsappConversationsNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationCreateManyInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageCreateInput = {
    id?: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutMessagesInput
    conversation: WhatsAppConversationCreateNestedOneWithoutMessagesInput
    contact: WhatsAppContactCreateNestedOneWithoutMessagesInput
    toolExecution?: ToolExecutionCreateNestedOneWithoutWhatsappMessagesInput
  }

  export type WhatsAppMessageUncheckedCreateInput = {
    id?: string
    instanceId: string
    conversationId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: WhatsAppConversationUpdateOneRequiredWithoutMessagesNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutMessagesNestedInput
    toolExecution?: ToolExecutionUpdateOneWithoutWhatsappMessagesNestedInput
  }

  export type WhatsAppMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageCreateManyInput = {
    id?: string
    instanceId: string
    conversationId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportCreateInput = {
    id?: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutImportsInput
    contact: WhatsAppContactCreateNestedOneWithoutImportsInput
    uploadedBy: UserCreateNestedOneWithoutWhatsappImportsUploadedInput
  }

  export type WhatsAppImportUncheckedCreateInput = {
    id?: string
    instanceId: string
    contactId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    uploadedById: string
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutImportsNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutImportsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutWhatsappImportsUploadedNestedInput
  }

  export type WhatsAppImportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportCreateManyInput = {
    id?: string
    instanceId: string
    contactId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    uploadedById: string
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutClientsInput
    conversations?: ConversationCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    clientTags?: ClientTagCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutClientsNestedInput
    conversations?: ConversationUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUncheckedUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCreateInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    office: OfficeCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutMessagesInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutMessagesInput
    audioTranscription?: AudioTranscriptionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    userId?: string | null
    whatsappConfigId?: string | null
    audioTranscription?: AudioTranscriptionUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutMessagesNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutMessagesNestedInput
    audioTranscription?: AudioTranscriptionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    audioTranscription?: AudioTranscriptionUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    userId?: string | null
    whatsappConfigId?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AudioTranscriptionCreateInput = {
    id?: string
    originalText?: string | null
    provider: $Enums.TranscriptionProvider
    confidence?: number | null
    duration?: number | null
    language?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    message: MessageCreateNestedOneWithoutAudioTranscriptionInput
  }

  export type AudioTranscriptionUncheckedCreateInput = {
    id?: string
    originalText?: string | null
    provider: $Enums.TranscriptionProvider
    confidence?: number | null
    duration?: number | null
    language?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messageId: string
  }

  export type AudioTranscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAudioTranscriptionNestedInput
  }

  export type AudioTranscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type AudioTranscriptionCreateManyInput = {
    id?: string
    originalText?: string | null
    provider: $Enums.TranscriptionProvider
    confidence?: number | null
    duration?: number | null
    language?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messageId: string
  }

  export type AudioTranscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTranscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutTagsInput
    clientTags?: ClientTagCreateNestedManyWithoutTagInput
    conversationTags?: ConversationTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutTagInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutTagsNestedInput
    clientTags?: ClientTagUpdateManyWithoutTagNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    clientTags?: ClientTagUncheckedUpdateManyWithoutTagNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientTagCreateInput = {
    id?: string
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutClientTagsInput
    tag: TagCreateNestedOneWithoutClientTagsInput
  }

  export type ClientTagUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    clientId: string
    tagId: string
  }

  export type ClientTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutClientTagsNestedInput
  }

  export type ClientTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientTagCreateManyInput = {
    id?: string
    createdAt?: Date | string
    clientId: string
    tagId: string
  }

  export type ClientTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationTagCreateInput = {
    id?: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutConversationTagsInput
    tag: TagCreateNestedOneWithoutConversationTagsInput
  }

  export type ConversationTagUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
    tagId: string
  }

  export type ConversationTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutConversationTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutConversationTagsNestedInput
  }

  export type ConversationTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationTagCreateManyInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
    tagId: string
  }

  export type ConversationTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomStatusCreateInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutCustomStatusesInput
    conversationStatuses?: ConversationCustomStatusCreateNestedManyWithoutCustomStatusInput
  }

  export type CustomStatusUncheckedCreateInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversationStatuses?: ConversationCustomStatusUncheckedCreateNestedManyWithoutCustomStatusInput
  }

  export type CustomStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutCustomStatusesNestedInput
    conversationStatuses?: ConversationCustomStatusUpdateManyWithoutCustomStatusNestedInput
  }

  export type CustomStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversationStatuses?: ConversationCustomStatusUncheckedUpdateManyWithoutCustomStatusNestedInput
  }

  export type CustomStatusCreateManyInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type CustomStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCustomStatusCreateInput = {
    id?: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutConversationStatusInput
    customStatus: CustomStatusCreateNestedOneWithoutConversationStatusesInput
  }

  export type ConversationCustomStatusUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
    customStatusId: string
  }

  export type ConversationCustomStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutConversationStatusNestedInput
    customStatus?: CustomStatusUpdateOneRequiredWithoutConversationStatusesNestedInput
  }

  export type ConversationCustomStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    customStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCustomStatusCreateManyInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
    customStatusId: string
  }

  export type ConversationCustomStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCustomStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    customStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type AiAgentCreateInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutAiAgentsInput
    whatsappConversations?: WhatsAppConversationCreateNestedManyWithoutCurrentAgentInput
  }

  export type AiAgentUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    whatsappConversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutCurrentAgentInput
  }

  export type AiAgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutAiAgentsNestedInput
    whatsappConversations?: WhatsAppConversationUpdateManyWithoutCurrentAgentNestedInput
  }

  export type AiAgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    whatsappConversations?: WhatsAppConversationUncheckedUpdateManyWithoutCurrentAgentNestedInput
  }

  export type AiAgentCreateManyInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type AiAgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type AIProviderConfigCreateInput = {
    id?: string
    provider: $Enums.AIProvider
    apiKey: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutAiConfigsInput
  }

  export type AIProviderConfigUncheckedCreateInput = {
    id?: string
    provider: $Enums.AIProvider
    apiKey: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type AIProviderConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    apiKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutAiConfigsNestedInput
  }

  export type AIProviderConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    apiKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type AIProviderConfigCreateManyInput = {
    id?: string
    provider: $Enums.AIProvider
    apiKey: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type AIProviderConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    apiKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    apiKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutDocumentsInput
    office: OfficeCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutDocumentsNestedInput
    office?: OfficeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type ToolCreateInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutToolsInput
    createdBy: UserCreateNestedOneWithoutToolsCreatedInput
    executions?: ToolExecutionCreateNestedManyWithoutToolInput
  }

  export type ToolUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    createdById: string
    executions?: ToolExecutionUncheckedCreateNestedManyWithoutToolInput
  }

  export type ToolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutToolsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutToolsCreatedNestedInput
    executions?: ToolExecutionUpdateManyWithoutToolNestedInput
  }

  export type ToolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    executions?: ToolExecutionUncheckedUpdateManyWithoutToolNestedInput
  }

  export type ToolCreateManyInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    createdById: string
  }

  export type ToolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ToolExecutionCreateInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
    tool: ToolCreateNestedOneWithoutExecutionsInput
    whatsappMessages?: WhatsAppMessageCreateNestedManyWithoutToolExecutionInput
  }

  export type ToolExecutionUncheckedCreateInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
    toolId: string
    whatsappMessages?: WhatsAppMessageUncheckedCreateNestedManyWithoutToolExecutionInput
  }

  export type ToolExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tool?: ToolUpdateOneRequiredWithoutExecutionsNestedInput
    whatsappMessages?: WhatsAppMessageUpdateManyWithoutToolExecutionNestedInput
  }

  export type ToolExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    toolId?: StringFieldUpdateOperationsInput | string
    whatsappMessages?: WhatsAppMessageUncheckedUpdateManyWithoutToolExecutionNestedInput
  }

  export type ToolExecutionCreateManyInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
    toolId: string
  }

  export type ToolExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ToolExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    toolId?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookCreateInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWebhooksInput
    executions?: WebhookExecutionCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    executions?: WebhookExecutionUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWebhooksNestedInput
    executions?: WebhookExecutionUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    executions?: WebhookExecutionUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookExecutionCreateInput = {
    id?: string
    status: string
    requestBody: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: number | null
    executedAt?: Date | string
    attempt?: number
    error?: string | null
    webhook: WebhookCreateNestedOneWithoutExecutionsInput
  }

  export type WebhookExecutionUncheckedCreateInput = {
    id?: string
    status: string
    requestBody: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: number | null
    executedAt?: Date | string
    attempt?: number
    error?: string | null
    webhookId: string
  }

  export type WebhookExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestBody?: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: WebhookUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type WebhookExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestBody?: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    webhookId?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookExecutionCreateManyInput = {
    id?: string
    status: string
    requestBody: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: number | null
    executedAt?: Date | string
    attempt?: number
    error?: string | null
    webhookId: string
  }

  export type WebhookExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestBody?: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestBody?: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    webhookId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLogsInput
    office: OfficeCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    userId?: string | null
    officeId: string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogsNestedInput
    office?: OfficeUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    userId?: string | null
    officeId: string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type GlobalConfigCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalConfigCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type OfficeNullableScalarRelationFilter = {
    is?: OfficeWhereInput | null
    isNot?: OfficeWhereInput | null
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ToolListRelationFilter = {
    every?: ToolWhereInput
    some?: ToolWhereInput
    none?: ToolWhereInput
  }

  export type WhatsAppInstanceListRelationFilter = {
    every?: WhatsAppInstanceWhereInput
    some?: WhatsAppInstanceWhereInput
    none?: WhatsAppInstanceWhereInput
  }

  export type WhatsAppImportListRelationFilter = {
    every?: WhatsAppImportWhereInput
    some?: WhatsAppImportWhereInput
    none?: WhatsAppImportWhereInput
  }

  export type WhatsAppConversationListRelationFilter = {
    every?: WhatsAppConversationWhereInput
    some?: WhatsAppConversationWhereInput
    none?: WhatsAppConversationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ToolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppImportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type CustomStatusListRelationFilter = {
    every?: CustomStatusWhereInput
    some?: CustomStatusWhereInput
    none?: CustomStatusWhereInput
  }

  export type AiAgentListRelationFilter = {
    every?: AiAgentWhereInput
    some?: AiAgentWhereInput
    none?: AiAgentWhereInput
  }

  export type WhatsappConfigListRelationFilter = {
    every?: WhatsappConfigWhereInput
    some?: WhatsappConfigWhereInput
    none?: WhatsappConfigWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type WebhookListRelationFilter = {
    every?: WebhookWhereInput
    some?: WebhookWhereInput
    none?: WebhookWhereInput
  }

  export type AIProviderConfigListRelationFilter = {
    every?: AIProviderConfigWhereInput
    some?: AIProviderConfigWhereInput
    none?: AIProviderConfigWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiAgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsappConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIProviderConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfficeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfficeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfficeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfficeScalarRelationFilter = {
    is?: OfficeWhereInput
    isNot?: OfficeWhereInput
  }

  export type WhatsappConfigCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    phone?: SortOrder
    qrCode?: SortOrder
    isActive?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type WhatsappConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    phone?: SortOrder
    qrCode?: SortOrder
    isActive?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type WhatsappConfigMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    phone?: SortOrder
    qrCode?: SortOrder
    isActive?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type EnumWhatsAppInstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppInstanceStatus | EnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppInstanceStatusFilter<$PrismaModel> | $Enums.WhatsAppInstanceStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WhatsAppContactListRelationFilter = {
    every?: WhatsAppContactWhereInput
    some?: WhatsAppContactWhereInput
    none?: WhatsAppContactWhereInput
  }

  export type WhatsAppMessageListRelationFilter = {
    every?: WhatsAppMessageWhereInput
    some?: WhatsAppMessageWhereInput
    none?: WhatsAppMessageWhereInput
  }

  export type WhatsAppContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    webhookUrl?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
    connectionData?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    webhookUrl?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    webhookUrl?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWhatsAppInstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppInstanceStatus | EnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppInstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppInstanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppInstanceStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppInstanceStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WhatsAppInstanceScalarRelationFilter = {
    is?: WhatsAppInstanceWhereInput
    isNot?: WhatsAppInstanceWhereInput
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type WhatsAppContactInstanceIdRemoteJidCompoundUniqueInput = {
    instanceId: string
    remoteJid: string
  }

  export type WhatsAppContactCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    remoteJid?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    pushName?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    lastSeen?: SortOrder
    isBlocked?: SortOrder
    clientId?: SortOrder
    tags?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppContactMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    remoteJid?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    pushName?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    lastSeen?: SortOrder
    isBlocked?: SortOrder
    clientId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppContactMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    remoteJid?: SortOrder
    phoneNumber?: SortOrder
    name?: SortOrder
    pushName?: SortOrder
    profilePicUrl?: SortOrder
    isGroup?: SortOrder
    lastSeen?: SortOrder
    isBlocked?: SortOrder
    clientId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumWhatsAppConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppConversationStatus | EnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppConversationStatusFilter<$PrismaModel> | $Enums.WhatsAppConversationStatus
  }

  export type WhatsAppContactScalarRelationFilter = {
    is?: WhatsAppContactWhereInput
    isNot?: WhatsAppContactWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AiAgentNullableScalarRelationFilter = {
    is?: AiAgentWhereInput | null
    isNot?: AiAgentWhereInput | null
  }

  export type WhatsAppConversationInstanceIdRemoteJidCompoundUniqueInput = {
    instanceId: string
    remoteJid: string
  }

  export type WhatsAppConversationCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    title?: SortOrder
    isGroup?: SortOrder
    lastMessageId?: SortOrder
    lastMessageAt?: SortOrder
    unreadCount?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    aiEnabled?: SortOrder
    currentAgentId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppConversationAvgOrderByAggregateInput = {
    unreadCount?: SortOrder
  }

  export type WhatsAppConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    title?: SortOrder
    isGroup?: SortOrder
    lastMessageId?: SortOrder
    lastMessageAt?: SortOrder
    unreadCount?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    aiEnabled?: SortOrder
    currentAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppConversationMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    title?: SortOrder
    isGroup?: SortOrder
    lastMessageId?: SortOrder
    lastMessageAt?: SortOrder
    unreadCount?: SortOrder
    isArchived?: SortOrder
    isPinned?: SortOrder
    assignedUserId?: SortOrder
    status?: SortOrder
    aiEnabled?: SortOrder
    currentAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppConversationSumOrderByAggregateInput = {
    unreadCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumWhatsAppConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppConversationStatus | EnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppConversationStatusFilter<$PrismaModel>
  }

  export type EnumWhatsAppMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageType | EnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageTypeFilter<$PrismaModel> | $Enums.WhatsAppMessageType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumWhatsAppMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageStatus | EnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageStatusFilter<$PrismaModel> | $Enums.WhatsAppMessageStatus
  }

  export type WhatsAppConversationScalarRelationFilter = {
    is?: WhatsAppConversationWhereInput
    isNot?: WhatsAppConversationWhereInput
  }

  export type ToolExecutionNullableScalarRelationFilter = {
    is?: ToolExecutionWhereInput | null
    isNot?: ToolExecutionWhereInput | null
  }

  export type WhatsAppMessageInstanceIdMessageIdCompoundUniqueInput = {
    instanceId: string
    messageId: string
  }

  export type WhatsAppMessageCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    messageId?: SortOrder
    fromMe?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    quotedMessageId?: SortOrder
    mediaUrl?: SortOrder
    mediaSize?: SortOrder
    mimetype?: SortOrder
    fileName?: SortOrder
    caption?: SortOrder
    location?: SortOrder
    isForwarded?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    isEdited?: SortOrder
    aiResponse?: SortOrder
    toolExecutionId?: SortOrder
    importedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageAvgOrderByAggregateInput = {
    mediaSize?: SortOrder
  }

  export type WhatsAppMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    messageId?: SortOrder
    fromMe?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    quotedMessageId?: SortOrder
    mediaUrl?: SortOrder
    mediaSize?: SortOrder
    mimetype?: SortOrder
    fileName?: SortOrder
    caption?: SortOrder
    isForwarded?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    isEdited?: SortOrder
    aiResponse?: SortOrder
    toolExecutionId?: SortOrder
    importedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    remoteJid?: SortOrder
    messageId?: SortOrder
    fromMe?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    quotedMessageId?: SortOrder
    mediaUrl?: SortOrder
    mediaSize?: SortOrder
    mimetype?: SortOrder
    fileName?: SortOrder
    caption?: SortOrder
    isForwarded?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    isEdited?: SortOrder
    aiResponse?: SortOrder
    toolExecutionId?: SortOrder
    importedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageSumOrderByAggregateInput = {
    mediaSize?: SortOrder
  }

  export type EnumWhatsAppMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageType | EnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppMessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppMessageTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumWhatsAppMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageStatus | EnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppMessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppMessageStatusFilter<$PrismaModel>
  }

  export type EnumWhatsAppImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppImportStatus | EnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppImportStatusFilter<$PrismaModel> | $Enums.WhatsAppImportStatus
  }

  export type WhatsAppImportCountOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalMessages?: SortOrder
    importedMessages?: SortOrder
    failedMessages?: SortOrder
    mediaFiles?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    uploadedById?: SortOrder
    importedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppImportAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    totalMessages?: SortOrder
    importedMessages?: SortOrder
    failedMessages?: SortOrder
  }

  export type WhatsAppImportMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalMessages?: SortOrder
    importedMessages?: SortOrder
    failedMessages?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    uploadedById?: SortOrder
    importedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppImportMinOrderByAggregateInput = {
    id?: SortOrder
    instanceId?: SortOrder
    contactId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    totalMessages?: SortOrder
    importedMessages?: SortOrder
    failedMessages?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    uploadedById?: SortOrder
    importedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppImportSumOrderByAggregateInput = {
    fileSize?: SortOrder
    totalMessages?: SortOrder
    importedMessages?: SortOrder
    failedMessages?: SortOrder
  }

  export type EnumWhatsAppImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppImportStatus | EnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppImportStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppImportStatusFilter<$PrismaModel>
  }

  export type ClientTagListRelationFilter = {
    every?: ClientTagWhereInput
    some?: ClientTagWhereInput
    none?: ClientTagWhereInput
  }

  export type ClientTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    document?: SortOrder
    notes?: SortOrder
    isLead?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    document?: SortOrder
    notes?: SortOrder
    isLead?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    document?: SortOrder
    notes?: SortOrder
    isLead?: SortOrder
    dateOfBirth?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type EnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type EnumAgentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgentTypeNullableFilter<$PrismaModel> | $Enums.AgentType | null
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type WhatsappConfigNullableScalarRelationFilter = {
    is?: WhatsappConfigWhereInput | null
    isNot?: WhatsappConfigWhereInput | null
  }

  export type ConversationTagListRelationFilter = {
    every?: ConversationTagWhereInput
    some?: ConversationTagWhereInput
    none?: ConversationTagWhereInput
  }

  export type ConversationCustomStatusListRelationFilter = {
    every?: ConversationCustomStatusWhereInput
    some?: ConversationCustomStatusWhereInput
    none?: ConversationCustomStatusWhereInput
  }

  export type ConversationTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCustomStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    metadata?: SortOrder
    currentAgentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
    createdBy?: SortOrder
    assignedTo?: SortOrder
    whatsappConfigId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    currentAgentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
    createdBy?: SortOrder
    assignedTo?: SortOrder
    whatsappConfigId?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    currentAgentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
    createdBy?: SortOrder
    assignedTo?: SortOrder
    whatsappConfigId?: SortOrder
  }

  export type EnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type EnumAgentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeNullableFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type AudioTranscriptionNullableScalarRelationFilter = {
    is?: AudioTranscriptionWhereInput | null
    isNot?: AudioTranscriptionWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isFromClient?: SortOrder
    isFromAI?: SortOrder
    metadata?: SortOrder
    externalId?: SortOrder
    mediaUrl?: SortOrder
    transcription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    whatsappConfigId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isFromClient?: SortOrder
    isFromAI?: SortOrder
    externalId?: SortOrder
    mediaUrl?: SortOrder
    transcription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    whatsappConfigId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isFromClient?: SortOrder
    isFromAI?: SortOrder
    externalId?: SortOrder
    mediaUrl?: SortOrder
    transcription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    whatsappConfigId?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumTranscriptionProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderFilter<$PrismaModel> | $Enums.TranscriptionProvider
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type AudioTranscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    originalText?: SortOrder
    provider?: SortOrder
    confidence?: SortOrder
    duration?: SortOrder
    language?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messageId?: SortOrder
  }

  export type AudioTranscriptionAvgOrderByAggregateInput = {
    confidence?: SortOrder
    duration?: SortOrder
  }

  export type AudioTranscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    originalText?: SortOrder
    provider?: SortOrder
    confidence?: SortOrder
    duration?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messageId?: SortOrder
  }

  export type AudioTranscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    originalText?: SortOrder
    provider?: SortOrder
    confidence?: SortOrder
    duration?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messageId?: SortOrder
  }

  export type AudioTranscriptionSumOrderByAggregateInput = {
    confidence?: SortOrder
    duration?: SortOrder
  }

  export type EnumTranscriptionProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptionProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
    _max?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type TagNameOfficeIdCompoundUniqueInput = {
    name: string
    officeId: string
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ClientTagClientIdTagIdCompoundUniqueInput = {
    clientId: string
    tagId: string
  }

  export type ClientTagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    clientId?: SortOrder
    tagId?: SortOrder
  }

  export type ClientTagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    clientId?: SortOrder
    tagId?: SortOrder
  }

  export type ClientTagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    clientId?: SortOrder
    tagId?: SortOrder
  }

  export type ConversationTagConversationIdTagIdCompoundUniqueInput = {
    conversationId: string
    tagId: string
  }

  export type ConversationTagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    tagId?: SortOrder
  }

  export type ConversationTagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    tagId?: SortOrder
  }

  export type ConversationTagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    tagId?: SortOrder
  }

  export type CustomStatusNameOfficeIdCompoundUniqueInput = {
    name: string
    officeId: string
  }

  export type CustomStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type CustomStatusAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CustomStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type CustomStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type CustomStatusSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CustomStatusScalarRelationFilter = {
    is?: CustomStatusWhereInput
    isNot?: CustomStatusWhereInput
  }

  export type ConversationCustomStatusConversationIdCustomStatusIdCompoundUniqueInput = {
    conversationId: string
    customStatusId: string
  }

  export type ConversationCustomStatusCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    customStatusId?: SortOrder
  }

  export type ConversationCustomStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    customStatusId?: SortOrder
  }

  export type ConversationCustomStatusMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    customStatusId?: SortOrder
  }

  export type EnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type EnumAIProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AIProvider | EnumAIProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAIProviderFilter<$PrismaModel> | $Enums.AIProvider
  }

  export type EnumAIModelFilter<$PrismaModel = never> = {
    equals?: $Enums.AIModel | EnumAIModelFieldRefInput<$PrismaModel>
    in?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAIModelFilter<$PrismaModel> | $Enums.AIModel
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AiAgentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    aiModel?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type AiAgentAvgOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type AiAgentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    aiModel?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type AiAgentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    prompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    aiModel?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type AiAgentSumOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type EnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type EnumAIProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIProvider | EnumAIProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAIProviderWithAggregatesFilter<$PrismaModel> | $Enums.AIProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIProviderFilter<$PrismaModel>
    _max?: NestedEnumAIProviderFilter<$PrismaModel>
  }

  export type EnumAIModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIModel | EnumAIModelFieldRefInput<$PrismaModel>
    in?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAIModelWithAggregatesFilter<$PrismaModel> | $Enums.AIModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIModelFilter<$PrismaModel>
    _max?: NestedEnumAIModelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AIProviderConfigOfficeIdProviderCompoundUniqueInput = {
    officeId: string
    provider: $Enums.AIProvider
  }

  export type AIProviderConfigCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type AIProviderConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type AIProviderConfigMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    officeId?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type ToolExecutionListRelationFilter = {
    every?: ToolExecutionWhereInput
    some?: ToolExecutionWhereInput
    none?: ToolExecutionWhereInput
  }

  export type ToolExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ToolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
  }

  export type ToolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
  }

  export type ToolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    webhookUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumToolExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ToolExecutionStatus | EnumToolExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToolExecutionStatusFilter<$PrismaModel> | $Enums.ToolExecutionStatus
  }

  export type ToolScalarRelationFilter = {
    is?: ToolWhereInput
    isNot?: ToolWhereInput
  }

  export type ToolExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    conversationId?: SortOrder
    agentId?: SortOrder
    toolId?: SortOrder
  }

  export type ToolExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    conversationId?: SortOrder
    agentId?: SortOrder
    toolId?: SortOrder
  }

  export type ToolExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    description?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    conversationId?: SortOrder
    agentId?: SortOrder
    toolId?: SortOrder
  }

  export type EnumToolExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ToolExecutionStatus | EnumToolExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToolExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ToolExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumToolExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumToolExecutionStatusFilter<$PrismaModel>
  }

  export type WebhookExecutionListRelationFilter = {
    every?: WebhookExecutionWhereInput
    some?: WebhookExecutionWhereInput
    none?: WebhookExecutionWhereInput
  }

  export type WebhookExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    retryCount?: SortOrder
    timeoutMs?: SortOrder
    headers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    retryCount?: SortOrder
    timeoutMs?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    retryCount?: SortOrder
    timeoutMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    retryCount?: SortOrder
    timeoutMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeId?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    retryCount?: SortOrder
    timeoutMs?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WebhookScalarRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    requestBody?: SortOrder
    responseBody?: SortOrder
    responseCode?: SortOrder
    executedAt?: SortOrder
    attempt?: SortOrder
    error?: SortOrder
    webhookId?: SortOrder
  }

  export type WebhookExecutionAvgOrderByAggregateInput = {
    responseCode?: SortOrder
    attempt?: SortOrder
  }

  export type WebhookExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    responseCode?: SortOrder
    executedAt?: SortOrder
    attempt?: SortOrder
    error?: SortOrder
    webhookId?: SortOrder
  }

  export type WebhookExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    responseCode?: SortOrder
    executedAt?: SortOrder
    attempt?: SortOrder
    error?: SortOrder
    webhookId?: SortOrder
  }

  export type WebhookExecutionSumOrderByAggregateInput = {
    responseCode?: SortOrder
    attempt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    officeId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    officeId?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    officeId?: SortOrder
  }

  export type GlobalConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfficeCreateNestedOneWithoutUsersInput = {
    create?: XOR<OfficeCreateWithoutUsersInput, OfficeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutUsersInput
    connect?: OfficeWhereUniqueInput
  }

  export type ConversationCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ConversationCreateWithoutCreatorInput, ConversationUncheckedCreateWithoutCreatorInput> | ConversationCreateWithoutCreatorInput[] | ConversationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatorInput | ConversationCreateOrConnectWithoutCreatorInput[]
    createMany?: ConversationCreateManyCreatorInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<ConversationCreateWithoutAssigneeInput, ConversationUncheckedCreateWithoutAssigneeInput> | ConversationCreateWithoutAssigneeInput[] | ConversationUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAssigneeInput | ConversationCreateOrConnectWithoutAssigneeInput[]
    createMany?: ConversationCreateManyAssigneeInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ToolCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ToolCreateWithoutCreatedByInput, ToolUncheckedCreateWithoutCreatedByInput> | ToolCreateWithoutCreatedByInput[] | ToolUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutCreatedByInput | ToolCreateOrConnectWithoutCreatedByInput[]
    createMany?: ToolCreateManyCreatedByInputEnvelope
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
  }

  export type WhatsAppInstanceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutCreatedByInput, WhatsAppInstanceUncheckedCreateWithoutCreatedByInput> | WhatsAppInstanceCreateWithoutCreatedByInput[] | WhatsAppInstanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutCreatedByInput | WhatsAppInstanceCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhatsAppInstanceCreateManyCreatedByInputEnvelope
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
  }

  export type WhatsAppImportCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<WhatsAppImportCreateWithoutUploadedByInput, WhatsAppImportUncheckedCreateWithoutUploadedByInput> | WhatsAppImportCreateWithoutUploadedByInput[] | WhatsAppImportUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutUploadedByInput | WhatsAppImportCreateOrConnectWithoutUploadedByInput[]
    createMany?: WhatsAppImportCreateManyUploadedByInputEnvelope
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
  }

  export type WhatsAppConversationCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<WhatsAppConversationCreateWithoutAssignedUserInput, WhatsAppConversationUncheckedCreateWithoutAssignedUserInput> | WhatsAppConversationCreateWithoutAssignedUserInput[] | WhatsAppConversationUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutAssignedUserInput | WhatsAppConversationCreateOrConnectWithoutAssignedUserInput[]
    createMany?: WhatsAppConversationCreateManyAssignedUserInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ConversationCreateWithoutCreatorInput, ConversationUncheckedCreateWithoutCreatorInput> | ConversationCreateWithoutCreatorInput[] | ConversationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatorInput | ConversationCreateOrConnectWithoutCreatorInput[]
    createMany?: ConversationCreateManyCreatorInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<ConversationCreateWithoutAssigneeInput, ConversationUncheckedCreateWithoutAssigneeInput> | ConversationCreateWithoutAssigneeInput[] | ConversationUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAssigneeInput | ConversationCreateOrConnectWithoutAssigneeInput[]
    createMany?: ConversationCreateManyAssigneeInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ToolUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ToolCreateWithoutCreatedByInput, ToolUncheckedCreateWithoutCreatedByInput> | ToolCreateWithoutCreatedByInput[] | ToolUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutCreatedByInput | ToolCreateOrConnectWithoutCreatedByInput[]
    createMany?: ToolCreateManyCreatedByInputEnvelope
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
  }

  export type WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutCreatedByInput, WhatsAppInstanceUncheckedCreateWithoutCreatedByInput> | WhatsAppInstanceCreateWithoutCreatedByInput[] | WhatsAppInstanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutCreatedByInput | WhatsAppInstanceCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhatsAppInstanceCreateManyCreatedByInputEnvelope
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
  }

  export type WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<WhatsAppImportCreateWithoutUploadedByInput, WhatsAppImportUncheckedCreateWithoutUploadedByInput> | WhatsAppImportCreateWithoutUploadedByInput[] | WhatsAppImportUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutUploadedByInput | WhatsAppImportCreateOrConnectWithoutUploadedByInput[]
    createMany?: WhatsAppImportCreateManyUploadedByInputEnvelope
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
  }

  export type WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<WhatsAppConversationCreateWithoutAssignedUserInput, WhatsAppConversationUncheckedCreateWithoutAssignedUserInput> | WhatsAppConversationCreateWithoutAssignedUserInput[] | WhatsAppConversationUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutAssignedUserInput | WhatsAppConversationCreateOrConnectWithoutAssignedUserInput[]
    createMany?: WhatsAppConversationCreateManyAssignedUserInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OfficeUpdateOneWithoutUsersNestedInput = {
    create?: XOR<OfficeCreateWithoutUsersInput, OfficeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutUsersInput
    upsert?: OfficeUpsertWithoutUsersInput
    disconnect?: OfficeWhereInput | boolean
    delete?: OfficeWhereInput | boolean
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutUsersInput, OfficeUpdateWithoutUsersInput>, OfficeUncheckedUpdateWithoutUsersInput>
  }

  export type ConversationUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatorInput, ConversationUncheckedCreateWithoutCreatorInput> | ConversationCreateWithoutCreatorInput[] | ConversationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatorInput | ConversationCreateOrConnectWithoutCreatorInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatorInput | ConversationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ConversationCreateManyCreatorInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatorInput | ConversationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatorInput | ConversationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<ConversationCreateWithoutAssigneeInput, ConversationUncheckedCreateWithoutAssigneeInput> | ConversationCreateWithoutAssigneeInput[] | ConversationUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAssigneeInput | ConversationCreateOrConnectWithoutAssigneeInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutAssigneeInput | ConversationUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: ConversationCreateManyAssigneeInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutAssigneeInput | ConversationUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutAssigneeInput | ConversationUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ToolUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ToolCreateWithoutCreatedByInput, ToolUncheckedCreateWithoutCreatedByInput> | ToolCreateWithoutCreatedByInput[] | ToolUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutCreatedByInput | ToolCreateOrConnectWithoutCreatedByInput[]
    upsert?: ToolUpsertWithWhereUniqueWithoutCreatedByInput | ToolUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ToolCreateManyCreatedByInputEnvelope
    set?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    disconnect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    delete?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    update?: ToolUpdateWithWhereUniqueWithoutCreatedByInput | ToolUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ToolUpdateManyWithWhereWithoutCreatedByInput | ToolUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ToolScalarWhereInput | ToolScalarWhereInput[]
  }

  export type WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutCreatedByInput, WhatsAppInstanceUncheckedCreateWithoutCreatedByInput> | WhatsAppInstanceCreateWithoutCreatedByInput[] | WhatsAppInstanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutCreatedByInput | WhatsAppInstanceCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhatsAppInstanceUpsertWithWhereUniqueWithoutCreatedByInput | WhatsAppInstanceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhatsAppInstanceCreateManyCreatedByInputEnvelope
    set?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    disconnect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    delete?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    update?: WhatsAppInstanceUpdateWithWhereUniqueWithoutCreatedByInput | WhatsAppInstanceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhatsAppInstanceUpdateManyWithWhereWithoutCreatedByInput | WhatsAppInstanceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhatsAppInstanceScalarWhereInput | WhatsAppInstanceScalarWhereInput[]
  }

  export type WhatsAppImportUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<WhatsAppImportCreateWithoutUploadedByInput, WhatsAppImportUncheckedCreateWithoutUploadedByInput> | WhatsAppImportCreateWithoutUploadedByInput[] | WhatsAppImportUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutUploadedByInput | WhatsAppImportCreateOrConnectWithoutUploadedByInput[]
    upsert?: WhatsAppImportUpsertWithWhereUniqueWithoutUploadedByInput | WhatsAppImportUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: WhatsAppImportCreateManyUploadedByInputEnvelope
    set?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    disconnect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    delete?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    update?: WhatsAppImportUpdateWithWhereUniqueWithoutUploadedByInput | WhatsAppImportUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: WhatsAppImportUpdateManyWithWhereWithoutUploadedByInput | WhatsAppImportUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
  }

  export type WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutAssignedUserInput, WhatsAppConversationUncheckedCreateWithoutAssignedUserInput> | WhatsAppConversationCreateWithoutAssignedUserInput[] | WhatsAppConversationUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutAssignedUserInput | WhatsAppConversationCreateOrConnectWithoutAssignedUserInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutAssignedUserInput | WhatsAppConversationUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: WhatsAppConversationCreateManyAssignedUserInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutAssignedUserInput | WhatsAppConversationUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutAssignedUserInput | WhatsAppConversationUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ConversationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatorInput, ConversationUncheckedCreateWithoutCreatorInput> | ConversationCreateWithoutCreatorInput[] | ConversationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatorInput | ConversationCreateOrConnectWithoutCreatorInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatorInput | ConversationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ConversationCreateManyCreatorInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatorInput | ConversationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatorInput | ConversationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<ConversationCreateWithoutAssigneeInput, ConversationUncheckedCreateWithoutAssigneeInput> | ConversationCreateWithoutAssigneeInput[] | ConversationUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutAssigneeInput | ConversationCreateOrConnectWithoutAssigneeInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutAssigneeInput | ConversationUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: ConversationCreateManyAssigneeInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutAssigneeInput | ConversationUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutAssigneeInput | ConversationUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ToolUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ToolCreateWithoutCreatedByInput, ToolUncheckedCreateWithoutCreatedByInput> | ToolCreateWithoutCreatedByInput[] | ToolUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutCreatedByInput | ToolCreateOrConnectWithoutCreatedByInput[]
    upsert?: ToolUpsertWithWhereUniqueWithoutCreatedByInput | ToolUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ToolCreateManyCreatedByInputEnvelope
    set?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    disconnect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    delete?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    update?: ToolUpdateWithWhereUniqueWithoutCreatedByInput | ToolUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ToolUpdateManyWithWhereWithoutCreatedByInput | ToolUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ToolScalarWhereInput | ToolScalarWhereInput[]
  }

  export type WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutCreatedByInput, WhatsAppInstanceUncheckedCreateWithoutCreatedByInput> | WhatsAppInstanceCreateWithoutCreatedByInput[] | WhatsAppInstanceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutCreatedByInput | WhatsAppInstanceCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhatsAppInstanceUpsertWithWhereUniqueWithoutCreatedByInput | WhatsAppInstanceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhatsAppInstanceCreateManyCreatedByInputEnvelope
    set?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    disconnect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    delete?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    update?: WhatsAppInstanceUpdateWithWhereUniqueWithoutCreatedByInput | WhatsAppInstanceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhatsAppInstanceUpdateManyWithWhereWithoutCreatedByInput | WhatsAppInstanceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhatsAppInstanceScalarWhereInput | WhatsAppInstanceScalarWhereInput[]
  }

  export type WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<WhatsAppImportCreateWithoutUploadedByInput, WhatsAppImportUncheckedCreateWithoutUploadedByInput> | WhatsAppImportCreateWithoutUploadedByInput[] | WhatsAppImportUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutUploadedByInput | WhatsAppImportCreateOrConnectWithoutUploadedByInput[]
    upsert?: WhatsAppImportUpsertWithWhereUniqueWithoutUploadedByInput | WhatsAppImportUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: WhatsAppImportCreateManyUploadedByInputEnvelope
    set?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    disconnect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    delete?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    update?: WhatsAppImportUpdateWithWhereUniqueWithoutUploadedByInput | WhatsAppImportUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: WhatsAppImportUpdateManyWithWhereWithoutUploadedByInput | WhatsAppImportUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutAssignedUserInput, WhatsAppConversationUncheckedCreateWithoutAssignedUserInput> | WhatsAppConversationCreateWithoutAssignedUserInput[] | WhatsAppConversationUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutAssignedUserInput | WhatsAppConversationCreateOrConnectWithoutAssignedUserInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutAssignedUserInput | WhatsAppConversationUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: WhatsAppConversationCreateManyAssignedUserInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutAssignedUserInput | WhatsAppConversationUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutAssignedUserInput | WhatsAppConversationUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedManyWithoutOfficeInput = {
    create?: XOR<UserCreateWithoutOfficeInput, UserUncheckedCreateWithoutOfficeInput> | UserCreateWithoutOfficeInput[] | UserUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOfficeInput | UserCreateOrConnectWithoutOfficeInput[]
    createMany?: UserCreateManyOfficeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutOfficeInput = {
    create?: XOR<ClientCreateWithoutOfficeInput, ClientUncheckedCreateWithoutOfficeInput> | ClientCreateWithoutOfficeInput[] | ClientUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOfficeInput | ClientCreateOrConnectWithoutOfficeInput[]
    createMany?: ClientCreateManyOfficeInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutOfficeInput = {
    create?: XOR<ConversationCreateWithoutOfficeInput, ConversationUncheckedCreateWithoutOfficeInput> | ConversationCreateWithoutOfficeInput[] | ConversationUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOfficeInput | ConversationCreateOrConnectWithoutOfficeInput[]
    createMany?: ConversationCreateManyOfficeInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutOfficeInput = {
    create?: XOR<TagCreateWithoutOfficeInput, TagUncheckedCreateWithoutOfficeInput> | TagCreateWithoutOfficeInput[] | TagUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutOfficeInput | TagCreateOrConnectWithoutOfficeInput[]
    createMany?: TagCreateManyOfficeInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CustomStatusCreateNestedManyWithoutOfficeInput = {
    create?: XOR<CustomStatusCreateWithoutOfficeInput, CustomStatusUncheckedCreateWithoutOfficeInput> | CustomStatusCreateWithoutOfficeInput[] | CustomStatusUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: CustomStatusCreateOrConnectWithoutOfficeInput | CustomStatusCreateOrConnectWithoutOfficeInput[]
    createMany?: CustomStatusCreateManyOfficeInputEnvelope
    connect?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
  }

  export type AiAgentCreateNestedManyWithoutOfficeInput = {
    create?: XOR<AiAgentCreateWithoutOfficeInput, AiAgentUncheckedCreateWithoutOfficeInput> | AiAgentCreateWithoutOfficeInput[] | AiAgentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutOfficeInput | AiAgentCreateOrConnectWithoutOfficeInput[]
    createMany?: AiAgentCreateManyOfficeInputEnvelope
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
  }

  export type WhatsappConfigCreateNestedManyWithoutOfficeInput = {
    create?: XOR<WhatsappConfigCreateWithoutOfficeInput, WhatsappConfigUncheckedCreateWithoutOfficeInput> | WhatsappConfigCreateWithoutOfficeInput[] | WhatsappConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutOfficeInput | WhatsappConfigCreateOrConnectWithoutOfficeInput[]
    createMany?: WhatsappConfigCreateManyOfficeInputEnvelope
    connect?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutOfficeInput = {
    create?: XOR<DocumentCreateWithoutOfficeInput, DocumentUncheckedCreateWithoutOfficeInput> | DocumentCreateWithoutOfficeInput[] | DocumentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOfficeInput | DocumentCreateOrConnectWithoutOfficeInput[]
    createMany?: DocumentCreateManyOfficeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ToolCreateNestedManyWithoutOfficeInput = {
    create?: XOR<ToolCreateWithoutOfficeInput, ToolUncheckedCreateWithoutOfficeInput> | ToolCreateWithoutOfficeInput[] | ToolUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutOfficeInput | ToolCreateOrConnectWithoutOfficeInput[]
    createMany?: ToolCreateManyOfficeInputEnvelope
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
  }

  export type WebhookCreateNestedManyWithoutOfficeInput = {
    create?: XOR<WebhookCreateWithoutOfficeInput, WebhookUncheckedCreateWithoutOfficeInput> | WebhookCreateWithoutOfficeInput[] | WebhookUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOfficeInput | WebhookCreateOrConnectWithoutOfficeInput[]
    createMany?: WebhookCreateManyOfficeInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutOfficeInput = {
    create?: XOR<AuditLogCreateWithoutOfficeInput, AuditLogUncheckedCreateWithoutOfficeInput> | AuditLogCreateWithoutOfficeInput[] | AuditLogUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOfficeInput | AuditLogCreateOrConnectWithoutOfficeInput[]
    createMany?: AuditLogCreateManyOfficeInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AIProviderConfigCreateNestedManyWithoutOfficeInput = {
    create?: XOR<AIProviderConfigCreateWithoutOfficeInput, AIProviderConfigUncheckedCreateWithoutOfficeInput> | AIProviderConfigCreateWithoutOfficeInput[] | AIProviderConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AIProviderConfigCreateOrConnectWithoutOfficeInput | AIProviderConfigCreateOrConnectWithoutOfficeInput[]
    createMany?: AIProviderConfigCreateManyOfficeInputEnvelope
    connect?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
  }

  export type WhatsAppInstanceCreateNestedManyWithoutOfficeInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutOfficeInput, WhatsAppInstanceUncheckedCreateWithoutOfficeInput> | WhatsAppInstanceCreateWithoutOfficeInput[] | WhatsAppInstanceUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutOfficeInput | WhatsAppInstanceCreateOrConnectWithoutOfficeInput[]
    createMany?: WhatsAppInstanceCreateManyOfficeInputEnvelope
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<UserCreateWithoutOfficeInput, UserUncheckedCreateWithoutOfficeInput> | UserCreateWithoutOfficeInput[] | UserUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOfficeInput | UserCreateOrConnectWithoutOfficeInput[]
    createMany?: UserCreateManyOfficeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<ClientCreateWithoutOfficeInput, ClientUncheckedCreateWithoutOfficeInput> | ClientCreateWithoutOfficeInput[] | ClientUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOfficeInput | ClientCreateOrConnectWithoutOfficeInput[]
    createMany?: ClientCreateManyOfficeInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<ConversationCreateWithoutOfficeInput, ConversationUncheckedCreateWithoutOfficeInput> | ConversationCreateWithoutOfficeInput[] | ConversationUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOfficeInput | ConversationCreateOrConnectWithoutOfficeInput[]
    createMany?: ConversationCreateManyOfficeInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<TagCreateWithoutOfficeInput, TagUncheckedCreateWithoutOfficeInput> | TagCreateWithoutOfficeInput[] | TagUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutOfficeInput | TagCreateOrConnectWithoutOfficeInput[]
    createMany?: TagCreateManyOfficeInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type CustomStatusUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<CustomStatusCreateWithoutOfficeInput, CustomStatusUncheckedCreateWithoutOfficeInput> | CustomStatusCreateWithoutOfficeInput[] | CustomStatusUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: CustomStatusCreateOrConnectWithoutOfficeInput | CustomStatusCreateOrConnectWithoutOfficeInput[]
    createMany?: CustomStatusCreateManyOfficeInputEnvelope
    connect?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
  }

  export type AiAgentUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<AiAgentCreateWithoutOfficeInput, AiAgentUncheckedCreateWithoutOfficeInput> | AiAgentCreateWithoutOfficeInput[] | AiAgentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutOfficeInput | AiAgentCreateOrConnectWithoutOfficeInput[]
    createMany?: AiAgentCreateManyOfficeInputEnvelope
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
  }

  export type WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<WhatsappConfigCreateWithoutOfficeInput, WhatsappConfigUncheckedCreateWithoutOfficeInput> | WhatsappConfigCreateWithoutOfficeInput[] | WhatsappConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutOfficeInput | WhatsappConfigCreateOrConnectWithoutOfficeInput[]
    createMany?: WhatsappConfigCreateManyOfficeInputEnvelope
    connect?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<DocumentCreateWithoutOfficeInput, DocumentUncheckedCreateWithoutOfficeInput> | DocumentCreateWithoutOfficeInput[] | DocumentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOfficeInput | DocumentCreateOrConnectWithoutOfficeInput[]
    createMany?: DocumentCreateManyOfficeInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ToolUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<ToolCreateWithoutOfficeInput, ToolUncheckedCreateWithoutOfficeInput> | ToolCreateWithoutOfficeInput[] | ToolUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutOfficeInput | ToolCreateOrConnectWithoutOfficeInput[]
    createMany?: ToolCreateManyOfficeInputEnvelope
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<WebhookCreateWithoutOfficeInput, WebhookUncheckedCreateWithoutOfficeInput> | WebhookCreateWithoutOfficeInput[] | WebhookUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOfficeInput | WebhookCreateOrConnectWithoutOfficeInput[]
    createMany?: WebhookCreateManyOfficeInputEnvelope
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<AuditLogCreateWithoutOfficeInput, AuditLogUncheckedCreateWithoutOfficeInput> | AuditLogCreateWithoutOfficeInput[] | AuditLogUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOfficeInput | AuditLogCreateOrConnectWithoutOfficeInput[]
    createMany?: AuditLogCreateManyOfficeInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<AIProviderConfigCreateWithoutOfficeInput, AIProviderConfigUncheckedCreateWithoutOfficeInput> | AIProviderConfigCreateWithoutOfficeInput[] | AIProviderConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AIProviderConfigCreateOrConnectWithoutOfficeInput | AIProviderConfigCreateOrConnectWithoutOfficeInput[]
    createMany?: AIProviderConfigCreateManyOfficeInputEnvelope
    connect?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
  }

  export type WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutOfficeInput, WhatsAppInstanceUncheckedCreateWithoutOfficeInput> | WhatsAppInstanceCreateWithoutOfficeInput[] | WhatsAppInstanceUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutOfficeInput | WhatsAppInstanceCreateOrConnectWithoutOfficeInput[]
    createMany?: WhatsAppInstanceCreateManyOfficeInputEnvelope
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<UserCreateWithoutOfficeInput, UserUncheckedCreateWithoutOfficeInput> | UserCreateWithoutOfficeInput[] | UserUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOfficeInput | UserCreateOrConnectWithoutOfficeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOfficeInput | UserUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: UserCreateManyOfficeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOfficeInput | UserUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOfficeInput | UserUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<ClientCreateWithoutOfficeInput, ClientUncheckedCreateWithoutOfficeInput> | ClientCreateWithoutOfficeInput[] | ClientUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOfficeInput | ClientCreateOrConnectWithoutOfficeInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutOfficeInput | ClientUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: ClientCreateManyOfficeInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutOfficeInput | ClientUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutOfficeInput | ClientUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<ConversationCreateWithoutOfficeInput, ConversationUncheckedCreateWithoutOfficeInput> | ConversationCreateWithoutOfficeInput[] | ConversationUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOfficeInput | ConversationCreateOrConnectWithoutOfficeInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutOfficeInput | ConversationUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: ConversationCreateManyOfficeInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutOfficeInput | ConversationUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutOfficeInput | ConversationUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type TagUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<TagCreateWithoutOfficeInput, TagUncheckedCreateWithoutOfficeInput> | TagCreateWithoutOfficeInput[] | TagUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutOfficeInput | TagCreateOrConnectWithoutOfficeInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutOfficeInput | TagUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: TagCreateManyOfficeInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutOfficeInput | TagUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: TagUpdateManyWithWhereWithoutOfficeInput | TagUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CustomStatusUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<CustomStatusCreateWithoutOfficeInput, CustomStatusUncheckedCreateWithoutOfficeInput> | CustomStatusCreateWithoutOfficeInput[] | CustomStatusUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: CustomStatusCreateOrConnectWithoutOfficeInput | CustomStatusCreateOrConnectWithoutOfficeInput[]
    upsert?: CustomStatusUpsertWithWhereUniqueWithoutOfficeInput | CustomStatusUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: CustomStatusCreateManyOfficeInputEnvelope
    set?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    disconnect?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    delete?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    connect?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    update?: CustomStatusUpdateWithWhereUniqueWithoutOfficeInput | CustomStatusUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: CustomStatusUpdateManyWithWhereWithoutOfficeInput | CustomStatusUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: CustomStatusScalarWhereInput | CustomStatusScalarWhereInput[]
  }

  export type AiAgentUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<AiAgentCreateWithoutOfficeInput, AiAgentUncheckedCreateWithoutOfficeInput> | AiAgentCreateWithoutOfficeInput[] | AiAgentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutOfficeInput | AiAgentCreateOrConnectWithoutOfficeInput[]
    upsert?: AiAgentUpsertWithWhereUniqueWithoutOfficeInput | AiAgentUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: AiAgentCreateManyOfficeInputEnvelope
    set?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    disconnect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    delete?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    update?: AiAgentUpdateWithWhereUniqueWithoutOfficeInput | AiAgentUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: AiAgentUpdateManyWithWhereWithoutOfficeInput | AiAgentUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
  }

  export type WhatsappConfigUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<WhatsappConfigCreateWithoutOfficeInput, WhatsappConfigUncheckedCreateWithoutOfficeInput> | WhatsappConfigCreateWithoutOfficeInput[] | WhatsappConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutOfficeInput | WhatsappConfigCreateOrConnectWithoutOfficeInput[]
    upsert?: WhatsappConfigUpsertWithWhereUniqueWithoutOfficeInput | WhatsappConfigUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: WhatsappConfigCreateManyOfficeInputEnvelope
    set?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    disconnect?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    delete?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    connect?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    update?: WhatsappConfigUpdateWithWhereUniqueWithoutOfficeInput | WhatsappConfigUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: WhatsappConfigUpdateManyWithWhereWithoutOfficeInput | WhatsappConfigUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: WhatsappConfigScalarWhereInput | WhatsappConfigScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<DocumentCreateWithoutOfficeInput, DocumentUncheckedCreateWithoutOfficeInput> | DocumentCreateWithoutOfficeInput[] | DocumentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOfficeInput | DocumentCreateOrConnectWithoutOfficeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOfficeInput | DocumentUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: DocumentCreateManyOfficeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOfficeInput | DocumentUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOfficeInput | DocumentUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ToolUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<ToolCreateWithoutOfficeInput, ToolUncheckedCreateWithoutOfficeInput> | ToolCreateWithoutOfficeInput[] | ToolUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutOfficeInput | ToolCreateOrConnectWithoutOfficeInput[]
    upsert?: ToolUpsertWithWhereUniqueWithoutOfficeInput | ToolUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: ToolCreateManyOfficeInputEnvelope
    set?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    disconnect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    delete?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    update?: ToolUpdateWithWhereUniqueWithoutOfficeInput | ToolUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: ToolUpdateManyWithWhereWithoutOfficeInput | ToolUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: ToolScalarWhereInput | ToolScalarWhereInput[]
  }

  export type WebhookUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<WebhookCreateWithoutOfficeInput, WebhookUncheckedCreateWithoutOfficeInput> | WebhookCreateWithoutOfficeInput[] | WebhookUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOfficeInput | WebhookCreateOrConnectWithoutOfficeInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutOfficeInput | WebhookUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: WebhookCreateManyOfficeInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutOfficeInput | WebhookUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutOfficeInput | WebhookUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<AuditLogCreateWithoutOfficeInput, AuditLogUncheckedCreateWithoutOfficeInput> | AuditLogCreateWithoutOfficeInput[] | AuditLogUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOfficeInput | AuditLogCreateOrConnectWithoutOfficeInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutOfficeInput | AuditLogUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: AuditLogCreateManyOfficeInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutOfficeInput | AuditLogUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutOfficeInput | AuditLogUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AIProviderConfigUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<AIProviderConfigCreateWithoutOfficeInput, AIProviderConfigUncheckedCreateWithoutOfficeInput> | AIProviderConfigCreateWithoutOfficeInput[] | AIProviderConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AIProviderConfigCreateOrConnectWithoutOfficeInput | AIProviderConfigCreateOrConnectWithoutOfficeInput[]
    upsert?: AIProviderConfigUpsertWithWhereUniqueWithoutOfficeInput | AIProviderConfigUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: AIProviderConfigCreateManyOfficeInputEnvelope
    set?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    disconnect?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    delete?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    connect?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    update?: AIProviderConfigUpdateWithWhereUniqueWithoutOfficeInput | AIProviderConfigUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: AIProviderConfigUpdateManyWithWhereWithoutOfficeInput | AIProviderConfigUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: AIProviderConfigScalarWhereInput | AIProviderConfigScalarWhereInput[]
  }

  export type WhatsAppInstanceUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutOfficeInput, WhatsAppInstanceUncheckedCreateWithoutOfficeInput> | WhatsAppInstanceCreateWithoutOfficeInput[] | WhatsAppInstanceUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutOfficeInput | WhatsAppInstanceCreateOrConnectWithoutOfficeInput[]
    upsert?: WhatsAppInstanceUpsertWithWhereUniqueWithoutOfficeInput | WhatsAppInstanceUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: WhatsAppInstanceCreateManyOfficeInputEnvelope
    set?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    disconnect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    delete?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    update?: WhatsAppInstanceUpdateWithWhereUniqueWithoutOfficeInput | WhatsAppInstanceUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: WhatsAppInstanceUpdateManyWithWhereWithoutOfficeInput | WhatsAppInstanceUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: WhatsAppInstanceScalarWhereInput | WhatsAppInstanceScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<UserCreateWithoutOfficeInput, UserUncheckedCreateWithoutOfficeInput> | UserCreateWithoutOfficeInput[] | UserUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOfficeInput | UserCreateOrConnectWithoutOfficeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOfficeInput | UserUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: UserCreateManyOfficeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOfficeInput | UserUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOfficeInput | UserUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<ClientCreateWithoutOfficeInput, ClientUncheckedCreateWithoutOfficeInput> | ClientCreateWithoutOfficeInput[] | ClientUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutOfficeInput | ClientCreateOrConnectWithoutOfficeInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutOfficeInput | ClientUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: ClientCreateManyOfficeInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutOfficeInput | ClientUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutOfficeInput | ClientUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<ConversationCreateWithoutOfficeInput, ConversationUncheckedCreateWithoutOfficeInput> | ConversationCreateWithoutOfficeInput[] | ConversationUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutOfficeInput | ConversationCreateOrConnectWithoutOfficeInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutOfficeInput | ConversationUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: ConversationCreateManyOfficeInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutOfficeInput | ConversationUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutOfficeInput | ConversationUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<TagCreateWithoutOfficeInput, TagUncheckedCreateWithoutOfficeInput> | TagCreateWithoutOfficeInput[] | TagUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutOfficeInput | TagCreateOrConnectWithoutOfficeInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutOfficeInput | TagUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: TagCreateManyOfficeInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutOfficeInput | TagUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: TagUpdateManyWithWhereWithoutOfficeInput | TagUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<CustomStatusCreateWithoutOfficeInput, CustomStatusUncheckedCreateWithoutOfficeInput> | CustomStatusCreateWithoutOfficeInput[] | CustomStatusUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: CustomStatusCreateOrConnectWithoutOfficeInput | CustomStatusCreateOrConnectWithoutOfficeInput[]
    upsert?: CustomStatusUpsertWithWhereUniqueWithoutOfficeInput | CustomStatusUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: CustomStatusCreateManyOfficeInputEnvelope
    set?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    disconnect?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    delete?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    connect?: CustomStatusWhereUniqueInput | CustomStatusWhereUniqueInput[]
    update?: CustomStatusUpdateWithWhereUniqueWithoutOfficeInput | CustomStatusUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: CustomStatusUpdateManyWithWhereWithoutOfficeInput | CustomStatusUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: CustomStatusScalarWhereInput | CustomStatusScalarWhereInput[]
  }

  export type AiAgentUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<AiAgentCreateWithoutOfficeInput, AiAgentUncheckedCreateWithoutOfficeInput> | AiAgentCreateWithoutOfficeInput[] | AiAgentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AiAgentCreateOrConnectWithoutOfficeInput | AiAgentCreateOrConnectWithoutOfficeInput[]
    upsert?: AiAgentUpsertWithWhereUniqueWithoutOfficeInput | AiAgentUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: AiAgentCreateManyOfficeInputEnvelope
    set?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    disconnect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    delete?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    connect?: AiAgentWhereUniqueInput | AiAgentWhereUniqueInput[]
    update?: AiAgentUpdateWithWhereUniqueWithoutOfficeInput | AiAgentUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: AiAgentUpdateManyWithWhereWithoutOfficeInput | AiAgentUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
  }

  export type WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<WhatsappConfigCreateWithoutOfficeInput, WhatsappConfigUncheckedCreateWithoutOfficeInput> | WhatsappConfigCreateWithoutOfficeInput[] | WhatsappConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutOfficeInput | WhatsappConfigCreateOrConnectWithoutOfficeInput[]
    upsert?: WhatsappConfigUpsertWithWhereUniqueWithoutOfficeInput | WhatsappConfigUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: WhatsappConfigCreateManyOfficeInputEnvelope
    set?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    disconnect?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    delete?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    connect?: WhatsappConfigWhereUniqueInput | WhatsappConfigWhereUniqueInput[]
    update?: WhatsappConfigUpdateWithWhereUniqueWithoutOfficeInput | WhatsappConfigUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: WhatsappConfigUpdateManyWithWhereWithoutOfficeInput | WhatsappConfigUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: WhatsappConfigScalarWhereInput | WhatsappConfigScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<DocumentCreateWithoutOfficeInput, DocumentUncheckedCreateWithoutOfficeInput> | DocumentCreateWithoutOfficeInput[] | DocumentUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOfficeInput | DocumentCreateOrConnectWithoutOfficeInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOfficeInput | DocumentUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: DocumentCreateManyOfficeInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOfficeInput | DocumentUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOfficeInput | DocumentUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ToolUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<ToolCreateWithoutOfficeInput, ToolUncheckedCreateWithoutOfficeInput> | ToolCreateWithoutOfficeInput[] | ToolUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: ToolCreateOrConnectWithoutOfficeInput | ToolCreateOrConnectWithoutOfficeInput[]
    upsert?: ToolUpsertWithWhereUniqueWithoutOfficeInput | ToolUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: ToolCreateManyOfficeInputEnvelope
    set?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    disconnect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    delete?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    connect?: ToolWhereUniqueInput | ToolWhereUniqueInput[]
    update?: ToolUpdateWithWhereUniqueWithoutOfficeInput | ToolUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: ToolUpdateManyWithWhereWithoutOfficeInput | ToolUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: ToolScalarWhereInput | ToolScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<WebhookCreateWithoutOfficeInput, WebhookUncheckedCreateWithoutOfficeInput> | WebhookCreateWithoutOfficeInput[] | WebhookUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WebhookCreateOrConnectWithoutOfficeInput | WebhookCreateOrConnectWithoutOfficeInput[]
    upsert?: WebhookUpsertWithWhereUniqueWithoutOfficeInput | WebhookUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: WebhookCreateManyOfficeInputEnvelope
    set?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    disconnect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    delete?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    connect?: WebhookWhereUniqueInput | WebhookWhereUniqueInput[]
    update?: WebhookUpdateWithWhereUniqueWithoutOfficeInput | WebhookUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: WebhookUpdateManyWithWhereWithoutOfficeInput | WebhookUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<AuditLogCreateWithoutOfficeInput, AuditLogUncheckedCreateWithoutOfficeInput> | AuditLogCreateWithoutOfficeInput[] | AuditLogUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOfficeInput | AuditLogCreateOrConnectWithoutOfficeInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutOfficeInput | AuditLogUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: AuditLogCreateManyOfficeInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutOfficeInput | AuditLogUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutOfficeInput | AuditLogUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<AIProviderConfigCreateWithoutOfficeInput, AIProviderConfigUncheckedCreateWithoutOfficeInput> | AIProviderConfigCreateWithoutOfficeInput[] | AIProviderConfigUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: AIProviderConfigCreateOrConnectWithoutOfficeInput | AIProviderConfigCreateOrConnectWithoutOfficeInput[]
    upsert?: AIProviderConfigUpsertWithWhereUniqueWithoutOfficeInput | AIProviderConfigUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: AIProviderConfigCreateManyOfficeInputEnvelope
    set?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    disconnect?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    delete?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    connect?: AIProviderConfigWhereUniqueInput | AIProviderConfigWhereUniqueInput[]
    update?: AIProviderConfigUpdateWithWhereUniqueWithoutOfficeInput | AIProviderConfigUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: AIProviderConfigUpdateManyWithWhereWithoutOfficeInput | AIProviderConfigUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: AIProviderConfigScalarWhereInput | AIProviderConfigScalarWhereInput[]
  }

  export type WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutOfficeInput, WhatsAppInstanceUncheckedCreateWithoutOfficeInput> | WhatsAppInstanceCreateWithoutOfficeInput[] | WhatsAppInstanceUncheckedCreateWithoutOfficeInput[]
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutOfficeInput | WhatsAppInstanceCreateOrConnectWithoutOfficeInput[]
    upsert?: WhatsAppInstanceUpsertWithWhereUniqueWithoutOfficeInput | WhatsAppInstanceUpsertWithWhereUniqueWithoutOfficeInput[]
    createMany?: WhatsAppInstanceCreateManyOfficeInputEnvelope
    set?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    disconnect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    delete?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    connect?: WhatsAppInstanceWhereUniqueInput | WhatsAppInstanceWhereUniqueInput[]
    update?: WhatsAppInstanceUpdateWithWhereUniqueWithoutOfficeInput | WhatsAppInstanceUpdateWithWhereUniqueWithoutOfficeInput[]
    updateMany?: WhatsAppInstanceUpdateManyWithWhereWithoutOfficeInput | WhatsAppInstanceUpdateManyWithWhereWithoutOfficeInput[]
    deleteMany?: WhatsAppInstanceScalarWhereInput | WhatsAppInstanceScalarWhereInput[]
  }

  export type OfficeCreateNestedOneWithoutWhatsappConfigsInput = {
    create?: XOR<OfficeCreateWithoutWhatsappConfigsInput, OfficeUncheckedCreateWithoutWhatsappConfigsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutWhatsappConfigsInput
    connect?: OfficeWhereUniqueInput
  }

  export type ConversationCreateNestedManyWithoutWhatsappConfigInput = {
    create?: XOR<ConversationCreateWithoutWhatsappConfigInput, ConversationUncheckedCreateWithoutWhatsappConfigInput> | ConversationCreateWithoutWhatsappConfigInput[] | ConversationUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWhatsappConfigInput | ConversationCreateOrConnectWithoutWhatsappConfigInput[]
    createMany?: ConversationCreateManyWhatsappConfigInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutWhatsappConfigInput = {
    create?: XOR<MessageCreateWithoutWhatsappConfigInput, MessageUncheckedCreateWithoutWhatsappConfigInput> | MessageCreateWithoutWhatsappConfigInput[] | MessageUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutWhatsappConfigInput | MessageCreateOrConnectWithoutWhatsappConfigInput[]
    createMany?: MessageCreateManyWhatsappConfigInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutWhatsappConfigInput = {
    create?: XOR<ConversationCreateWithoutWhatsappConfigInput, ConversationUncheckedCreateWithoutWhatsappConfigInput> | ConversationCreateWithoutWhatsappConfigInput[] | ConversationUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWhatsappConfigInput | ConversationCreateOrConnectWithoutWhatsappConfigInput[]
    createMany?: ConversationCreateManyWhatsappConfigInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutWhatsappConfigInput = {
    create?: XOR<MessageCreateWithoutWhatsappConfigInput, MessageUncheckedCreateWithoutWhatsappConfigInput> | MessageCreateWithoutWhatsappConfigInput[] | MessageUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutWhatsappConfigInput | MessageCreateOrConnectWithoutWhatsappConfigInput[]
    createMany?: MessageCreateManyWhatsappConfigInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type OfficeUpdateOneRequiredWithoutWhatsappConfigsNestedInput = {
    create?: XOR<OfficeCreateWithoutWhatsappConfigsInput, OfficeUncheckedCreateWithoutWhatsappConfigsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutWhatsappConfigsInput
    upsert?: OfficeUpsertWithoutWhatsappConfigsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutWhatsappConfigsInput, OfficeUpdateWithoutWhatsappConfigsInput>, OfficeUncheckedUpdateWithoutWhatsappConfigsInput>
  }

  export type ConversationUpdateManyWithoutWhatsappConfigNestedInput = {
    create?: XOR<ConversationCreateWithoutWhatsappConfigInput, ConversationUncheckedCreateWithoutWhatsappConfigInput> | ConversationCreateWithoutWhatsappConfigInput[] | ConversationUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWhatsappConfigInput | ConversationCreateOrConnectWithoutWhatsappConfigInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutWhatsappConfigInput | ConversationUpsertWithWhereUniqueWithoutWhatsappConfigInput[]
    createMany?: ConversationCreateManyWhatsappConfigInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutWhatsappConfigInput | ConversationUpdateWithWhereUniqueWithoutWhatsappConfigInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutWhatsappConfigInput | ConversationUpdateManyWithWhereWithoutWhatsappConfigInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutWhatsappConfigNestedInput = {
    create?: XOR<MessageCreateWithoutWhatsappConfigInput, MessageUncheckedCreateWithoutWhatsappConfigInput> | MessageCreateWithoutWhatsappConfigInput[] | MessageUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutWhatsappConfigInput | MessageCreateOrConnectWithoutWhatsappConfigInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutWhatsappConfigInput | MessageUpsertWithWhereUniqueWithoutWhatsappConfigInput[]
    createMany?: MessageCreateManyWhatsappConfigInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutWhatsappConfigInput | MessageUpdateWithWhereUniqueWithoutWhatsappConfigInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutWhatsappConfigInput | MessageUpdateManyWithWhereWithoutWhatsappConfigInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutWhatsappConfigNestedInput = {
    create?: XOR<ConversationCreateWithoutWhatsappConfigInput, ConversationUncheckedCreateWithoutWhatsappConfigInput> | ConversationCreateWithoutWhatsappConfigInput[] | ConversationUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWhatsappConfigInput | ConversationCreateOrConnectWithoutWhatsappConfigInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutWhatsappConfigInput | ConversationUpsertWithWhereUniqueWithoutWhatsappConfigInput[]
    createMany?: ConversationCreateManyWhatsappConfigInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutWhatsappConfigInput | ConversationUpdateWithWhereUniqueWithoutWhatsappConfigInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutWhatsappConfigInput | ConversationUpdateManyWithWhereWithoutWhatsappConfigInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutWhatsappConfigNestedInput = {
    create?: XOR<MessageCreateWithoutWhatsappConfigInput, MessageUncheckedCreateWithoutWhatsappConfigInput> | MessageCreateWithoutWhatsappConfigInput[] | MessageUncheckedCreateWithoutWhatsappConfigInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutWhatsappConfigInput | MessageCreateOrConnectWithoutWhatsappConfigInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutWhatsappConfigInput | MessageUpsertWithWhereUniqueWithoutWhatsappConfigInput[]
    createMany?: MessageCreateManyWhatsappConfigInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutWhatsappConfigInput | MessageUpdateWithWhereUniqueWithoutWhatsappConfigInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutWhatsappConfigInput | MessageUpdateManyWithWhereWithoutWhatsappConfigInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type OfficeCreateNestedOneWithoutWhatsappInstancesInput = {
    create?: XOR<OfficeCreateWithoutWhatsappInstancesInput, OfficeUncheckedCreateWithoutWhatsappInstancesInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutWhatsappInstancesInput
    connect?: OfficeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWhatsappInstancesCreatedInput = {
    create?: XOR<UserCreateWithoutWhatsappInstancesCreatedInput, UserUncheckedCreateWithoutWhatsappInstancesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappInstancesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppContactCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppContactCreateWithoutInstanceInput, WhatsAppContactUncheckedCreateWithoutInstanceInput> | WhatsAppContactCreateWithoutInstanceInput[] | WhatsAppContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutInstanceInput | WhatsAppContactCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppContactCreateManyInstanceInputEnvelope
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
  }

  export type WhatsAppConversationCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppConversationCreateWithoutInstanceInput, WhatsAppConversationUncheckedCreateWithoutInstanceInput> | WhatsAppConversationCreateWithoutInstanceInput[] | WhatsAppConversationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutInstanceInput | WhatsAppConversationCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppConversationCreateManyInstanceInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type WhatsAppMessageCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppMessageCreateWithoutInstanceInput, WhatsAppMessageUncheckedCreateWithoutInstanceInput> | WhatsAppMessageCreateWithoutInstanceInput[] | WhatsAppMessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutInstanceInput | WhatsAppMessageCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppMessageCreateManyInstanceInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type WhatsAppImportCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppImportCreateWithoutInstanceInput, WhatsAppImportUncheckedCreateWithoutInstanceInput> | WhatsAppImportCreateWithoutInstanceInput[] | WhatsAppImportUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutInstanceInput | WhatsAppImportCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppImportCreateManyInstanceInputEnvelope
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
  }

  export type WhatsAppContactUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppContactCreateWithoutInstanceInput, WhatsAppContactUncheckedCreateWithoutInstanceInput> | WhatsAppContactCreateWithoutInstanceInput[] | WhatsAppContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutInstanceInput | WhatsAppContactCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppContactCreateManyInstanceInputEnvelope
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
  }

  export type WhatsAppConversationUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppConversationCreateWithoutInstanceInput, WhatsAppConversationUncheckedCreateWithoutInstanceInput> | WhatsAppConversationCreateWithoutInstanceInput[] | WhatsAppConversationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutInstanceInput | WhatsAppConversationCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppConversationCreateManyInstanceInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type WhatsAppMessageUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppMessageCreateWithoutInstanceInput, WhatsAppMessageUncheckedCreateWithoutInstanceInput> | WhatsAppMessageCreateWithoutInstanceInput[] | WhatsAppMessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutInstanceInput | WhatsAppMessageCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppMessageCreateManyInstanceInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type WhatsAppImportUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WhatsAppImportCreateWithoutInstanceInput, WhatsAppImportUncheckedCreateWithoutInstanceInput> | WhatsAppImportCreateWithoutInstanceInput[] | WhatsAppImportUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutInstanceInput | WhatsAppImportCreateOrConnectWithoutInstanceInput[]
    createMany?: WhatsAppImportCreateManyInstanceInputEnvelope
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
  }

  export type EnumWhatsAppInstanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.WhatsAppInstanceStatus
  }

  export type OfficeUpdateOneRequiredWithoutWhatsappInstancesNestedInput = {
    create?: XOR<OfficeCreateWithoutWhatsappInstancesInput, OfficeUncheckedCreateWithoutWhatsappInstancesInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutWhatsappInstancesInput
    upsert?: OfficeUpsertWithoutWhatsappInstancesInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutWhatsappInstancesInput, OfficeUpdateWithoutWhatsappInstancesInput>, OfficeUncheckedUpdateWithoutWhatsappInstancesInput>
  }

  export type UserUpdateOneRequiredWithoutWhatsappInstancesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappInstancesCreatedInput, UserUncheckedCreateWithoutWhatsappInstancesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappInstancesCreatedInput
    upsert?: UserUpsertWithoutWhatsappInstancesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsappInstancesCreatedInput, UserUpdateWithoutWhatsappInstancesCreatedInput>, UserUncheckedUpdateWithoutWhatsappInstancesCreatedInput>
  }

  export type WhatsAppContactUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutInstanceInput, WhatsAppContactUncheckedCreateWithoutInstanceInput> | WhatsAppContactCreateWithoutInstanceInput[] | WhatsAppContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutInstanceInput | WhatsAppContactCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppContactUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppContactUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppContactCreateManyInstanceInputEnvelope
    set?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    disconnect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    delete?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    update?: WhatsAppContactUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppContactUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppContactUpdateManyWithWhereWithoutInstanceInput | WhatsAppContactUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
  }

  export type WhatsAppConversationUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutInstanceInput, WhatsAppConversationUncheckedCreateWithoutInstanceInput> | WhatsAppConversationCreateWithoutInstanceInput[] | WhatsAppConversationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutInstanceInput | WhatsAppConversationCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppConversationUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppConversationCreateManyInstanceInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppConversationUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutInstanceInput | WhatsAppConversationUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type WhatsAppMessageUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutInstanceInput, WhatsAppMessageUncheckedCreateWithoutInstanceInput> | WhatsAppMessageCreateWithoutInstanceInput[] | WhatsAppMessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutInstanceInput | WhatsAppMessageCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppMessageUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppMessageCreateManyInstanceInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppMessageUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutInstanceInput | WhatsAppMessageUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type WhatsAppImportUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppImportCreateWithoutInstanceInput, WhatsAppImportUncheckedCreateWithoutInstanceInput> | WhatsAppImportCreateWithoutInstanceInput[] | WhatsAppImportUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutInstanceInput | WhatsAppImportCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppImportUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppImportUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppImportCreateManyInstanceInputEnvelope
    set?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    disconnect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    delete?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    update?: WhatsAppImportUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppImportUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppImportUpdateManyWithWhereWithoutInstanceInput | WhatsAppImportUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
  }

  export type WhatsAppContactUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutInstanceInput, WhatsAppContactUncheckedCreateWithoutInstanceInput> | WhatsAppContactCreateWithoutInstanceInput[] | WhatsAppContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutInstanceInput | WhatsAppContactCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppContactUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppContactUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppContactCreateManyInstanceInputEnvelope
    set?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    disconnect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    delete?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    update?: WhatsAppContactUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppContactUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppContactUpdateManyWithWhereWithoutInstanceInput | WhatsAppContactUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutInstanceInput, WhatsAppConversationUncheckedCreateWithoutInstanceInput> | WhatsAppConversationCreateWithoutInstanceInput[] | WhatsAppConversationUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutInstanceInput | WhatsAppConversationCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppConversationUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppConversationCreateManyInstanceInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppConversationUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutInstanceInput | WhatsAppConversationUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutInstanceInput, WhatsAppMessageUncheckedCreateWithoutInstanceInput> | WhatsAppMessageCreateWithoutInstanceInput[] | WhatsAppMessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutInstanceInput | WhatsAppMessageCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppMessageUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppMessageCreateManyInstanceInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppMessageUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutInstanceInput | WhatsAppMessageUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type WhatsAppImportUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WhatsAppImportCreateWithoutInstanceInput, WhatsAppImportUncheckedCreateWithoutInstanceInput> | WhatsAppImportCreateWithoutInstanceInput[] | WhatsAppImportUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutInstanceInput | WhatsAppImportCreateOrConnectWithoutInstanceInput[]
    upsert?: WhatsAppImportUpsertWithWhereUniqueWithoutInstanceInput | WhatsAppImportUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WhatsAppImportCreateManyInstanceInputEnvelope
    set?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    disconnect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    delete?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    update?: WhatsAppImportUpdateWithWhereUniqueWithoutInstanceInput | WhatsAppImportUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WhatsAppImportUpdateManyWithWhereWithoutInstanceInput | WhatsAppImportUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
  }

  export type WhatsAppContactCreatetagsInput = {
    set: string[]
  }

  export type WhatsAppInstanceCreateNestedOneWithoutContactsInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutContactsInput, WhatsAppInstanceUncheckedCreateWithoutContactsInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutContactsInput
    connect?: WhatsAppInstanceWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutWhatsappContactsInput = {
    create?: XOR<ClientCreateWithoutWhatsappContactsInput, ClientUncheckedCreateWithoutWhatsappContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutWhatsappContactsInput
    connect?: ClientWhereUniqueInput
  }

  export type WhatsAppConversationCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppConversationCreateWithoutContactInput, WhatsAppConversationUncheckedCreateWithoutContactInput> | WhatsAppConversationCreateWithoutContactInput[] | WhatsAppConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutContactInput | WhatsAppConversationCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppConversationCreateManyContactInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type WhatsAppMessageCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppMessageCreateWithoutContactInput, WhatsAppMessageUncheckedCreateWithoutContactInput> | WhatsAppMessageCreateWithoutContactInput[] | WhatsAppMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutContactInput | WhatsAppMessageCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppMessageCreateManyContactInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type WhatsAppImportCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppImportCreateWithoutContactInput, WhatsAppImportUncheckedCreateWithoutContactInput> | WhatsAppImportCreateWithoutContactInput[] | WhatsAppImportUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutContactInput | WhatsAppImportCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppImportCreateManyContactInputEnvelope
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
  }

  export type WhatsAppConversationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppConversationCreateWithoutContactInput, WhatsAppConversationUncheckedCreateWithoutContactInput> | WhatsAppConversationCreateWithoutContactInput[] | WhatsAppConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutContactInput | WhatsAppConversationCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppConversationCreateManyContactInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type WhatsAppMessageUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppMessageCreateWithoutContactInput, WhatsAppMessageUncheckedCreateWithoutContactInput> | WhatsAppMessageCreateWithoutContactInput[] | WhatsAppMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutContactInput | WhatsAppMessageCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppMessageCreateManyContactInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type WhatsAppImportUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<WhatsAppImportCreateWithoutContactInput, WhatsAppImportUncheckedCreateWithoutContactInput> | WhatsAppImportCreateWithoutContactInput[] | WhatsAppImportUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutContactInput | WhatsAppImportCreateOrConnectWithoutContactInput[]
    createMany?: WhatsAppImportCreateManyContactInputEnvelope
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type WhatsAppContactUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WhatsAppInstanceUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutContactsInput, WhatsAppInstanceUncheckedCreateWithoutContactsInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutContactsInput
    upsert?: WhatsAppInstanceUpsertWithoutContactsInput
    connect?: WhatsAppInstanceWhereUniqueInput
    update?: XOR<XOR<WhatsAppInstanceUpdateToOneWithWhereWithoutContactsInput, WhatsAppInstanceUpdateWithoutContactsInput>, WhatsAppInstanceUncheckedUpdateWithoutContactsInput>
  }

  export type ClientUpdateOneWithoutWhatsappContactsNestedInput = {
    create?: XOR<ClientCreateWithoutWhatsappContactsInput, ClientUncheckedCreateWithoutWhatsappContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutWhatsappContactsInput
    upsert?: ClientUpsertWithoutWhatsappContactsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutWhatsappContactsInput, ClientUpdateWithoutWhatsappContactsInput>, ClientUncheckedUpdateWithoutWhatsappContactsInput>
  }

  export type WhatsAppConversationUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutContactInput, WhatsAppConversationUncheckedCreateWithoutContactInput> | WhatsAppConversationCreateWithoutContactInput[] | WhatsAppConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutContactInput | WhatsAppConversationCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutContactInput | WhatsAppConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppConversationCreateManyContactInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutContactInput | WhatsAppConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutContactInput | WhatsAppConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type WhatsAppMessageUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutContactInput, WhatsAppMessageUncheckedCreateWithoutContactInput> | WhatsAppMessageCreateWithoutContactInput[] | WhatsAppMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutContactInput | WhatsAppMessageCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutContactInput | WhatsAppMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppMessageCreateManyContactInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutContactInput | WhatsAppMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutContactInput | WhatsAppMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type WhatsAppImportUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppImportCreateWithoutContactInput, WhatsAppImportUncheckedCreateWithoutContactInput> | WhatsAppImportCreateWithoutContactInput[] | WhatsAppImportUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutContactInput | WhatsAppImportCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppImportUpsertWithWhereUniqueWithoutContactInput | WhatsAppImportUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppImportCreateManyContactInputEnvelope
    set?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    disconnect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    delete?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    update?: WhatsAppImportUpdateWithWhereUniqueWithoutContactInput | WhatsAppImportUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppImportUpdateManyWithWhereWithoutContactInput | WhatsAppImportUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutContactInput, WhatsAppConversationUncheckedCreateWithoutContactInput> | WhatsAppConversationCreateWithoutContactInput[] | WhatsAppConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutContactInput | WhatsAppConversationCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutContactInput | WhatsAppConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppConversationCreateManyContactInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutContactInput | WhatsAppConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutContactInput | WhatsAppConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutContactInput, WhatsAppMessageUncheckedCreateWithoutContactInput> | WhatsAppMessageCreateWithoutContactInput[] | WhatsAppMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutContactInput | WhatsAppMessageCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutContactInput | WhatsAppMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppMessageCreateManyContactInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutContactInput | WhatsAppMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutContactInput | WhatsAppMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type WhatsAppImportUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<WhatsAppImportCreateWithoutContactInput, WhatsAppImportUncheckedCreateWithoutContactInput> | WhatsAppImportCreateWithoutContactInput[] | WhatsAppImportUncheckedCreateWithoutContactInput[]
    connectOrCreate?: WhatsAppImportCreateOrConnectWithoutContactInput | WhatsAppImportCreateOrConnectWithoutContactInput[]
    upsert?: WhatsAppImportUpsertWithWhereUniqueWithoutContactInput | WhatsAppImportUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: WhatsAppImportCreateManyContactInputEnvelope
    set?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    disconnect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    delete?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    connect?: WhatsAppImportWhereUniqueInput | WhatsAppImportWhereUniqueInput[]
    update?: WhatsAppImportUpdateWithWhereUniqueWithoutContactInput | WhatsAppImportUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: WhatsAppImportUpdateManyWithWhereWithoutContactInput | WhatsAppImportUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
  }

  export type WhatsAppInstanceCreateNestedOneWithoutConversationsInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutConversationsInput, WhatsAppInstanceUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutConversationsInput
    connect?: WhatsAppInstanceWhereUniqueInput
  }

  export type WhatsAppContactCreateNestedOneWithoutConversationsInput = {
    create?: XOR<WhatsAppContactCreateWithoutConversationsInput, WhatsAppContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutConversationsInput
    connect?: WhatsAppContactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWhatsappConversationsAssignedInput = {
    create?: XOR<UserCreateWithoutWhatsappConversationsAssignedInput, UserUncheckedCreateWithoutWhatsappConversationsAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappConversationsAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type AiAgentCreateNestedOneWithoutWhatsappConversationsInput = {
    create?: XOR<AiAgentCreateWithoutWhatsappConversationsInput, AiAgentUncheckedCreateWithoutWhatsappConversationsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutWhatsappConversationsInput
    connect?: AiAgentWhereUniqueInput
  }

  export type WhatsAppMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<WhatsAppMessageCreateWithoutConversationInput, WhatsAppMessageUncheckedCreateWithoutConversationInput> | WhatsAppMessageCreateWithoutConversationInput[] | WhatsAppMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutConversationInput | WhatsAppMessageCreateOrConnectWithoutConversationInput[]
    createMany?: WhatsAppMessageCreateManyConversationInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type WhatsAppMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<WhatsAppMessageCreateWithoutConversationInput, WhatsAppMessageUncheckedCreateWithoutConversationInput> | WhatsAppMessageCreateWithoutConversationInput[] | WhatsAppMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutConversationInput | WhatsAppMessageCreateOrConnectWithoutConversationInput[]
    createMany?: WhatsAppMessageCreateManyConversationInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumWhatsAppConversationStatusFieldUpdateOperationsInput = {
    set?: $Enums.WhatsAppConversationStatus
  }

  export type WhatsAppInstanceUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutConversationsInput, WhatsAppInstanceUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutConversationsInput
    upsert?: WhatsAppInstanceUpsertWithoutConversationsInput
    connect?: WhatsAppInstanceWhereUniqueInput
    update?: XOR<XOR<WhatsAppInstanceUpdateToOneWithWhereWithoutConversationsInput, WhatsAppInstanceUpdateWithoutConversationsInput>, WhatsAppInstanceUncheckedUpdateWithoutConversationsInput>
  }

  export type WhatsAppContactUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutConversationsInput, WhatsAppContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutConversationsInput
    upsert?: WhatsAppContactUpsertWithoutConversationsInput
    connect?: WhatsAppContactWhereUniqueInput
    update?: XOR<XOR<WhatsAppContactUpdateToOneWithWhereWithoutConversationsInput, WhatsAppContactUpdateWithoutConversationsInput>, WhatsAppContactUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneWithoutWhatsappConversationsAssignedNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappConversationsAssignedInput, UserUncheckedCreateWithoutWhatsappConversationsAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappConversationsAssignedInput
    upsert?: UserUpsertWithoutWhatsappConversationsAssignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsappConversationsAssignedInput, UserUpdateWithoutWhatsappConversationsAssignedInput>, UserUncheckedUpdateWithoutWhatsappConversationsAssignedInput>
  }

  export type AiAgentUpdateOneWithoutWhatsappConversationsNestedInput = {
    create?: XOR<AiAgentCreateWithoutWhatsappConversationsInput, AiAgentUncheckedCreateWithoutWhatsappConversationsInput>
    connectOrCreate?: AiAgentCreateOrConnectWithoutWhatsappConversationsInput
    upsert?: AiAgentUpsertWithoutWhatsappConversationsInput
    disconnect?: AiAgentWhereInput | boolean
    delete?: AiAgentWhereInput | boolean
    connect?: AiAgentWhereUniqueInput
    update?: XOR<XOR<AiAgentUpdateToOneWithWhereWithoutWhatsappConversationsInput, AiAgentUpdateWithoutWhatsappConversationsInput>, AiAgentUncheckedUpdateWithoutWhatsappConversationsInput>
  }

  export type WhatsAppMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutConversationInput, WhatsAppMessageUncheckedCreateWithoutConversationInput> | WhatsAppMessageCreateWithoutConversationInput[] | WhatsAppMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutConversationInput | WhatsAppMessageCreateOrConnectWithoutConversationInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutConversationInput | WhatsAppMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: WhatsAppMessageCreateManyConversationInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutConversationInput | WhatsAppMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutConversationInput | WhatsAppMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutConversationInput, WhatsAppMessageUncheckedCreateWithoutConversationInput> | WhatsAppMessageCreateWithoutConversationInput[] | WhatsAppMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutConversationInput | WhatsAppMessageCreateOrConnectWithoutConversationInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutConversationInput | WhatsAppMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: WhatsAppMessageCreateManyConversationInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutConversationInput | WhatsAppMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutConversationInput | WhatsAppMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type WhatsAppInstanceCreateNestedOneWithoutMessagesInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutMessagesInput, WhatsAppInstanceUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutMessagesInput
    connect?: WhatsAppInstanceWhereUniqueInput
  }

  export type WhatsAppConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<WhatsAppConversationCreateWithoutMessagesInput, WhatsAppConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutMessagesInput
    connect?: WhatsAppConversationWhereUniqueInput
  }

  export type WhatsAppContactCreateNestedOneWithoutMessagesInput = {
    create?: XOR<WhatsAppContactCreateWithoutMessagesInput, WhatsAppContactUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutMessagesInput
    connect?: WhatsAppContactWhereUniqueInput
  }

  export type ToolExecutionCreateNestedOneWithoutWhatsappMessagesInput = {
    create?: XOR<ToolExecutionCreateWithoutWhatsappMessagesInput, ToolExecutionUncheckedCreateWithoutWhatsappMessagesInput>
    connectOrCreate?: ToolExecutionCreateOrConnectWithoutWhatsappMessagesInput
    connect?: ToolExecutionWhereUniqueInput
  }

  export type EnumWhatsAppMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.WhatsAppMessageType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumWhatsAppMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.WhatsAppMessageStatus
  }

  export type WhatsAppInstanceUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutMessagesInput, WhatsAppInstanceUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutMessagesInput
    upsert?: WhatsAppInstanceUpsertWithoutMessagesInput
    connect?: WhatsAppInstanceWhereUniqueInput
    update?: XOR<XOR<WhatsAppInstanceUpdateToOneWithWhereWithoutMessagesInput, WhatsAppInstanceUpdateWithoutMessagesInput>, WhatsAppInstanceUncheckedUpdateWithoutMessagesInput>
  }

  export type WhatsAppConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutMessagesInput, WhatsAppConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutMessagesInput
    upsert?: WhatsAppConversationUpsertWithoutMessagesInput
    connect?: WhatsAppConversationWhereUniqueInput
    update?: XOR<XOR<WhatsAppConversationUpdateToOneWithWhereWithoutMessagesInput, WhatsAppConversationUpdateWithoutMessagesInput>, WhatsAppConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type WhatsAppContactUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutMessagesInput, WhatsAppContactUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutMessagesInput
    upsert?: WhatsAppContactUpsertWithoutMessagesInput
    connect?: WhatsAppContactWhereUniqueInput
    update?: XOR<XOR<WhatsAppContactUpdateToOneWithWhereWithoutMessagesInput, WhatsAppContactUpdateWithoutMessagesInput>, WhatsAppContactUncheckedUpdateWithoutMessagesInput>
  }

  export type ToolExecutionUpdateOneWithoutWhatsappMessagesNestedInput = {
    create?: XOR<ToolExecutionCreateWithoutWhatsappMessagesInput, ToolExecutionUncheckedCreateWithoutWhatsappMessagesInput>
    connectOrCreate?: ToolExecutionCreateOrConnectWithoutWhatsappMessagesInput
    upsert?: ToolExecutionUpsertWithoutWhatsappMessagesInput
    disconnect?: ToolExecutionWhereInput | boolean
    delete?: ToolExecutionWhereInput | boolean
    connect?: ToolExecutionWhereUniqueInput
    update?: XOR<XOR<ToolExecutionUpdateToOneWithWhereWithoutWhatsappMessagesInput, ToolExecutionUpdateWithoutWhatsappMessagesInput>, ToolExecutionUncheckedUpdateWithoutWhatsappMessagesInput>
  }

  export type WhatsAppImportCreatemediaFilesInput = {
    set: string[]
  }

  export type WhatsAppInstanceCreateNestedOneWithoutImportsInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutImportsInput, WhatsAppInstanceUncheckedCreateWithoutImportsInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutImportsInput
    connect?: WhatsAppInstanceWhereUniqueInput
  }

  export type WhatsAppContactCreateNestedOneWithoutImportsInput = {
    create?: XOR<WhatsAppContactCreateWithoutImportsInput, WhatsAppContactUncheckedCreateWithoutImportsInput>
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutImportsInput
    connect?: WhatsAppContactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWhatsappImportsUploadedInput = {
    create?: XOR<UserCreateWithoutWhatsappImportsUploadedInput, UserUncheckedCreateWithoutWhatsappImportsUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappImportsUploadedInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppImportUpdatemediaFilesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumWhatsAppImportStatusFieldUpdateOperationsInput = {
    set?: $Enums.WhatsAppImportStatus
  }

  export type WhatsAppInstanceUpdateOneRequiredWithoutImportsNestedInput = {
    create?: XOR<WhatsAppInstanceCreateWithoutImportsInput, WhatsAppInstanceUncheckedCreateWithoutImportsInput>
    connectOrCreate?: WhatsAppInstanceCreateOrConnectWithoutImportsInput
    upsert?: WhatsAppInstanceUpsertWithoutImportsInput
    connect?: WhatsAppInstanceWhereUniqueInput
    update?: XOR<XOR<WhatsAppInstanceUpdateToOneWithWhereWithoutImportsInput, WhatsAppInstanceUpdateWithoutImportsInput>, WhatsAppInstanceUncheckedUpdateWithoutImportsInput>
  }

  export type WhatsAppContactUpdateOneRequiredWithoutImportsNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutImportsInput, WhatsAppContactUncheckedCreateWithoutImportsInput>
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutImportsInput
    upsert?: WhatsAppContactUpsertWithoutImportsInput
    connect?: WhatsAppContactWhereUniqueInput
    update?: XOR<XOR<WhatsAppContactUpdateToOneWithWhereWithoutImportsInput, WhatsAppContactUpdateWithoutImportsInput>, WhatsAppContactUncheckedUpdateWithoutImportsInput>
  }

  export type UserUpdateOneRequiredWithoutWhatsappImportsUploadedNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappImportsUploadedInput, UserUncheckedCreateWithoutWhatsappImportsUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappImportsUploadedInput
    upsert?: UserUpsertWithoutWhatsappImportsUploadedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsappImportsUploadedInput, UserUpdateWithoutWhatsappImportsUploadedInput>, UserUncheckedUpdateWithoutWhatsappImportsUploadedInput>
  }

  export type OfficeCreateNestedOneWithoutClientsInput = {
    create?: XOR<OfficeCreateWithoutClientsInput, OfficeUncheckedCreateWithoutClientsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutClientsInput
    connect?: OfficeWhereUniqueInput
  }

  export type ConversationCreateNestedManyWithoutClientInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientTagCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientTagCreateWithoutClientInput, ClientTagUncheckedCreateWithoutClientInput> | ClientTagCreateWithoutClientInput[] | ClientTagUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutClientInput | ClientTagCreateOrConnectWithoutClientInput[]
    createMany?: ClientTagCreateManyClientInputEnvelope
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
  }

  export type WhatsAppContactCreateNestedManyWithoutClientInput = {
    create?: XOR<WhatsAppContactCreateWithoutClientInput, WhatsAppContactUncheckedCreateWithoutClientInput> | WhatsAppContactCreateWithoutClientInput[] | WhatsAppContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutClientInput | WhatsAppContactCreateOrConnectWithoutClientInput[]
    createMany?: WhatsAppContactCreateManyClientInputEnvelope
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientTagUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientTagCreateWithoutClientInput, ClientTagUncheckedCreateWithoutClientInput> | ClientTagCreateWithoutClientInput[] | ClientTagUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutClientInput | ClientTagCreateOrConnectWithoutClientInput[]
    createMany?: ClientTagCreateManyClientInputEnvelope
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
  }

  export type WhatsAppContactUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<WhatsAppContactCreateWithoutClientInput, WhatsAppContactUncheckedCreateWithoutClientInput> | WhatsAppContactCreateWithoutClientInput[] | WhatsAppContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutClientInput | WhatsAppContactCreateOrConnectWithoutClientInput[]
    createMany?: WhatsAppContactCreateManyClientInputEnvelope
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
  }

  export type OfficeUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<OfficeCreateWithoutClientsInput, OfficeUncheckedCreateWithoutClientsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutClientsInput
    upsert?: OfficeUpsertWithoutClientsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutClientsInput, OfficeUpdateWithoutClientsInput>, OfficeUncheckedUpdateWithoutClientsInput>
  }

  export type ConversationUpdateManyWithoutClientNestedInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutClientInput | ConversationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutClientInput | ConversationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutClientInput | ConversationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientTagUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientTagCreateWithoutClientInput, ClientTagUncheckedCreateWithoutClientInput> | ClientTagCreateWithoutClientInput[] | ClientTagUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutClientInput | ClientTagCreateOrConnectWithoutClientInput[]
    upsert?: ClientTagUpsertWithWhereUniqueWithoutClientInput | ClientTagUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientTagCreateManyClientInputEnvelope
    set?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    disconnect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    delete?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    update?: ClientTagUpdateWithWhereUniqueWithoutClientInput | ClientTagUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientTagUpdateManyWithWhereWithoutClientInput | ClientTagUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientTagScalarWhereInput | ClientTagScalarWhereInput[]
  }

  export type WhatsAppContactUpdateManyWithoutClientNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutClientInput, WhatsAppContactUncheckedCreateWithoutClientInput> | WhatsAppContactCreateWithoutClientInput[] | WhatsAppContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutClientInput | WhatsAppContactCreateOrConnectWithoutClientInput[]
    upsert?: WhatsAppContactUpsertWithWhereUniqueWithoutClientInput | WhatsAppContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: WhatsAppContactCreateManyClientInputEnvelope
    set?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    disconnect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    delete?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    update?: WhatsAppContactUpdateWithWhereUniqueWithoutClientInput | WhatsAppContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: WhatsAppContactUpdateManyWithWhereWithoutClientInput | WhatsAppContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput> | ConversationCreateWithoutClientInput[] | ConversationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutClientInput | ConversationCreateOrConnectWithoutClientInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutClientInput | ConversationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ConversationCreateManyClientInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutClientInput | ConversationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutClientInput | ConversationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientTagUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientTagCreateWithoutClientInput, ClientTagUncheckedCreateWithoutClientInput> | ClientTagCreateWithoutClientInput[] | ClientTagUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutClientInput | ClientTagCreateOrConnectWithoutClientInput[]
    upsert?: ClientTagUpsertWithWhereUniqueWithoutClientInput | ClientTagUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientTagCreateManyClientInputEnvelope
    set?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    disconnect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    delete?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    update?: ClientTagUpdateWithWhereUniqueWithoutClientInput | ClientTagUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientTagUpdateManyWithWhereWithoutClientInput | ClientTagUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientTagScalarWhereInput | ClientTagScalarWhereInput[]
  }

  export type WhatsAppContactUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<WhatsAppContactCreateWithoutClientInput, WhatsAppContactUncheckedCreateWithoutClientInput> | WhatsAppContactCreateWithoutClientInput[] | WhatsAppContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: WhatsAppContactCreateOrConnectWithoutClientInput | WhatsAppContactCreateOrConnectWithoutClientInput[]
    upsert?: WhatsAppContactUpsertWithWhereUniqueWithoutClientInput | WhatsAppContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: WhatsAppContactCreateManyClientInputEnvelope
    set?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    disconnect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    delete?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    connect?: WhatsAppContactWhereUniqueInput | WhatsAppContactWhereUniqueInput[]
    update?: WhatsAppContactUpdateWithWhereUniqueWithoutClientInput | WhatsAppContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: WhatsAppContactUpdateManyWithWhereWithoutClientInput | WhatsAppContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutConversationsInput
    connect?: ClientWhereUniqueInput
  }

  export type OfficeCreateNestedOneWithoutConversationsInput = {
    create?: XOR<OfficeCreateWithoutConversationsInput, OfficeUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutConversationsInput
    connect?: OfficeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedConversationsInput = {
    create?: XOR<UserCreateWithoutCreatedConversationsInput, UserUncheckedCreateWithoutCreatedConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedConversationsInput = {
    create?: XOR<UserCreateWithoutAssignedConversationsInput, UserUncheckedCreateWithoutAssignedConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsappConfigCreateNestedOneWithoutConversationsInput = {
    create?: XOR<WhatsappConfigCreateWithoutConversationsInput, WhatsappConfigUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutConversationsInput
    connect?: WhatsappConfigWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationTagCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationTagCreateWithoutConversationInput, ConversationTagUncheckedCreateWithoutConversationInput> | ConversationTagCreateWithoutConversationInput[] | ConversationTagUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutConversationInput | ConversationTagCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationTagCreateManyConversationInputEnvelope
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
  }

  export type ConversationCustomStatusCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutConversationInput, ConversationCustomStatusUncheckedCreateWithoutConversationInput> | ConversationCustomStatusCreateWithoutConversationInput[] | ConversationCustomStatusUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutConversationInput | ConversationCustomStatusCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationCustomStatusCreateManyConversationInputEnvelope
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationTagUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationTagCreateWithoutConversationInput, ConversationTagUncheckedCreateWithoutConversationInput> | ConversationTagCreateWithoutConversationInput[] | ConversationTagUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutConversationInput | ConversationTagCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationTagCreateManyConversationInputEnvelope
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
  }

  export type ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutConversationInput, ConversationCustomStatusUncheckedCreateWithoutConversationInput> | ConversationCustomStatusCreateWithoutConversationInput[] | ConversationCustomStatusUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutConversationInput | ConversationCustomStatusCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationCustomStatusCreateManyConversationInputEnvelope
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
  }

  export type EnumConversationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConversationStatus
  }

  export type NullableEnumAgentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgentType | null
  }

  export type ClientUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutConversationsInput
    upsert?: ClientUpsertWithoutConversationsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutConversationsInput, ClientUpdateWithoutConversationsInput>, ClientUncheckedUpdateWithoutConversationsInput>
  }

  export type OfficeUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<OfficeCreateWithoutConversationsInput, OfficeUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutConversationsInput
    upsert?: OfficeUpsertWithoutConversationsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutConversationsInput, OfficeUpdateWithoutConversationsInput>, OfficeUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedConversationsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedConversationsInput, UserUncheckedCreateWithoutCreatedConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedConversationsInput
    upsert?: UserUpsertWithoutCreatedConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedConversationsInput, UserUpdateWithoutCreatedConversationsInput>, UserUncheckedUpdateWithoutCreatedConversationsInput>
  }

  export type UserUpdateOneWithoutAssignedConversationsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedConversationsInput, UserUncheckedCreateWithoutAssignedConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedConversationsInput
    upsert?: UserUpsertWithoutAssignedConversationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedConversationsInput, UserUpdateWithoutAssignedConversationsInput>, UserUncheckedUpdateWithoutAssignedConversationsInput>
  }

  export type WhatsappConfigUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<WhatsappConfigCreateWithoutConversationsInput, WhatsappConfigUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutConversationsInput
    upsert?: WhatsappConfigUpsertWithoutConversationsInput
    disconnect?: WhatsappConfigWhereInput | boolean
    delete?: WhatsappConfigWhereInput | boolean
    connect?: WhatsappConfigWhereUniqueInput
    update?: XOR<XOR<WhatsappConfigUpdateToOneWithWhereWithoutConversationsInput, WhatsappConfigUpdateWithoutConversationsInput>, WhatsappConfigUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationTagUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationTagCreateWithoutConversationInput, ConversationTagUncheckedCreateWithoutConversationInput> | ConversationTagCreateWithoutConversationInput[] | ConversationTagUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutConversationInput | ConversationTagCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationTagUpsertWithWhereUniqueWithoutConversationInput | ConversationTagUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationTagCreateManyConversationInputEnvelope
    set?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    disconnect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    delete?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    update?: ConversationTagUpdateWithWhereUniqueWithoutConversationInput | ConversationTagUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationTagUpdateManyWithWhereWithoutConversationInput | ConversationTagUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationTagScalarWhereInput | ConversationTagScalarWhereInput[]
  }

  export type ConversationCustomStatusUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutConversationInput, ConversationCustomStatusUncheckedCreateWithoutConversationInput> | ConversationCustomStatusCreateWithoutConversationInput[] | ConversationCustomStatusUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutConversationInput | ConversationCustomStatusCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationCustomStatusUpsertWithWhereUniqueWithoutConversationInput | ConversationCustomStatusUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationCustomStatusCreateManyConversationInputEnvelope
    set?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    disconnect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    delete?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    update?: ConversationCustomStatusUpdateWithWhereUniqueWithoutConversationInput | ConversationCustomStatusUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationCustomStatusUpdateManyWithWhereWithoutConversationInput | ConversationCustomStatusUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationCustomStatusScalarWhereInput | ConversationCustomStatusScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationTagUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationTagCreateWithoutConversationInput, ConversationTagUncheckedCreateWithoutConversationInput> | ConversationTagCreateWithoutConversationInput[] | ConversationTagUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutConversationInput | ConversationTagCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationTagUpsertWithWhereUniqueWithoutConversationInput | ConversationTagUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationTagCreateManyConversationInputEnvelope
    set?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    disconnect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    delete?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    update?: ConversationTagUpdateWithWhereUniqueWithoutConversationInput | ConversationTagUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationTagUpdateManyWithWhereWithoutConversationInput | ConversationTagUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationTagScalarWhereInput | ConversationTagScalarWhereInput[]
  }

  export type ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutConversationInput, ConversationCustomStatusUncheckedCreateWithoutConversationInput> | ConversationCustomStatusCreateWithoutConversationInput[] | ConversationCustomStatusUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutConversationInput | ConversationCustomStatusCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationCustomStatusUpsertWithWhereUniqueWithoutConversationInput | ConversationCustomStatusUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationCustomStatusCreateManyConversationInputEnvelope
    set?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    disconnect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    delete?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    update?: ConversationCustomStatusUpdateWithWhereUniqueWithoutConversationInput | ConversationCustomStatusUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationCustomStatusUpdateManyWithWhereWithoutConversationInput | ConversationCustomStatusUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationCustomStatusScalarWhereInput | ConversationCustomStatusScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsappConfigCreateNestedOneWithoutMessagesInput = {
    create?: XOR<WhatsappConfigCreateWithoutMessagesInput, WhatsappConfigUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutMessagesInput
    connect?: WhatsappConfigWhereUniqueInput
  }

  export type AudioTranscriptionCreateNestedOneWithoutMessageInput = {
    create?: XOR<AudioTranscriptionCreateWithoutMessageInput, AudioTranscriptionUncheckedCreateWithoutMessageInput>
    connectOrCreate?: AudioTranscriptionCreateOrConnectWithoutMessageInput
    connect?: AudioTranscriptionWhereUniqueInput
  }

  export type AudioTranscriptionUncheckedCreateNestedOneWithoutMessageInput = {
    create?: XOR<AudioTranscriptionCreateWithoutMessageInput, AudioTranscriptionUncheckedCreateWithoutMessageInput>
    connectOrCreate?: AudioTranscriptionCreateOrConnectWithoutMessageInput
    connect?: AudioTranscriptionWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type WhatsappConfigUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<WhatsappConfigCreateWithoutMessagesInput, WhatsappConfigUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: WhatsappConfigCreateOrConnectWithoutMessagesInput
    upsert?: WhatsappConfigUpsertWithoutMessagesInput
    disconnect?: WhatsappConfigWhereInput | boolean
    delete?: WhatsappConfigWhereInput | boolean
    connect?: WhatsappConfigWhereUniqueInput
    update?: XOR<XOR<WhatsappConfigUpdateToOneWithWhereWithoutMessagesInput, WhatsappConfigUpdateWithoutMessagesInput>, WhatsappConfigUncheckedUpdateWithoutMessagesInput>
  }

  export type AudioTranscriptionUpdateOneWithoutMessageNestedInput = {
    create?: XOR<AudioTranscriptionCreateWithoutMessageInput, AudioTranscriptionUncheckedCreateWithoutMessageInput>
    connectOrCreate?: AudioTranscriptionCreateOrConnectWithoutMessageInput
    upsert?: AudioTranscriptionUpsertWithoutMessageInput
    disconnect?: AudioTranscriptionWhereInput | boolean
    delete?: AudioTranscriptionWhereInput | boolean
    connect?: AudioTranscriptionWhereUniqueInput
    update?: XOR<XOR<AudioTranscriptionUpdateToOneWithWhereWithoutMessageInput, AudioTranscriptionUpdateWithoutMessageInput>, AudioTranscriptionUncheckedUpdateWithoutMessageInput>
  }

  export type AudioTranscriptionUncheckedUpdateOneWithoutMessageNestedInput = {
    create?: XOR<AudioTranscriptionCreateWithoutMessageInput, AudioTranscriptionUncheckedCreateWithoutMessageInput>
    connectOrCreate?: AudioTranscriptionCreateOrConnectWithoutMessageInput
    upsert?: AudioTranscriptionUpsertWithoutMessageInput
    disconnect?: AudioTranscriptionWhereInput | boolean
    delete?: AudioTranscriptionWhereInput | boolean
    connect?: AudioTranscriptionWhereUniqueInput
    update?: XOR<XOR<AudioTranscriptionUpdateToOneWithWhereWithoutMessageInput, AudioTranscriptionUpdateWithoutMessageInput>, AudioTranscriptionUncheckedUpdateWithoutMessageInput>
  }

  export type MessageCreateNestedOneWithoutAudioTranscriptionInput = {
    create?: XOR<MessageCreateWithoutAudioTranscriptionInput, MessageUncheckedCreateWithoutAudioTranscriptionInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAudioTranscriptionInput
    connect?: MessageWhereUniqueInput
  }

  export type EnumTranscriptionProviderFieldUpdateOperationsInput = {
    set?: $Enums.TranscriptionProvider
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MessageUpdateOneRequiredWithoutAudioTranscriptionNestedInput = {
    create?: XOR<MessageCreateWithoutAudioTranscriptionInput, MessageUncheckedCreateWithoutAudioTranscriptionInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAudioTranscriptionInput
    upsert?: MessageUpsertWithoutAudioTranscriptionInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAudioTranscriptionInput, MessageUpdateWithoutAudioTranscriptionInput>, MessageUncheckedUpdateWithoutAudioTranscriptionInput>
  }

  export type OfficeCreateNestedOneWithoutTagsInput = {
    create?: XOR<OfficeCreateWithoutTagsInput, OfficeUncheckedCreateWithoutTagsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutTagsInput
    connect?: OfficeWhereUniqueInput
  }

  export type ClientTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ClientTagCreateWithoutTagInput, ClientTagUncheckedCreateWithoutTagInput> | ClientTagCreateWithoutTagInput[] | ClientTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutTagInput | ClientTagCreateOrConnectWithoutTagInput[]
    createMany?: ClientTagCreateManyTagInputEnvelope
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
  }

  export type ConversationTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ConversationTagCreateWithoutTagInput, ConversationTagUncheckedCreateWithoutTagInput> | ConversationTagCreateWithoutTagInput[] | ConversationTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutTagInput | ConversationTagCreateOrConnectWithoutTagInput[]
    createMany?: ConversationTagCreateManyTagInputEnvelope
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
  }

  export type ClientTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ClientTagCreateWithoutTagInput, ClientTagUncheckedCreateWithoutTagInput> | ClientTagCreateWithoutTagInput[] | ClientTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutTagInput | ClientTagCreateOrConnectWithoutTagInput[]
    createMany?: ClientTagCreateManyTagInputEnvelope
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
  }

  export type ConversationTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ConversationTagCreateWithoutTagInput, ConversationTagUncheckedCreateWithoutTagInput> | ConversationTagCreateWithoutTagInput[] | ConversationTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutTagInput | ConversationTagCreateOrConnectWithoutTagInput[]
    createMany?: ConversationTagCreateManyTagInputEnvelope
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
  }

  export type OfficeUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<OfficeCreateWithoutTagsInput, OfficeUncheckedCreateWithoutTagsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutTagsInput
    upsert?: OfficeUpsertWithoutTagsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutTagsInput, OfficeUpdateWithoutTagsInput>, OfficeUncheckedUpdateWithoutTagsInput>
  }

  export type ClientTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ClientTagCreateWithoutTagInput, ClientTagUncheckedCreateWithoutTagInput> | ClientTagCreateWithoutTagInput[] | ClientTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutTagInput | ClientTagCreateOrConnectWithoutTagInput[]
    upsert?: ClientTagUpsertWithWhereUniqueWithoutTagInput | ClientTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ClientTagCreateManyTagInputEnvelope
    set?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    disconnect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    delete?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    update?: ClientTagUpdateWithWhereUniqueWithoutTagInput | ClientTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ClientTagUpdateManyWithWhereWithoutTagInput | ClientTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ClientTagScalarWhereInput | ClientTagScalarWhereInput[]
  }

  export type ConversationTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ConversationTagCreateWithoutTagInput, ConversationTagUncheckedCreateWithoutTagInput> | ConversationTagCreateWithoutTagInput[] | ConversationTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutTagInput | ConversationTagCreateOrConnectWithoutTagInput[]
    upsert?: ConversationTagUpsertWithWhereUniqueWithoutTagInput | ConversationTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ConversationTagCreateManyTagInputEnvelope
    set?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    disconnect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    delete?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    update?: ConversationTagUpdateWithWhereUniqueWithoutTagInput | ConversationTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ConversationTagUpdateManyWithWhereWithoutTagInput | ConversationTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ConversationTagScalarWhereInput | ConversationTagScalarWhereInput[]
  }

  export type ClientTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ClientTagCreateWithoutTagInput, ClientTagUncheckedCreateWithoutTagInput> | ClientTagCreateWithoutTagInput[] | ClientTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ClientTagCreateOrConnectWithoutTagInput | ClientTagCreateOrConnectWithoutTagInput[]
    upsert?: ClientTagUpsertWithWhereUniqueWithoutTagInput | ClientTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ClientTagCreateManyTagInputEnvelope
    set?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    disconnect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    delete?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    connect?: ClientTagWhereUniqueInput | ClientTagWhereUniqueInput[]
    update?: ClientTagUpdateWithWhereUniqueWithoutTagInput | ClientTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ClientTagUpdateManyWithWhereWithoutTagInput | ClientTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ClientTagScalarWhereInput | ClientTagScalarWhereInput[]
  }

  export type ConversationTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ConversationTagCreateWithoutTagInput, ConversationTagUncheckedCreateWithoutTagInput> | ConversationTagCreateWithoutTagInput[] | ConversationTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ConversationTagCreateOrConnectWithoutTagInput | ConversationTagCreateOrConnectWithoutTagInput[]
    upsert?: ConversationTagUpsertWithWhereUniqueWithoutTagInput | ConversationTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ConversationTagCreateManyTagInputEnvelope
    set?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    disconnect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    delete?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    connect?: ConversationTagWhereUniqueInput | ConversationTagWhereUniqueInput[]
    update?: ConversationTagUpdateWithWhereUniqueWithoutTagInput | ConversationTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ConversationTagUpdateManyWithWhereWithoutTagInput | ConversationTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ConversationTagScalarWhereInput | ConversationTagScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutClientTagsInput = {
    create?: XOR<ClientCreateWithoutClientTagsInput, ClientUncheckedCreateWithoutClientTagsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientTagsInput
    connect?: ClientWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutClientTagsInput = {
    create?: XOR<TagCreateWithoutClientTagsInput, TagUncheckedCreateWithoutClientTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutClientTagsInput
    connect?: TagWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutClientTagsNestedInput = {
    create?: XOR<ClientCreateWithoutClientTagsInput, ClientUncheckedCreateWithoutClientTagsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientTagsInput
    upsert?: ClientUpsertWithoutClientTagsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientTagsInput, ClientUpdateWithoutClientTagsInput>, ClientUncheckedUpdateWithoutClientTagsInput>
  }

  export type TagUpdateOneRequiredWithoutClientTagsNestedInput = {
    create?: XOR<TagCreateWithoutClientTagsInput, TagUncheckedCreateWithoutClientTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutClientTagsInput
    upsert?: TagUpsertWithoutClientTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutClientTagsInput, TagUpdateWithoutClientTagsInput>, TagUncheckedUpdateWithoutClientTagsInput>
  }

  export type ConversationCreateNestedOneWithoutConversationTagsInput = {
    create?: XOR<ConversationCreateWithoutConversationTagsInput, ConversationUncheckedCreateWithoutConversationTagsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationTagsInput
    connect?: ConversationWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutConversationTagsInput = {
    create?: XOR<TagCreateWithoutConversationTagsInput, TagUncheckedCreateWithoutConversationTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutConversationTagsInput
    connect?: TagWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutConversationTagsNestedInput = {
    create?: XOR<ConversationCreateWithoutConversationTagsInput, ConversationUncheckedCreateWithoutConversationTagsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationTagsInput
    upsert?: ConversationUpsertWithoutConversationTagsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutConversationTagsInput, ConversationUpdateWithoutConversationTagsInput>, ConversationUncheckedUpdateWithoutConversationTagsInput>
  }

  export type TagUpdateOneRequiredWithoutConversationTagsNestedInput = {
    create?: XOR<TagCreateWithoutConversationTagsInput, TagUncheckedCreateWithoutConversationTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutConversationTagsInput
    upsert?: TagUpsertWithoutConversationTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutConversationTagsInput, TagUpdateWithoutConversationTagsInput>, TagUncheckedUpdateWithoutConversationTagsInput>
  }

  export type OfficeCreateNestedOneWithoutCustomStatusesInput = {
    create?: XOR<OfficeCreateWithoutCustomStatusesInput, OfficeUncheckedCreateWithoutCustomStatusesInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutCustomStatusesInput
    connect?: OfficeWhereUniqueInput
  }

  export type ConversationCustomStatusCreateNestedManyWithoutCustomStatusInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutCustomStatusInput, ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput> | ConversationCustomStatusCreateWithoutCustomStatusInput[] | ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput | ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput[]
    createMany?: ConversationCustomStatusCreateManyCustomStatusInputEnvelope
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
  }

  export type ConversationCustomStatusUncheckedCreateNestedManyWithoutCustomStatusInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutCustomStatusInput, ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput> | ConversationCustomStatusCreateWithoutCustomStatusInput[] | ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput | ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput[]
    createMany?: ConversationCustomStatusCreateManyCustomStatusInputEnvelope
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
  }

  export type OfficeUpdateOneRequiredWithoutCustomStatusesNestedInput = {
    create?: XOR<OfficeCreateWithoutCustomStatusesInput, OfficeUncheckedCreateWithoutCustomStatusesInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutCustomStatusesInput
    upsert?: OfficeUpsertWithoutCustomStatusesInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutCustomStatusesInput, OfficeUpdateWithoutCustomStatusesInput>, OfficeUncheckedUpdateWithoutCustomStatusesInput>
  }

  export type ConversationCustomStatusUpdateManyWithoutCustomStatusNestedInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutCustomStatusInput, ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput> | ConversationCustomStatusCreateWithoutCustomStatusInput[] | ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput | ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput[]
    upsert?: ConversationCustomStatusUpsertWithWhereUniqueWithoutCustomStatusInput | ConversationCustomStatusUpsertWithWhereUniqueWithoutCustomStatusInput[]
    createMany?: ConversationCustomStatusCreateManyCustomStatusInputEnvelope
    set?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    disconnect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    delete?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    update?: ConversationCustomStatusUpdateWithWhereUniqueWithoutCustomStatusInput | ConversationCustomStatusUpdateWithWhereUniqueWithoutCustomStatusInput[]
    updateMany?: ConversationCustomStatusUpdateManyWithWhereWithoutCustomStatusInput | ConversationCustomStatusUpdateManyWithWhereWithoutCustomStatusInput[]
    deleteMany?: ConversationCustomStatusScalarWhereInput | ConversationCustomStatusScalarWhereInput[]
  }

  export type ConversationCustomStatusUncheckedUpdateManyWithoutCustomStatusNestedInput = {
    create?: XOR<ConversationCustomStatusCreateWithoutCustomStatusInput, ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput> | ConversationCustomStatusCreateWithoutCustomStatusInput[] | ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput[]
    connectOrCreate?: ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput | ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput[]
    upsert?: ConversationCustomStatusUpsertWithWhereUniqueWithoutCustomStatusInput | ConversationCustomStatusUpsertWithWhereUniqueWithoutCustomStatusInput[]
    createMany?: ConversationCustomStatusCreateManyCustomStatusInputEnvelope
    set?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    disconnect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    delete?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    connect?: ConversationCustomStatusWhereUniqueInput | ConversationCustomStatusWhereUniqueInput[]
    update?: ConversationCustomStatusUpdateWithWhereUniqueWithoutCustomStatusInput | ConversationCustomStatusUpdateWithWhereUniqueWithoutCustomStatusInput[]
    updateMany?: ConversationCustomStatusUpdateManyWithWhereWithoutCustomStatusInput | ConversationCustomStatusUpdateManyWithWhereWithoutCustomStatusInput[]
    deleteMany?: ConversationCustomStatusScalarWhereInput | ConversationCustomStatusScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutConversationStatusInput = {
    create?: XOR<ConversationCreateWithoutConversationStatusInput, ConversationUncheckedCreateWithoutConversationStatusInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationStatusInput
    connect?: ConversationWhereUniqueInput
  }

  export type CustomStatusCreateNestedOneWithoutConversationStatusesInput = {
    create?: XOR<CustomStatusCreateWithoutConversationStatusesInput, CustomStatusUncheckedCreateWithoutConversationStatusesInput>
    connectOrCreate?: CustomStatusCreateOrConnectWithoutConversationStatusesInput
    connect?: CustomStatusWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutConversationStatusNestedInput = {
    create?: XOR<ConversationCreateWithoutConversationStatusInput, ConversationUncheckedCreateWithoutConversationStatusInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutConversationStatusInput
    upsert?: ConversationUpsertWithoutConversationStatusInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutConversationStatusInput, ConversationUpdateWithoutConversationStatusInput>, ConversationUncheckedUpdateWithoutConversationStatusInput>
  }

  export type CustomStatusUpdateOneRequiredWithoutConversationStatusesNestedInput = {
    create?: XOR<CustomStatusCreateWithoutConversationStatusesInput, CustomStatusUncheckedCreateWithoutConversationStatusesInput>
    connectOrCreate?: CustomStatusCreateOrConnectWithoutConversationStatusesInput
    upsert?: CustomStatusUpsertWithoutConversationStatusesInput
    connect?: CustomStatusWhereUniqueInput
    update?: XOR<XOR<CustomStatusUpdateToOneWithWhereWithoutConversationStatusesInput, CustomStatusUpdateWithoutConversationStatusesInput>, CustomStatusUncheckedUpdateWithoutConversationStatusesInput>
  }

  export type OfficeCreateNestedOneWithoutAiAgentsInput = {
    create?: XOR<OfficeCreateWithoutAiAgentsInput, OfficeUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutAiAgentsInput
    connect?: OfficeWhereUniqueInput
  }

  export type WhatsAppConversationCreateNestedManyWithoutCurrentAgentInput = {
    create?: XOR<WhatsAppConversationCreateWithoutCurrentAgentInput, WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput> | WhatsAppConversationCreateWithoutCurrentAgentInput[] | WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput | WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput[]
    createMany?: WhatsAppConversationCreateManyCurrentAgentInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type WhatsAppConversationUncheckedCreateNestedManyWithoutCurrentAgentInput = {
    create?: XOR<WhatsAppConversationCreateWithoutCurrentAgentInput, WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput> | WhatsAppConversationCreateWithoutCurrentAgentInput[] | WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput | WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput[]
    createMany?: WhatsAppConversationCreateManyCurrentAgentInputEnvelope
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
  }

  export type EnumAgentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgentType
  }

  export type EnumAIProviderFieldUpdateOperationsInput = {
    set?: $Enums.AIProvider
  }

  export type EnumAIModelFieldUpdateOperationsInput = {
    set?: $Enums.AIModel
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OfficeUpdateOneRequiredWithoutAiAgentsNestedInput = {
    create?: XOR<OfficeCreateWithoutAiAgentsInput, OfficeUncheckedCreateWithoutAiAgentsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutAiAgentsInput
    upsert?: OfficeUpsertWithoutAiAgentsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutAiAgentsInput, OfficeUpdateWithoutAiAgentsInput>, OfficeUncheckedUpdateWithoutAiAgentsInput>
  }

  export type WhatsAppConversationUpdateManyWithoutCurrentAgentNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutCurrentAgentInput, WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput> | WhatsAppConversationCreateWithoutCurrentAgentInput[] | WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput | WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutCurrentAgentInput | WhatsAppConversationUpsertWithWhereUniqueWithoutCurrentAgentInput[]
    createMany?: WhatsAppConversationCreateManyCurrentAgentInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutCurrentAgentInput | WhatsAppConversationUpdateWithWhereUniqueWithoutCurrentAgentInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutCurrentAgentInput | WhatsAppConversationUpdateManyWithWhereWithoutCurrentAgentInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutCurrentAgentNestedInput = {
    create?: XOR<WhatsAppConversationCreateWithoutCurrentAgentInput, WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput> | WhatsAppConversationCreateWithoutCurrentAgentInput[] | WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput[]
    connectOrCreate?: WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput | WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput[]
    upsert?: WhatsAppConversationUpsertWithWhereUniqueWithoutCurrentAgentInput | WhatsAppConversationUpsertWithWhereUniqueWithoutCurrentAgentInput[]
    createMany?: WhatsAppConversationCreateManyCurrentAgentInputEnvelope
    set?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    disconnect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    delete?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    connect?: WhatsAppConversationWhereUniqueInput | WhatsAppConversationWhereUniqueInput[]
    update?: WhatsAppConversationUpdateWithWhereUniqueWithoutCurrentAgentInput | WhatsAppConversationUpdateWithWhereUniqueWithoutCurrentAgentInput[]
    updateMany?: WhatsAppConversationUpdateManyWithWhereWithoutCurrentAgentInput | WhatsAppConversationUpdateManyWithWhereWithoutCurrentAgentInput[]
    deleteMany?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
  }

  export type OfficeCreateNestedOneWithoutAiConfigsInput = {
    create?: XOR<OfficeCreateWithoutAiConfigsInput, OfficeUncheckedCreateWithoutAiConfigsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutAiConfigsInput
    connect?: OfficeWhereUniqueInput
  }

  export type OfficeUpdateOneRequiredWithoutAiConfigsNestedInput = {
    create?: XOR<OfficeCreateWithoutAiConfigsInput, OfficeUncheckedCreateWithoutAiConfigsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutAiConfigsInput
    upsert?: OfficeUpsertWithoutAiConfigsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutAiConfigsInput, OfficeUpdateWithoutAiConfigsInput>, OfficeUncheckedUpdateWithoutAiConfigsInput>
  }

  export type ClientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
  }

  export type OfficeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<OfficeCreateWithoutDocumentsInput, OfficeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutDocumentsInput
    connect?: OfficeWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    upsert?: ClientUpsertWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDocumentsInput, ClientUpdateWithoutDocumentsInput>, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type OfficeUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<OfficeCreateWithoutDocumentsInput, OfficeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutDocumentsInput
    upsert?: OfficeUpsertWithoutDocumentsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutDocumentsInput, OfficeUpdateWithoutDocumentsInput>, OfficeUncheckedUpdateWithoutDocumentsInput>
  }

  export type OfficeCreateNestedOneWithoutToolsInput = {
    create?: XOR<OfficeCreateWithoutToolsInput, OfficeUncheckedCreateWithoutToolsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutToolsInput
    connect?: OfficeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutToolsCreatedInput = {
    create?: XOR<UserCreateWithoutToolsCreatedInput, UserUncheckedCreateWithoutToolsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutToolsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ToolExecutionCreateNestedManyWithoutToolInput = {
    create?: XOR<ToolExecutionCreateWithoutToolInput, ToolExecutionUncheckedCreateWithoutToolInput> | ToolExecutionCreateWithoutToolInput[] | ToolExecutionUncheckedCreateWithoutToolInput[]
    connectOrCreate?: ToolExecutionCreateOrConnectWithoutToolInput | ToolExecutionCreateOrConnectWithoutToolInput[]
    createMany?: ToolExecutionCreateManyToolInputEnvelope
    connect?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
  }

  export type ToolExecutionUncheckedCreateNestedManyWithoutToolInput = {
    create?: XOR<ToolExecutionCreateWithoutToolInput, ToolExecutionUncheckedCreateWithoutToolInput> | ToolExecutionCreateWithoutToolInput[] | ToolExecutionUncheckedCreateWithoutToolInput[]
    connectOrCreate?: ToolExecutionCreateOrConnectWithoutToolInput | ToolExecutionCreateOrConnectWithoutToolInput[]
    createMany?: ToolExecutionCreateManyToolInputEnvelope
    connect?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
  }

  export type OfficeUpdateOneRequiredWithoutToolsNestedInput = {
    create?: XOR<OfficeCreateWithoutToolsInput, OfficeUncheckedCreateWithoutToolsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutToolsInput
    upsert?: OfficeUpsertWithoutToolsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutToolsInput, OfficeUpdateWithoutToolsInput>, OfficeUncheckedUpdateWithoutToolsInput>
  }

  export type UserUpdateOneRequiredWithoutToolsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutToolsCreatedInput, UserUncheckedCreateWithoutToolsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutToolsCreatedInput
    upsert?: UserUpsertWithoutToolsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutToolsCreatedInput, UserUpdateWithoutToolsCreatedInput>, UserUncheckedUpdateWithoutToolsCreatedInput>
  }

  export type ToolExecutionUpdateManyWithoutToolNestedInput = {
    create?: XOR<ToolExecutionCreateWithoutToolInput, ToolExecutionUncheckedCreateWithoutToolInput> | ToolExecutionCreateWithoutToolInput[] | ToolExecutionUncheckedCreateWithoutToolInput[]
    connectOrCreate?: ToolExecutionCreateOrConnectWithoutToolInput | ToolExecutionCreateOrConnectWithoutToolInput[]
    upsert?: ToolExecutionUpsertWithWhereUniqueWithoutToolInput | ToolExecutionUpsertWithWhereUniqueWithoutToolInput[]
    createMany?: ToolExecutionCreateManyToolInputEnvelope
    set?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    disconnect?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    delete?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    connect?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    update?: ToolExecutionUpdateWithWhereUniqueWithoutToolInput | ToolExecutionUpdateWithWhereUniqueWithoutToolInput[]
    updateMany?: ToolExecutionUpdateManyWithWhereWithoutToolInput | ToolExecutionUpdateManyWithWhereWithoutToolInput[]
    deleteMany?: ToolExecutionScalarWhereInput | ToolExecutionScalarWhereInput[]
  }

  export type ToolExecutionUncheckedUpdateManyWithoutToolNestedInput = {
    create?: XOR<ToolExecutionCreateWithoutToolInput, ToolExecutionUncheckedCreateWithoutToolInput> | ToolExecutionCreateWithoutToolInput[] | ToolExecutionUncheckedCreateWithoutToolInput[]
    connectOrCreate?: ToolExecutionCreateOrConnectWithoutToolInput | ToolExecutionCreateOrConnectWithoutToolInput[]
    upsert?: ToolExecutionUpsertWithWhereUniqueWithoutToolInput | ToolExecutionUpsertWithWhereUniqueWithoutToolInput[]
    createMany?: ToolExecutionCreateManyToolInputEnvelope
    set?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    disconnect?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    delete?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    connect?: ToolExecutionWhereUniqueInput | ToolExecutionWhereUniqueInput[]
    update?: ToolExecutionUpdateWithWhereUniqueWithoutToolInput | ToolExecutionUpdateWithWhereUniqueWithoutToolInput[]
    updateMany?: ToolExecutionUpdateManyWithWhereWithoutToolInput | ToolExecutionUpdateManyWithWhereWithoutToolInput[]
    deleteMany?: ToolExecutionScalarWhereInput | ToolExecutionScalarWhereInput[]
  }

  export type ToolCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<ToolCreateWithoutExecutionsInput, ToolUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ToolCreateOrConnectWithoutExecutionsInput
    connect?: ToolWhereUniqueInput
  }

  export type WhatsAppMessageCreateNestedManyWithoutToolExecutionInput = {
    create?: XOR<WhatsAppMessageCreateWithoutToolExecutionInput, WhatsAppMessageUncheckedCreateWithoutToolExecutionInput> | WhatsAppMessageCreateWithoutToolExecutionInput[] | WhatsAppMessageUncheckedCreateWithoutToolExecutionInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutToolExecutionInput | WhatsAppMessageCreateOrConnectWithoutToolExecutionInput[]
    createMany?: WhatsAppMessageCreateManyToolExecutionInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type WhatsAppMessageUncheckedCreateNestedManyWithoutToolExecutionInput = {
    create?: XOR<WhatsAppMessageCreateWithoutToolExecutionInput, WhatsAppMessageUncheckedCreateWithoutToolExecutionInput> | WhatsAppMessageCreateWithoutToolExecutionInput[] | WhatsAppMessageUncheckedCreateWithoutToolExecutionInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutToolExecutionInput | WhatsAppMessageCreateOrConnectWithoutToolExecutionInput[]
    createMany?: WhatsAppMessageCreateManyToolExecutionInputEnvelope
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
  }

  export type EnumToolExecutionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ToolExecutionStatus
  }

  export type ToolUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<ToolCreateWithoutExecutionsInput, ToolUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ToolCreateOrConnectWithoutExecutionsInput
    upsert?: ToolUpsertWithoutExecutionsInput
    connect?: ToolWhereUniqueInput
    update?: XOR<XOR<ToolUpdateToOneWithWhereWithoutExecutionsInput, ToolUpdateWithoutExecutionsInput>, ToolUncheckedUpdateWithoutExecutionsInput>
  }

  export type WhatsAppMessageUpdateManyWithoutToolExecutionNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutToolExecutionInput, WhatsAppMessageUncheckedCreateWithoutToolExecutionInput> | WhatsAppMessageCreateWithoutToolExecutionInput[] | WhatsAppMessageUncheckedCreateWithoutToolExecutionInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutToolExecutionInput | WhatsAppMessageCreateOrConnectWithoutToolExecutionInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutToolExecutionInput | WhatsAppMessageUpsertWithWhereUniqueWithoutToolExecutionInput[]
    createMany?: WhatsAppMessageCreateManyToolExecutionInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutToolExecutionInput | WhatsAppMessageUpdateWithWhereUniqueWithoutToolExecutionInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutToolExecutionInput | WhatsAppMessageUpdateManyWithWhereWithoutToolExecutionInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutToolExecutionNestedInput = {
    create?: XOR<WhatsAppMessageCreateWithoutToolExecutionInput, WhatsAppMessageUncheckedCreateWithoutToolExecutionInput> | WhatsAppMessageCreateWithoutToolExecutionInput[] | WhatsAppMessageUncheckedCreateWithoutToolExecutionInput[]
    connectOrCreate?: WhatsAppMessageCreateOrConnectWithoutToolExecutionInput | WhatsAppMessageCreateOrConnectWithoutToolExecutionInput[]
    upsert?: WhatsAppMessageUpsertWithWhereUniqueWithoutToolExecutionInput | WhatsAppMessageUpsertWithWhereUniqueWithoutToolExecutionInput[]
    createMany?: WhatsAppMessageCreateManyToolExecutionInputEnvelope
    set?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    disconnect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    delete?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    connect?: WhatsAppMessageWhereUniqueInput | WhatsAppMessageWhereUniqueInput[]
    update?: WhatsAppMessageUpdateWithWhereUniqueWithoutToolExecutionInput | WhatsAppMessageUpdateWithWhereUniqueWithoutToolExecutionInput[]
    updateMany?: WhatsAppMessageUpdateManyWithWhereWithoutToolExecutionInput | WhatsAppMessageUpdateManyWithWhereWithoutToolExecutionInput[]
    deleteMany?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
  }

  export type OfficeCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<OfficeCreateWithoutWebhooksInput, OfficeUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutWebhooksInput
    connect?: OfficeWhereUniqueInput
  }

  export type WebhookExecutionCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookExecutionCreateWithoutWebhookInput, WebhookExecutionUncheckedCreateWithoutWebhookInput> | WebhookExecutionCreateWithoutWebhookInput[] | WebhookExecutionUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookExecutionCreateOrConnectWithoutWebhookInput | WebhookExecutionCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookExecutionCreateManyWebhookInputEnvelope
    connect?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
  }

  export type WebhookExecutionUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookExecutionCreateWithoutWebhookInput, WebhookExecutionUncheckedCreateWithoutWebhookInput> | WebhookExecutionCreateWithoutWebhookInput[] | WebhookExecutionUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookExecutionCreateOrConnectWithoutWebhookInput | WebhookExecutionCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookExecutionCreateManyWebhookInputEnvelope
    connect?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
  }

  export type OfficeUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<OfficeCreateWithoutWebhooksInput, OfficeUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutWebhooksInput
    upsert?: OfficeUpsertWithoutWebhooksInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutWebhooksInput, OfficeUpdateWithoutWebhooksInput>, OfficeUncheckedUpdateWithoutWebhooksInput>
  }

  export type WebhookExecutionUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookExecutionCreateWithoutWebhookInput, WebhookExecutionUncheckedCreateWithoutWebhookInput> | WebhookExecutionCreateWithoutWebhookInput[] | WebhookExecutionUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookExecutionCreateOrConnectWithoutWebhookInput | WebhookExecutionCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookExecutionUpsertWithWhereUniqueWithoutWebhookInput | WebhookExecutionUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookExecutionCreateManyWebhookInputEnvelope
    set?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    disconnect?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    delete?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    connect?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    update?: WebhookExecutionUpdateWithWhereUniqueWithoutWebhookInput | WebhookExecutionUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookExecutionUpdateManyWithWhereWithoutWebhookInput | WebhookExecutionUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookExecutionScalarWhereInput | WebhookExecutionScalarWhereInput[]
  }

  export type WebhookExecutionUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookExecutionCreateWithoutWebhookInput, WebhookExecutionUncheckedCreateWithoutWebhookInput> | WebhookExecutionCreateWithoutWebhookInput[] | WebhookExecutionUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookExecutionCreateOrConnectWithoutWebhookInput | WebhookExecutionCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookExecutionUpsertWithWhereUniqueWithoutWebhookInput | WebhookExecutionUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookExecutionCreateManyWebhookInputEnvelope
    set?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    disconnect?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    delete?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    connect?: WebhookExecutionWhereUniqueInput | WebhookExecutionWhereUniqueInput[]
    update?: WebhookExecutionUpdateWithWhereUniqueWithoutWebhookInput | WebhookExecutionUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookExecutionUpdateManyWithWhereWithoutWebhookInput | WebhookExecutionUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookExecutionScalarWhereInput | WebhookExecutionScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<WebhookCreateWithoutExecutionsInput, WebhookUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutExecutionsInput
    connect?: WebhookWhereUniqueInput
  }

  export type WebhookUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<WebhookCreateWithoutExecutionsInput, WebhookUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutExecutionsInput
    upsert?: WebhookUpsertWithoutExecutionsInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutExecutionsInput, WebhookUpdateWithoutExecutionsInput>, WebhookUncheckedUpdateWithoutExecutionsInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type OfficeCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<OfficeCreateWithoutAuditLogsInput, OfficeUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutAuditLogsInput
    connect?: OfficeWhereUniqueInput
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type OfficeUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<OfficeCreateWithoutAuditLogsInput, OfficeUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: OfficeCreateOrConnectWithoutAuditLogsInput
    upsert?: OfficeUpsertWithoutAuditLogsInput
    connect?: OfficeWhereUniqueInput
    update?: XOR<XOR<OfficeUpdateToOneWithWhereWithoutAuditLogsInput, OfficeUpdateWithoutAuditLogsInput>, OfficeUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumWhatsAppInstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppInstanceStatus | EnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppInstanceStatusFilter<$PrismaModel> | $Enums.WhatsAppInstanceStatus
  }

  export type NestedEnumWhatsAppInstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppInstanceStatus | EnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppInstanceStatus[] | ListEnumWhatsAppInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppInstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppInstanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppInstanceStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppInstanceStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumWhatsAppConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppConversationStatus | EnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppConversationStatusFilter<$PrismaModel> | $Enums.WhatsAppConversationStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumWhatsAppConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppConversationStatus | EnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppConversationStatus[] | ListEnumWhatsAppConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppConversationStatusFilter<$PrismaModel>
  }

  export type NestedEnumWhatsAppMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageType | EnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageTypeFilter<$PrismaModel> | $Enums.WhatsAppMessageType
  }

  export type NestedEnumWhatsAppMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageStatus | EnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageStatusFilter<$PrismaModel> | $Enums.WhatsAppMessageStatus
  }

  export type NestedEnumWhatsAppMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageType | EnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageType[] | ListEnumWhatsAppMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppMessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppMessageTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumWhatsAppMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppMessageStatus | EnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppMessageStatus[] | ListEnumWhatsAppMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppMessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumWhatsAppImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppImportStatus | EnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppImportStatusFilter<$PrismaModel> | $Enums.WhatsAppImportStatus
  }

  export type NestedEnumWhatsAppImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhatsAppImportStatus | EnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhatsAppImportStatus[] | ListEnumWhatsAppImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhatsAppImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhatsAppImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhatsAppImportStatusFilter<$PrismaModel>
    _max?: NestedEnumWhatsAppImportStatusFilter<$PrismaModel>
  }

  export type NestedEnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type NestedEnumAgentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgentTypeNullableFilter<$PrismaModel> | $Enums.AgentType | null
  }

  export type NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type NestedEnumAgentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAgentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumTranscriptionProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderFilter<$PrismaModel> | $Enums.TranscriptionProvider
  }

  export type NestedEnumTranscriptionProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptionProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
    _max?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type NestedEnumAIProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AIProvider | EnumAIProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAIProviderFilter<$PrismaModel> | $Enums.AIProvider
  }

  export type NestedEnumAIModelFilter<$PrismaModel = never> = {
    equals?: $Enums.AIModel | EnumAIModelFieldRefInput<$PrismaModel>
    in?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAIModelFilter<$PrismaModel> | $Enums.AIModel
  }

  export type NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAIProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIProvider | EnumAIProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIProvider[] | ListEnumAIProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAIProviderWithAggregatesFilter<$PrismaModel> | $Enums.AIProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIProviderFilter<$PrismaModel>
    _max?: NestedEnumAIProviderFilter<$PrismaModel>
  }

  export type NestedEnumAIModelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIModel | EnumAIModelFieldRefInput<$PrismaModel>
    in?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIModel[] | ListEnumAIModelFieldRefInput<$PrismaModel>
    not?: NestedEnumAIModelWithAggregatesFilter<$PrismaModel> | $Enums.AIModel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIModelFilter<$PrismaModel>
    _max?: NestedEnumAIModelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumToolExecutionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ToolExecutionStatus | EnumToolExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToolExecutionStatusFilter<$PrismaModel> | $Enums.ToolExecutionStatus
  }

  export type NestedEnumToolExecutionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ToolExecutionStatus | EnumToolExecutionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ToolExecutionStatus[] | ListEnumToolExecutionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumToolExecutionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ToolExecutionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumToolExecutionStatusFilter<$PrismaModel>
    _max?: NestedEnumToolExecutionStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OfficeCreateWithoutUsersInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutUsersInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutUsersInput, OfficeUncheckedCreateWithoutUsersInput>
  }

  export type ConversationCreateWithoutCreatorInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    office: OfficeCreateNestedOneWithoutConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutCreatorInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutCreatorInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutCreatorInput, ConversationUncheckedCreateWithoutCreatorInput>
  }

  export type ConversationCreateManyCreatorInputEnvelope = {
    data: ConversationCreateManyCreatorInput | ConversationCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutAssigneeInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    office: OfficeCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    whatsappConfigId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutAssigneeInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutAssigneeInput, ConversationUncheckedCreateWithoutAssigneeInput>
  }

  export type ConversationCreateManyAssigneeInputEnvelope = {
    data: ConversationCreateManyAssigneeInput | ConversationCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutMessagesInput
    audioTranscription?: AudioTranscriptionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    whatsappConfigId?: string | null
    audioTranscription?: AudioTranscriptionUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    office: OfficeCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    officeId: string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ToolCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutToolsInput
    executions?: ToolExecutionCreateNestedManyWithoutToolInput
  }

  export type ToolUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    executions?: ToolExecutionUncheckedCreateNestedManyWithoutToolInput
  }

  export type ToolCreateOrConnectWithoutCreatedByInput = {
    where: ToolWhereUniqueInput
    create: XOR<ToolCreateWithoutCreatedByInput, ToolUncheckedCreateWithoutCreatedByInput>
  }

  export type ToolCreateManyCreatedByInputEnvelope = {
    data: ToolCreateManyCreatedByInput | ToolCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppInstanceCreateWithoutCreatedByInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappInstancesInput
    contacts?: WhatsAppContactCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: WhatsAppContactUncheckedCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceCreateOrConnectWithoutCreatedByInput = {
    where: WhatsAppInstanceWhereUniqueInput
    create: XOR<WhatsAppInstanceCreateWithoutCreatedByInput, WhatsAppInstanceUncheckedCreateWithoutCreatedByInput>
  }

  export type WhatsAppInstanceCreateManyCreatedByInputEnvelope = {
    data: WhatsAppInstanceCreateManyCreatedByInput | WhatsAppInstanceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppImportCreateWithoutUploadedByInput = {
    id?: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutImportsInput
    contact: WhatsAppContactCreateNestedOneWithoutImportsInput
  }

  export type WhatsAppImportUncheckedCreateWithoutUploadedByInput = {
    id?: string
    instanceId: string
    contactId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportCreateOrConnectWithoutUploadedByInput = {
    where: WhatsAppImportWhereUniqueInput
    create: XOR<WhatsAppImportCreateWithoutUploadedByInput, WhatsAppImportUncheckedCreateWithoutUploadedByInput>
  }

  export type WhatsAppImportCreateManyUploadedByInputEnvelope = {
    data: WhatsAppImportCreateManyUploadedByInput | WhatsAppImportCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppConversationCreateWithoutAssignedUserInput = {
    id?: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutConversationsInput
    contact: WhatsAppContactCreateNestedOneWithoutConversationsInput
    currentAgent?: AiAgentCreateNestedOneWithoutWhatsappConversationsInput
    messages?: WhatsAppMessageCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationUncheckedCreateWithoutAssignedUserInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationCreateOrConnectWithoutAssignedUserInput = {
    where: WhatsAppConversationWhereUniqueInput
    create: XOR<WhatsAppConversationCreateWithoutAssignedUserInput, WhatsAppConversationUncheckedCreateWithoutAssignedUserInput>
  }

  export type WhatsAppConversationCreateManyAssignedUserInputEnvelope = {
    data: WhatsAppConversationCreateManyAssignedUserInput | WhatsAppConversationCreateManyAssignedUserInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutUsersInput = {
    update: XOR<OfficeUpdateWithoutUsersInput, OfficeUncheckedUpdateWithoutUsersInput>
    create: XOR<OfficeCreateWithoutUsersInput, OfficeUncheckedCreateWithoutUsersInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutUsersInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutUsersInput, OfficeUncheckedUpdateWithoutUsersInput>
  }

  export type OfficeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type ConversationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutCreatorInput, ConversationUncheckedUpdateWithoutCreatorInput>
    create: XOR<ConversationCreateWithoutCreatorInput, ConversationUncheckedCreateWithoutCreatorInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutCreatorInput, ConversationUncheckedUpdateWithoutCreatorInput>
  }

  export type ConversationUpdateManyWithWhereWithoutCreatorInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    metadata?: JsonNullableFilter<"Conversation">
    currentAgentType?: EnumAgentTypeNullableFilter<"Conversation"> | $Enums.AgentType | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    clientId?: StringFilter<"Conversation"> | string
    officeId?: StringFilter<"Conversation"> | string
    createdBy?: StringFilter<"Conversation"> | string
    assignedTo?: StringNullableFilter<"Conversation"> | string | null
    whatsappConfigId?: StringNullableFilter<"Conversation"> | string | null
  }

  export type ConversationUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutAssigneeInput, ConversationUncheckedUpdateWithoutAssigneeInput>
    create: XOR<ConversationCreateWithoutAssigneeInput, ConversationUncheckedCreateWithoutAssigneeInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutAssigneeInput, ConversationUncheckedUpdateWithoutAssigneeInput>
  }

  export type ConversationUpdateManyWithWhereWithoutAssigneeInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isFromClient?: BoolFilter<"Message"> | boolean
    isFromAI?: BoolFilter<"Message"> | boolean
    metadata?: JsonNullableFilter<"Message">
    externalId?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    transcription?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    userId?: StringNullableFilter<"Message"> | string | null
    whatsappConfigId?: StringNullableFilter<"Message"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    officeId?: StringFilter<"AuditLog"> | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type ToolUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ToolWhereUniqueInput
    update: XOR<ToolUpdateWithoutCreatedByInput, ToolUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ToolCreateWithoutCreatedByInput, ToolUncheckedCreateWithoutCreatedByInput>
  }

  export type ToolUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ToolWhereUniqueInput
    data: XOR<ToolUpdateWithoutCreatedByInput, ToolUncheckedUpdateWithoutCreatedByInput>
  }

  export type ToolUpdateManyWithWhereWithoutCreatedByInput = {
    where: ToolScalarWhereInput
    data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ToolScalarWhereInput = {
    AND?: ToolScalarWhereInput | ToolScalarWhereInput[]
    OR?: ToolScalarWhereInput[]
    NOT?: ToolScalarWhereInput | ToolScalarWhereInput[]
    id?: StringFilter<"Tool"> | string
    name?: StringFilter<"Tool"> | string
    description?: StringFilter<"Tool"> | string
    webhookUrl?: StringFilter<"Tool"> | string
    isActive?: BoolFilter<"Tool"> | boolean
    createdAt?: DateTimeFilter<"Tool"> | Date | string
    updatedAt?: DateTimeFilter<"Tool"> | Date | string
    officeId?: StringFilter<"Tool"> | string
    createdById?: StringFilter<"Tool"> | string
  }

  export type WhatsAppInstanceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WhatsAppInstanceWhereUniqueInput
    update: XOR<WhatsAppInstanceUpdateWithoutCreatedByInput, WhatsAppInstanceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WhatsAppInstanceCreateWithoutCreatedByInput, WhatsAppInstanceUncheckedCreateWithoutCreatedByInput>
  }

  export type WhatsAppInstanceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WhatsAppInstanceWhereUniqueInput
    data: XOR<WhatsAppInstanceUpdateWithoutCreatedByInput, WhatsAppInstanceUncheckedUpdateWithoutCreatedByInput>
  }

  export type WhatsAppInstanceUpdateManyWithWhereWithoutCreatedByInput = {
    where: WhatsAppInstanceScalarWhereInput
    data: XOR<WhatsAppInstanceUpdateManyMutationInput, WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WhatsAppInstanceScalarWhereInput = {
    AND?: WhatsAppInstanceScalarWhereInput | WhatsAppInstanceScalarWhereInput[]
    OR?: WhatsAppInstanceScalarWhereInput[]
    NOT?: WhatsAppInstanceScalarWhereInput | WhatsAppInstanceScalarWhereInput[]
    id?: StringFilter<"WhatsAppInstance"> | string
    name?: StringFilter<"WhatsAppInstance"> | string
    phoneNumber?: StringNullableFilter<"WhatsAppInstance"> | string | null
    status?: EnumWhatsAppInstanceStatusFilter<"WhatsAppInstance"> | $Enums.WhatsAppInstanceStatus
    qrCode?: StringNullableFilter<"WhatsAppInstance"> | string | null
    webhookUrl?: StringNullableFilter<"WhatsAppInstance"> | string | null
    officeId?: StringFilter<"WhatsAppInstance"> | string
    createdById?: StringFilter<"WhatsAppInstance"> | string
    connectionData?: JsonNullableFilter<"WhatsAppInstance">
    isActive?: BoolFilter<"WhatsAppInstance"> | boolean
    createdAt?: DateTimeFilter<"WhatsAppInstance"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppInstance"> | Date | string
  }

  export type WhatsAppImportUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: WhatsAppImportWhereUniqueInput
    update: XOR<WhatsAppImportUpdateWithoutUploadedByInput, WhatsAppImportUncheckedUpdateWithoutUploadedByInput>
    create: XOR<WhatsAppImportCreateWithoutUploadedByInput, WhatsAppImportUncheckedCreateWithoutUploadedByInput>
  }

  export type WhatsAppImportUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: WhatsAppImportWhereUniqueInput
    data: XOR<WhatsAppImportUpdateWithoutUploadedByInput, WhatsAppImportUncheckedUpdateWithoutUploadedByInput>
  }

  export type WhatsAppImportUpdateManyWithWhereWithoutUploadedByInput = {
    where: WhatsAppImportScalarWhereInput
    data: XOR<WhatsAppImportUpdateManyMutationInput, WhatsAppImportUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type WhatsAppImportScalarWhereInput = {
    AND?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
    OR?: WhatsAppImportScalarWhereInput[]
    NOT?: WhatsAppImportScalarWhereInput | WhatsAppImportScalarWhereInput[]
    id?: StringFilter<"WhatsAppImport"> | string
    instanceId?: StringFilter<"WhatsAppImport"> | string
    contactId?: StringFilter<"WhatsAppImport"> | string
    fileName?: StringFilter<"WhatsAppImport"> | string
    fileSize?: IntFilter<"WhatsAppImport"> | number
    totalMessages?: IntFilter<"WhatsAppImport"> | number
    importedMessages?: IntFilter<"WhatsAppImport"> | number
    failedMessages?: IntFilter<"WhatsAppImport"> | number
    mediaFiles?: StringNullableListFilter<"WhatsAppImport">
    status?: EnumWhatsAppImportStatusFilter<"WhatsAppImport"> | $Enums.WhatsAppImportStatus
    errorMessage?: StringNullableFilter<"WhatsAppImport"> | string | null
    uploadedById?: StringFilter<"WhatsAppImport"> | string
    importedAt?: DateTimeNullableFilter<"WhatsAppImport"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppImport"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppImport"> | Date | string
  }

  export type WhatsAppConversationUpsertWithWhereUniqueWithoutAssignedUserInput = {
    where: WhatsAppConversationWhereUniqueInput
    update: XOR<WhatsAppConversationUpdateWithoutAssignedUserInput, WhatsAppConversationUncheckedUpdateWithoutAssignedUserInput>
    create: XOR<WhatsAppConversationCreateWithoutAssignedUserInput, WhatsAppConversationUncheckedCreateWithoutAssignedUserInput>
  }

  export type WhatsAppConversationUpdateWithWhereUniqueWithoutAssignedUserInput = {
    where: WhatsAppConversationWhereUniqueInput
    data: XOR<WhatsAppConversationUpdateWithoutAssignedUserInput, WhatsAppConversationUncheckedUpdateWithoutAssignedUserInput>
  }

  export type WhatsAppConversationUpdateManyWithWhereWithoutAssignedUserInput = {
    where: WhatsAppConversationScalarWhereInput
    data: XOR<WhatsAppConversationUpdateManyMutationInput, WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserInput>
  }

  export type WhatsAppConversationScalarWhereInput = {
    AND?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
    OR?: WhatsAppConversationScalarWhereInput[]
    NOT?: WhatsAppConversationScalarWhereInput | WhatsAppConversationScalarWhereInput[]
    id?: StringFilter<"WhatsAppConversation"> | string
    instanceId?: StringFilter<"WhatsAppConversation"> | string
    contactId?: StringFilter<"WhatsAppConversation"> | string
    remoteJid?: StringFilter<"WhatsAppConversation"> | string
    title?: StringNullableFilter<"WhatsAppConversation"> | string | null
    isGroup?: BoolFilter<"WhatsAppConversation"> | boolean
    lastMessageId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"WhatsAppConversation"> | Date | string | null
    unreadCount?: IntFilter<"WhatsAppConversation"> | number
    isArchived?: BoolFilter<"WhatsAppConversation"> | boolean
    isPinned?: BoolFilter<"WhatsAppConversation"> | boolean
    assignedUserId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    status?: EnumWhatsAppConversationStatusFilter<"WhatsAppConversation"> | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFilter<"WhatsAppConversation"> | boolean
    currentAgentId?: StringNullableFilter<"WhatsAppConversation"> | string | null
    metadata?: JsonNullableFilter<"WhatsAppConversation">
    createdAt?: DateTimeFilter<"WhatsAppConversation"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppConversation"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserCreateWithoutOfficeInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutOfficeInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutOfficeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOfficeInput, UserUncheckedCreateWithoutOfficeInput>
  }

  export type UserCreateManyOfficeInputEnvelope = {
    data: UserCreateManyOfficeInput | UserCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutOfficeInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    clientTags?: ClientTagCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOfficeInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOfficeInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOfficeInput, ClientUncheckedCreateWithoutOfficeInput>
  }

  export type ClientCreateManyOfficeInputEnvelope = {
    data: ClientCreateManyOfficeInput | ClientCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutOfficeInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutOfficeInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutOfficeInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutOfficeInput, ConversationUncheckedCreateWithoutOfficeInput>
  }

  export type ConversationCreateManyOfficeInputEnvelope = {
    data: ConversationCreateManyOfficeInput | ConversationCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutOfficeInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientTags?: ClientTagCreateNestedManyWithoutTagInput
    conversationTags?: ConversationTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutOfficeInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutTagInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutOfficeInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutOfficeInput, TagUncheckedCreateWithoutOfficeInput>
  }

  export type TagCreateManyOfficeInputEnvelope = {
    data: TagCreateManyOfficeInput | TagCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type CustomStatusCreateWithoutOfficeInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationStatuses?: ConversationCustomStatusCreateNestedManyWithoutCustomStatusInput
  }

  export type CustomStatusUncheckedCreateWithoutOfficeInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationStatuses?: ConversationCustomStatusUncheckedCreateNestedManyWithoutCustomStatusInput
  }

  export type CustomStatusCreateOrConnectWithoutOfficeInput = {
    where: CustomStatusWhereUniqueInput
    create: XOR<CustomStatusCreateWithoutOfficeInput, CustomStatusUncheckedCreateWithoutOfficeInput>
  }

  export type CustomStatusCreateManyOfficeInputEnvelope = {
    data: CustomStatusCreateManyOfficeInput | CustomStatusCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type AiAgentCreateWithoutOfficeInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappConversations?: WhatsAppConversationCreateNestedManyWithoutCurrentAgentInput
  }

  export type AiAgentUncheckedCreateWithoutOfficeInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappConversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutCurrentAgentInput
  }

  export type AiAgentCreateOrConnectWithoutOfficeInput = {
    where: AiAgentWhereUniqueInput
    create: XOR<AiAgentCreateWithoutOfficeInput, AiAgentUncheckedCreateWithoutOfficeInput>
  }

  export type AiAgentCreateManyOfficeInputEnvelope = {
    data: AiAgentCreateManyOfficeInput | AiAgentCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type WhatsappConfigCreateWithoutOfficeInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutWhatsappConfigInput
    messages?: MessageCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigUncheckedCreateWithoutOfficeInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutWhatsappConfigInput
    messages?: MessageUncheckedCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigCreateOrConnectWithoutOfficeInput = {
    where: WhatsappConfigWhereUniqueInput
    create: XOR<WhatsappConfigCreateWithoutOfficeInput, WhatsappConfigUncheckedCreateWithoutOfficeInput>
  }

  export type WhatsappConfigCreateManyOfficeInputEnvelope = {
    data: WhatsappConfigCreateManyOfficeInput | WhatsappConfigCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutOfficeInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutOfficeInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
  }

  export type DocumentCreateOrConnectWithoutOfficeInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutOfficeInput, DocumentUncheckedCreateWithoutOfficeInput>
  }

  export type DocumentCreateManyOfficeInputEnvelope = {
    data: DocumentCreateManyOfficeInput | DocumentCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type ToolCreateWithoutOfficeInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutToolsCreatedInput
    executions?: ToolExecutionCreateNestedManyWithoutToolInput
  }

  export type ToolUncheckedCreateWithoutOfficeInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    executions?: ToolExecutionUncheckedCreateNestedManyWithoutToolInput
  }

  export type ToolCreateOrConnectWithoutOfficeInput = {
    where: ToolWhereUniqueInput
    create: XOR<ToolCreateWithoutOfficeInput, ToolUncheckedCreateWithoutOfficeInput>
  }

  export type ToolCreateManyOfficeInputEnvelope = {
    data: ToolCreateManyOfficeInput | ToolCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutOfficeInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: WebhookExecutionCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateWithoutOfficeInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: WebhookExecutionUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookCreateOrConnectWithoutOfficeInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutOfficeInput, WebhookUncheckedCreateWithoutOfficeInput>
  }

  export type WebhookCreateManyOfficeInputEnvelope = {
    data: WebhookCreateManyOfficeInput | WebhookCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutOfficeInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type AuditLogUncheckedCreateWithoutOfficeInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type AuditLogCreateOrConnectWithoutOfficeInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutOfficeInput, AuditLogUncheckedCreateWithoutOfficeInput>
  }

  export type AuditLogCreateManyOfficeInputEnvelope = {
    data: AuditLogCreateManyOfficeInput | AuditLogCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type AIProviderConfigCreateWithoutOfficeInput = {
    id?: string
    provider: $Enums.AIProvider
    apiKey: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderConfigUncheckedCreateWithoutOfficeInput = {
    id?: string
    provider: $Enums.AIProvider
    apiKey: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderConfigCreateOrConnectWithoutOfficeInput = {
    where: AIProviderConfigWhereUniqueInput
    create: XOR<AIProviderConfigCreateWithoutOfficeInput, AIProviderConfigUncheckedCreateWithoutOfficeInput>
  }

  export type AIProviderConfigCreateManyOfficeInputEnvelope = {
    data: AIProviderConfigCreateManyOfficeInput | AIProviderConfigCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppInstanceCreateWithoutOfficeInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutWhatsappInstancesCreatedInput
    contacts?: WhatsAppContactCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUncheckedCreateWithoutOfficeInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: WhatsAppContactUncheckedCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceCreateOrConnectWithoutOfficeInput = {
    where: WhatsAppInstanceWhereUniqueInput
    create: XOR<WhatsAppInstanceCreateWithoutOfficeInput, WhatsAppInstanceUncheckedCreateWithoutOfficeInput>
  }

  export type WhatsAppInstanceCreateManyOfficeInputEnvelope = {
    data: WhatsAppInstanceCreateManyOfficeInput | WhatsAppInstanceCreateManyOfficeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOfficeInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOfficeInput, UserUncheckedUpdateWithoutOfficeInput>
    create: XOR<UserCreateWithoutOfficeInput, UserUncheckedCreateWithoutOfficeInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOfficeInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOfficeInput, UserUncheckedUpdateWithoutOfficeInput>
  }

  export type UserUpdateManyWithWhereWithoutOfficeInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOfficeInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    officeId?: StringNullableFilter<"User"> | string | null
  }

  export type ClientUpsertWithWhereUniqueWithoutOfficeInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutOfficeInput, ClientUncheckedUpdateWithoutOfficeInput>
    create: XOR<ClientCreateWithoutOfficeInput, ClientUncheckedCreateWithoutOfficeInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutOfficeInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutOfficeInput, ClientUncheckedUpdateWithoutOfficeInput>
  }

  export type ClientUpdateManyWithWhereWithoutOfficeInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutOfficeInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringNullableFilter<"Client"> | string | null
    phone?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    document?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    isLead?: BoolFilter<"Client"> | boolean
    dateOfBirth?: DateTimeNullableFilter<"Client"> | Date | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    officeId?: StringFilter<"Client"> | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutOfficeInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutOfficeInput, ConversationUncheckedUpdateWithoutOfficeInput>
    create: XOR<ConversationCreateWithoutOfficeInput, ConversationUncheckedCreateWithoutOfficeInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutOfficeInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutOfficeInput, ConversationUncheckedUpdateWithoutOfficeInput>
  }

  export type ConversationUpdateManyWithWhereWithoutOfficeInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutOfficeInput>
  }

  export type TagUpsertWithWhereUniqueWithoutOfficeInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutOfficeInput, TagUncheckedUpdateWithoutOfficeInput>
    create: XOR<TagCreateWithoutOfficeInput, TagUncheckedCreateWithoutOfficeInput>
  }

  export type TagUpdateWithWhereUniqueWithoutOfficeInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutOfficeInput, TagUncheckedUpdateWithoutOfficeInput>
  }

  export type TagUpdateManyWithWhereWithoutOfficeInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutOfficeInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    isActive?: BoolFilter<"Tag"> | boolean
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    officeId?: StringFilter<"Tag"> | string
  }

  export type CustomStatusUpsertWithWhereUniqueWithoutOfficeInput = {
    where: CustomStatusWhereUniqueInput
    update: XOR<CustomStatusUpdateWithoutOfficeInput, CustomStatusUncheckedUpdateWithoutOfficeInput>
    create: XOR<CustomStatusCreateWithoutOfficeInput, CustomStatusUncheckedCreateWithoutOfficeInput>
  }

  export type CustomStatusUpdateWithWhereUniqueWithoutOfficeInput = {
    where: CustomStatusWhereUniqueInput
    data: XOR<CustomStatusUpdateWithoutOfficeInput, CustomStatusUncheckedUpdateWithoutOfficeInput>
  }

  export type CustomStatusUpdateManyWithWhereWithoutOfficeInput = {
    where: CustomStatusScalarWhereInput
    data: XOR<CustomStatusUpdateManyMutationInput, CustomStatusUncheckedUpdateManyWithoutOfficeInput>
  }

  export type CustomStatusScalarWhereInput = {
    AND?: CustomStatusScalarWhereInput | CustomStatusScalarWhereInput[]
    OR?: CustomStatusScalarWhereInput[]
    NOT?: CustomStatusScalarWhereInput | CustomStatusScalarWhereInput[]
    id?: StringFilter<"CustomStatus"> | string
    name?: StringFilter<"CustomStatus"> | string
    color?: StringFilter<"CustomStatus"> | string
    description?: StringNullableFilter<"CustomStatus"> | string | null
    isActive?: BoolFilter<"CustomStatus"> | boolean
    order?: IntFilter<"CustomStatus"> | number
    createdAt?: DateTimeFilter<"CustomStatus"> | Date | string
    updatedAt?: DateTimeFilter<"CustomStatus"> | Date | string
    officeId?: StringFilter<"CustomStatus"> | string
  }

  export type AiAgentUpsertWithWhereUniqueWithoutOfficeInput = {
    where: AiAgentWhereUniqueInput
    update: XOR<AiAgentUpdateWithoutOfficeInput, AiAgentUncheckedUpdateWithoutOfficeInput>
    create: XOR<AiAgentCreateWithoutOfficeInput, AiAgentUncheckedCreateWithoutOfficeInput>
  }

  export type AiAgentUpdateWithWhereUniqueWithoutOfficeInput = {
    where: AiAgentWhereUniqueInput
    data: XOR<AiAgentUpdateWithoutOfficeInput, AiAgentUncheckedUpdateWithoutOfficeInput>
  }

  export type AiAgentUpdateManyWithWhereWithoutOfficeInput = {
    where: AiAgentScalarWhereInput
    data: XOR<AiAgentUpdateManyMutationInput, AiAgentUncheckedUpdateManyWithoutOfficeInput>
  }

  export type AiAgentScalarWhereInput = {
    AND?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
    OR?: AiAgentScalarWhereInput[]
    NOT?: AiAgentScalarWhereInput | AiAgentScalarWhereInput[]
    id?: StringFilter<"AiAgent"> | string
    name?: StringFilter<"AiAgent"> | string
    type?: EnumAgentTypeFilter<"AiAgent"> | $Enums.AgentType
    prompt?: StringFilter<"AiAgent"> | string
    model?: StringFilter<"AiAgent"> | string
    provider?: EnumAIProviderFilter<"AiAgent"> | $Enums.AIProvider
    aiModel?: EnumAIModelFilter<"AiAgent"> | $Enums.AIModel
    temperature?: FloatFilter<"AiAgent"> | number
    maxTokens?: IntFilter<"AiAgent"> | number
    isActive?: BoolFilter<"AiAgent"> | boolean
    createdAt?: DateTimeFilter<"AiAgent"> | Date | string
    updatedAt?: DateTimeFilter<"AiAgent"> | Date | string
    officeId?: StringFilter<"AiAgent"> | string
  }

  export type WhatsappConfigUpsertWithWhereUniqueWithoutOfficeInput = {
    where: WhatsappConfigWhereUniqueInput
    update: XOR<WhatsappConfigUpdateWithoutOfficeInput, WhatsappConfigUncheckedUpdateWithoutOfficeInput>
    create: XOR<WhatsappConfigCreateWithoutOfficeInput, WhatsappConfigUncheckedCreateWithoutOfficeInput>
  }

  export type WhatsappConfigUpdateWithWhereUniqueWithoutOfficeInput = {
    where: WhatsappConfigWhereUniqueInput
    data: XOR<WhatsappConfigUpdateWithoutOfficeInput, WhatsappConfigUncheckedUpdateWithoutOfficeInput>
  }

  export type WhatsappConfigUpdateManyWithWhereWithoutOfficeInput = {
    where: WhatsappConfigScalarWhereInput
    data: XOR<WhatsappConfigUpdateManyMutationInput, WhatsappConfigUncheckedUpdateManyWithoutOfficeInput>
  }

  export type WhatsappConfigScalarWhereInput = {
    AND?: WhatsappConfigScalarWhereInput | WhatsappConfigScalarWhereInput[]
    OR?: WhatsappConfigScalarWhereInput[]
    NOT?: WhatsappConfigScalarWhereInput | WhatsappConfigScalarWhereInput[]
    id?: StringFilter<"WhatsappConfig"> | string
    instanceId?: StringFilter<"WhatsappConfig"> | string
    phone?: StringFilter<"WhatsappConfig"> | string
    qrCode?: StringNullableFilter<"WhatsappConfig"> | string | null
    isActive?: BoolFilter<"WhatsappConfig"> | boolean
    apiUrl?: StringNullableFilter<"WhatsappConfig"> | string | null
    apiKey?: StringNullableFilter<"WhatsappConfig"> | string | null
    createdAt?: DateTimeFilter<"WhatsappConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappConfig"> | Date | string
    officeId?: StringFilter<"WhatsappConfig"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutOfficeInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutOfficeInput, DocumentUncheckedUpdateWithoutOfficeInput>
    create: XOR<DocumentCreateWithoutOfficeInput, DocumentUncheckedCreateWithoutOfficeInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutOfficeInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutOfficeInput, DocumentUncheckedUpdateWithoutOfficeInput>
  }

  export type DocumentUpdateManyWithWhereWithoutOfficeInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutOfficeInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    originalName?: StringFilter<"Document"> | string
    mimeType?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    url?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    clientId?: StringFilter<"Document"> | string
    officeId?: StringFilter<"Document"> | string
  }

  export type ToolUpsertWithWhereUniqueWithoutOfficeInput = {
    where: ToolWhereUniqueInput
    update: XOR<ToolUpdateWithoutOfficeInput, ToolUncheckedUpdateWithoutOfficeInput>
    create: XOR<ToolCreateWithoutOfficeInput, ToolUncheckedCreateWithoutOfficeInput>
  }

  export type ToolUpdateWithWhereUniqueWithoutOfficeInput = {
    where: ToolWhereUniqueInput
    data: XOR<ToolUpdateWithoutOfficeInput, ToolUncheckedUpdateWithoutOfficeInput>
  }

  export type ToolUpdateManyWithWhereWithoutOfficeInput = {
    where: ToolScalarWhereInput
    data: XOR<ToolUpdateManyMutationInput, ToolUncheckedUpdateManyWithoutOfficeInput>
  }

  export type WebhookUpsertWithWhereUniqueWithoutOfficeInput = {
    where: WebhookWhereUniqueInput
    update: XOR<WebhookUpdateWithoutOfficeInput, WebhookUncheckedUpdateWithoutOfficeInput>
    create: XOR<WebhookCreateWithoutOfficeInput, WebhookUncheckedCreateWithoutOfficeInput>
  }

  export type WebhookUpdateWithWhereUniqueWithoutOfficeInput = {
    where: WebhookWhereUniqueInput
    data: XOR<WebhookUpdateWithoutOfficeInput, WebhookUncheckedUpdateWithoutOfficeInput>
  }

  export type WebhookUpdateManyWithWhereWithoutOfficeInput = {
    where: WebhookScalarWhereInput
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyWithoutOfficeInput>
  }

  export type WebhookScalarWhereInput = {
    AND?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    OR?: WebhookScalarWhereInput[]
    NOT?: WebhookScalarWhereInput | WebhookScalarWhereInput[]
    id?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringNullableFilter<"Webhook"> | string | null
    isActive?: BoolFilter<"Webhook"> | boolean
    description?: StringNullableFilter<"Webhook"> | string | null
    retryCount?: IntFilter<"Webhook"> | number
    timeoutMs?: IntFilter<"Webhook"> | number
    headers?: JsonNullableFilter<"Webhook">
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    officeId?: StringFilter<"Webhook"> | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutOfficeInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutOfficeInput, AuditLogUncheckedUpdateWithoutOfficeInput>
    create: XOR<AuditLogCreateWithoutOfficeInput, AuditLogUncheckedCreateWithoutOfficeInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutOfficeInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutOfficeInput, AuditLogUncheckedUpdateWithoutOfficeInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutOfficeInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutOfficeInput>
  }

  export type AIProviderConfigUpsertWithWhereUniqueWithoutOfficeInput = {
    where: AIProviderConfigWhereUniqueInput
    update: XOR<AIProviderConfigUpdateWithoutOfficeInput, AIProviderConfigUncheckedUpdateWithoutOfficeInput>
    create: XOR<AIProviderConfigCreateWithoutOfficeInput, AIProviderConfigUncheckedCreateWithoutOfficeInput>
  }

  export type AIProviderConfigUpdateWithWhereUniqueWithoutOfficeInput = {
    where: AIProviderConfigWhereUniqueInput
    data: XOR<AIProviderConfigUpdateWithoutOfficeInput, AIProviderConfigUncheckedUpdateWithoutOfficeInput>
  }

  export type AIProviderConfigUpdateManyWithWhereWithoutOfficeInput = {
    where: AIProviderConfigScalarWhereInput
    data: XOR<AIProviderConfigUpdateManyMutationInput, AIProviderConfigUncheckedUpdateManyWithoutOfficeInput>
  }

  export type AIProviderConfigScalarWhereInput = {
    AND?: AIProviderConfigScalarWhereInput | AIProviderConfigScalarWhereInput[]
    OR?: AIProviderConfigScalarWhereInput[]
    NOT?: AIProviderConfigScalarWhereInput | AIProviderConfigScalarWhereInput[]
    id?: StringFilter<"AIProviderConfig"> | string
    provider?: EnumAIProviderFilter<"AIProviderConfig"> | $Enums.AIProvider
    apiKey?: StringFilter<"AIProviderConfig"> | string
    isActive?: BoolFilter<"AIProviderConfig"> | boolean
    createdAt?: DateTimeFilter<"AIProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIProviderConfig"> | Date | string
    officeId?: StringFilter<"AIProviderConfig"> | string
  }

  export type WhatsAppInstanceUpsertWithWhereUniqueWithoutOfficeInput = {
    where: WhatsAppInstanceWhereUniqueInput
    update: XOR<WhatsAppInstanceUpdateWithoutOfficeInput, WhatsAppInstanceUncheckedUpdateWithoutOfficeInput>
    create: XOR<WhatsAppInstanceCreateWithoutOfficeInput, WhatsAppInstanceUncheckedCreateWithoutOfficeInput>
  }

  export type WhatsAppInstanceUpdateWithWhereUniqueWithoutOfficeInput = {
    where: WhatsAppInstanceWhereUniqueInput
    data: XOR<WhatsAppInstanceUpdateWithoutOfficeInput, WhatsAppInstanceUncheckedUpdateWithoutOfficeInput>
  }

  export type WhatsAppInstanceUpdateManyWithWhereWithoutOfficeInput = {
    where: WhatsAppInstanceScalarWhereInput
    data: XOR<WhatsAppInstanceUpdateManyMutationInput, WhatsAppInstanceUncheckedUpdateManyWithoutOfficeInput>
  }

  export type OfficeCreateWithoutWhatsappConfigsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutWhatsappConfigsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutWhatsappConfigsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutWhatsappConfigsInput, OfficeUncheckedCreateWithoutWhatsappConfigsInput>
  }

  export type ConversationCreateWithoutWhatsappConfigInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    office: OfficeCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutWhatsappConfigInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutWhatsappConfigInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutWhatsappConfigInput, ConversationUncheckedCreateWithoutWhatsappConfigInput>
  }

  export type ConversationCreateManyWhatsappConfigInputEnvelope = {
    data: ConversationCreateManyWhatsappConfigInput | ConversationCreateManyWhatsappConfigInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutWhatsappConfigInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutMessagesInput
    audioTranscription?: AudioTranscriptionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutWhatsappConfigInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    userId?: string | null
    audioTranscription?: AudioTranscriptionUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutWhatsappConfigInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutWhatsappConfigInput, MessageUncheckedCreateWithoutWhatsappConfigInput>
  }

  export type MessageCreateManyWhatsappConfigInputEnvelope = {
    data: MessageCreateManyWhatsappConfigInput | MessageCreateManyWhatsappConfigInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutWhatsappConfigsInput = {
    update: XOR<OfficeUpdateWithoutWhatsappConfigsInput, OfficeUncheckedUpdateWithoutWhatsappConfigsInput>
    create: XOR<OfficeCreateWithoutWhatsappConfigsInput, OfficeUncheckedCreateWithoutWhatsappConfigsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutWhatsappConfigsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutWhatsappConfigsInput, OfficeUncheckedUpdateWithoutWhatsappConfigsInput>
  }

  export type OfficeUpdateWithoutWhatsappConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutWhatsappConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type ConversationUpsertWithWhereUniqueWithoutWhatsappConfigInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutWhatsappConfigInput, ConversationUncheckedUpdateWithoutWhatsappConfigInput>
    create: XOR<ConversationCreateWithoutWhatsappConfigInput, ConversationUncheckedCreateWithoutWhatsappConfigInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutWhatsappConfigInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutWhatsappConfigInput, ConversationUncheckedUpdateWithoutWhatsappConfigInput>
  }

  export type ConversationUpdateManyWithWhereWithoutWhatsappConfigInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutWhatsappConfigInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutWhatsappConfigInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutWhatsappConfigInput, MessageUncheckedUpdateWithoutWhatsappConfigInput>
    create: XOR<MessageCreateWithoutWhatsappConfigInput, MessageUncheckedCreateWithoutWhatsappConfigInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutWhatsappConfigInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutWhatsappConfigInput, MessageUncheckedUpdateWithoutWhatsappConfigInput>
  }

  export type MessageUpdateManyWithWhereWithoutWhatsappConfigInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutWhatsappConfigInput>
  }

  export type OfficeCreateWithoutWhatsappInstancesInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutWhatsappInstancesInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutWhatsappInstancesInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutWhatsappInstancesInput, OfficeUncheckedCreateWithoutWhatsappInstancesInput>
  }

  export type UserCreateWithoutWhatsappInstancesCreatedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutWhatsappInstancesCreatedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutWhatsappInstancesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsappInstancesCreatedInput, UserUncheckedCreateWithoutWhatsappInstancesCreatedInput>
  }

  export type WhatsAppContactCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutWhatsappContactsInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactUncheckedCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    clientId?: string | null
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactCreateOrConnectWithoutInstanceInput = {
    where: WhatsAppContactWhereUniqueInput
    create: XOR<WhatsAppContactCreateWithoutInstanceInput, WhatsAppContactUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppContactCreateManyInstanceInputEnvelope = {
    data: WhatsAppContactCreateManyInstanceInput | WhatsAppContactCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppConversationCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: WhatsAppContactCreateNestedOneWithoutConversationsInput
    assignedUser?: UserCreateNestedOneWithoutWhatsappConversationsAssignedInput
    currentAgent?: AiAgentCreateNestedOneWithoutWhatsappConversationsInput
    messages?: WhatsAppMessageCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationUncheckedCreateWithoutInstanceInput = {
    id?: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationCreateOrConnectWithoutInstanceInput = {
    where: WhatsAppConversationWhereUniqueInput
    create: XOR<WhatsAppConversationCreateWithoutInstanceInput, WhatsAppConversationUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppConversationCreateManyInstanceInputEnvelope = {
    data: WhatsAppConversationCreateManyInstanceInput | WhatsAppConversationCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppMessageCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: WhatsAppConversationCreateNestedOneWithoutMessagesInput
    contact: WhatsAppContactCreateNestedOneWithoutMessagesInput
    toolExecution?: ToolExecutionCreateNestedOneWithoutWhatsappMessagesInput
  }

  export type WhatsAppMessageUncheckedCreateWithoutInstanceInput = {
    id?: string
    conversationId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageCreateOrConnectWithoutInstanceInput = {
    where: WhatsAppMessageWhereUniqueInput
    create: XOR<WhatsAppMessageCreateWithoutInstanceInput, WhatsAppMessageUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppMessageCreateManyInstanceInputEnvelope = {
    data: WhatsAppMessageCreateManyInstanceInput | WhatsAppMessageCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppImportCreateWithoutInstanceInput = {
    id?: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: WhatsAppContactCreateNestedOneWithoutImportsInput
    uploadedBy: UserCreateNestedOneWithoutWhatsappImportsUploadedInput
  }

  export type WhatsAppImportUncheckedCreateWithoutInstanceInput = {
    id?: string
    contactId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    uploadedById: string
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportCreateOrConnectWithoutInstanceInput = {
    where: WhatsAppImportWhereUniqueInput
    create: XOR<WhatsAppImportCreateWithoutInstanceInput, WhatsAppImportUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppImportCreateManyInstanceInputEnvelope = {
    data: WhatsAppImportCreateManyInstanceInput | WhatsAppImportCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutWhatsappInstancesInput = {
    update: XOR<OfficeUpdateWithoutWhatsappInstancesInput, OfficeUncheckedUpdateWithoutWhatsappInstancesInput>
    create: XOR<OfficeCreateWithoutWhatsappInstancesInput, OfficeUncheckedCreateWithoutWhatsappInstancesInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutWhatsappInstancesInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutWhatsappInstancesInput, OfficeUncheckedUpdateWithoutWhatsappInstancesInput>
  }

  export type OfficeUpdateWithoutWhatsappInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutWhatsappInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type UserUpsertWithoutWhatsappInstancesCreatedInput = {
    update: XOR<UserUpdateWithoutWhatsappInstancesCreatedInput, UserUncheckedUpdateWithoutWhatsappInstancesCreatedInput>
    create: XOR<UserCreateWithoutWhatsappInstancesCreatedInput, UserUncheckedCreateWithoutWhatsappInstancesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsappInstancesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsappInstancesCreatedInput, UserUncheckedUpdateWithoutWhatsappInstancesCreatedInput>
  }

  export type UserUpdateWithoutWhatsappInstancesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsappInstancesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type WhatsAppContactUpsertWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppContactWhereUniqueInput
    update: XOR<WhatsAppContactUpdateWithoutInstanceInput, WhatsAppContactUncheckedUpdateWithoutInstanceInput>
    create: XOR<WhatsAppContactCreateWithoutInstanceInput, WhatsAppContactUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppContactUpdateWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppContactWhereUniqueInput
    data: XOR<WhatsAppContactUpdateWithoutInstanceInput, WhatsAppContactUncheckedUpdateWithoutInstanceInput>
  }

  export type WhatsAppContactUpdateManyWithWhereWithoutInstanceInput = {
    where: WhatsAppContactScalarWhereInput
    data: XOR<WhatsAppContactUpdateManyMutationInput, WhatsAppContactUncheckedUpdateManyWithoutInstanceInput>
  }

  export type WhatsAppContactScalarWhereInput = {
    AND?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
    OR?: WhatsAppContactScalarWhereInput[]
    NOT?: WhatsAppContactScalarWhereInput | WhatsAppContactScalarWhereInput[]
    id?: StringFilter<"WhatsAppContact"> | string
    instanceId?: StringFilter<"WhatsAppContact"> | string
    remoteJid?: StringFilter<"WhatsAppContact"> | string
    phoneNumber?: StringFilter<"WhatsAppContact"> | string
    name?: StringNullableFilter<"WhatsAppContact"> | string | null
    pushName?: StringNullableFilter<"WhatsAppContact"> | string | null
    profilePicUrl?: StringNullableFilter<"WhatsAppContact"> | string | null
    isGroup?: BoolFilter<"WhatsAppContact"> | boolean
    lastSeen?: DateTimeNullableFilter<"WhatsAppContact"> | Date | string | null
    isBlocked?: BoolFilter<"WhatsAppContact"> | boolean
    clientId?: StringNullableFilter<"WhatsAppContact"> | string | null
    tags?: StringNullableListFilter<"WhatsAppContact">
    notes?: StringNullableFilter<"WhatsAppContact"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppContact"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppContact"> | Date | string
  }

  export type WhatsAppConversationUpsertWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppConversationWhereUniqueInput
    update: XOR<WhatsAppConversationUpdateWithoutInstanceInput, WhatsAppConversationUncheckedUpdateWithoutInstanceInput>
    create: XOR<WhatsAppConversationCreateWithoutInstanceInput, WhatsAppConversationUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppConversationUpdateWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppConversationWhereUniqueInput
    data: XOR<WhatsAppConversationUpdateWithoutInstanceInput, WhatsAppConversationUncheckedUpdateWithoutInstanceInput>
  }

  export type WhatsAppConversationUpdateManyWithWhereWithoutInstanceInput = {
    where: WhatsAppConversationScalarWhereInput
    data: XOR<WhatsAppConversationUpdateManyMutationInput, WhatsAppConversationUncheckedUpdateManyWithoutInstanceInput>
  }

  export type WhatsAppMessageUpsertWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppMessageWhereUniqueInput
    update: XOR<WhatsAppMessageUpdateWithoutInstanceInput, WhatsAppMessageUncheckedUpdateWithoutInstanceInput>
    create: XOR<WhatsAppMessageCreateWithoutInstanceInput, WhatsAppMessageUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppMessageUpdateWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppMessageWhereUniqueInput
    data: XOR<WhatsAppMessageUpdateWithoutInstanceInput, WhatsAppMessageUncheckedUpdateWithoutInstanceInput>
  }

  export type WhatsAppMessageUpdateManyWithWhereWithoutInstanceInput = {
    where: WhatsAppMessageScalarWhereInput
    data: XOR<WhatsAppMessageUpdateManyMutationInput, WhatsAppMessageUncheckedUpdateManyWithoutInstanceInput>
  }

  export type WhatsAppMessageScalarWhereInput = {
    AND?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
    OR?: WhatsAppMessageScalarWhereInput[]
    NOT?: WhatsAppMessageScalarWhereInput | WhatsAppMessageScalarWhereInput[]
    id?: StringFilter<"WhatsAppMessage"> | string
    instanceId?: StringFilter<"WhatsAppMessage"> | string
    conversationId?: StringFilter<"WhatsAppMessage"> | string
    contactId?: StringFilter<"WhatsAppMessage"> | string
    remoteJid?: StringFilter<"WhatsAppMessage"> | string
    messageId?: StringFilter<"WhatsAppMessage"> | string
    fromMe?: BoolFilter<"WhatsAppMessage"> | boolean
    messageType?: EnumWhatsAppMessageTypeFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageType
    content?: StringNullableFilter<"WhatsAppMessage"> | string | null
    quotedMessageId?: StringNullableFilter<"WhatsAppMessage"> | string | null
    mediaUrl?: StringNullableFilter<"WhatsAppMessage"> | string | null
    mediaSize?: IntNullableFilter<"WhatsAppMessage"> | number | null
    mimetype?: StringNullableFilter<"WhatsAppMessage"> | string | null
    fileName?: StringNullableFilter<"WhatsAppMessage"> | string | null
    caption?: StringNullableFilter<"WhatsAppMessage"> | string | null
    location?: JsonNullableFilter<"WhatsAppMessage">
    isForwarded?: BoolFilter<"WhatsAppMessage"> | boolean
    timestamp?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    status?: EnumWhatsAppMessageStatusFilter<"WhatsAppMessage"> | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFilter<"WhatsAppMessage"> | boolean
    isEdited?: BoolFilter<"WhatsAppMessage"> | boolean
    aiResponse?: BoolFilter<"WhatsAppMessage"> | boolean
    toolExecutionId?: StringNullableFilter<"WhatsAppMessage"> | string | null
    importedFrom?: StringNullableFilter<"WhatsAppMessage"> | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessage"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessage"> | Date | string
  }

  export type WhatsAppImportUpsertWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppImportWhereUniqueInput
    update: XOR<WhatsAppImportUpdateWithoutInstanceInput, WhatsAppImportUncheckedUpdateWithoutInstanceInput>
    create: XOR<WhatsAppImportCreateWithoutInstanceInput, WhatsAppImportUncheckedCreateWithoutInstanceInput>
  }

  export type WhatsAppImportUpdateWithWhereUniqueWithoutInstanceInput = {
    where: WhatsAppImportWhereUniqueInput
    data: XOR<WhatsAppImportUpdateWithoutInstanceInput, WhatsAppImportUncheckedUpdateWithoutInstanceInput>
  }

  export type WhatsAppImportUpdateManyWithWhereWithoutInstanceInput = {
    where: WhatsAppImportScalarWhereInput
    data: XOR<WhatsAppImportUpdateManyMutationInput, WhatsAppImportUncheckedUpdateManyWithoutInstanceInput>
  }

  export type WhatsAppInstanceCreateWithoutContactsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappInstancesInput
    createdBy: UserCreateNestedOneWithoutWhatsappInstancesCreatedInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceCreateOrConnectWithoutContactsInput = {
    where: WhatsAppInstanceWhereUniqueInput
    create: XOR<WhatsAppInstanceCreateWithoutContactsInput, WhatsAppInstanceUncheckedCreateWithoutContactsInput>
  }

  export type ClientCreateWithoutWhatsappContactsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutClientsInput
    conversations?: ConversationCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    clientTags?: ClientTagCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutWhatsappContactsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutWhatsappContactsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutWhatsappContactsInput, ClientUncheckedCreateWithoutWhatsappContactsInput>
  }

  export type WhatsAppConversationCreateWithoutContactInput = {
    id?: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutConversationsInput
    assignedUser?: UserCreateNestedOneWithoutWhatsappConversationsAssignedInput
    currentAgent?: AiAgentCreateNestedOneWithoutWhatsappConversationsInput
    messages?: WhatsAppMessageCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationUncheckedCreateWithoutContactInput = {
    id?: string
    instanceId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationCreateOrConnectWithoutContactInput = {
    where: WhatsAppConversationWhereUniqueInput
    create: XOR<WhatsAppConversationCreateWithoutContactInput, WhatsAppConversationUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppConversationCreateManyContactInputEnvelope = {
    data: WhatsAppConversationCreateManyContactInput | WhatsAppConversationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppMessageCreateWithoutContactInput = {
    id?: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutMessagesInput
    conversation: WhatsAppConversationCreateNestedOneWithoutMessagesInput
    toolExecution?: ToolExecutionCreateNestedOneWithoutWhatsappMessagesInput
  }

  export type WhatsAppMessageUncheckedCreateWithoutContactInput = {
    id?: string
    instanceId: string
    conversationId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageCreateOrConnectWithoutContactInput = {
    where: WhatsAppMessageWhereUniqueInput
    create: XOR<WhatsAppMessageCreateWithoutContactInput, WhatsAppMessageUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppMessageCreateManyContactInputEnvelope = {
    data: WhatsAppMessageCreateManyContactInput | WhatsAppMessageCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppImportCreateWithoutContactInput = {
    id?: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutImportsInput
    uploadedBy: UserCreateNestedOneWithoutWhatsappImportsUploadedInput
  }

  export type WhatsAppImportUncheckedCreateWithoutContactInput = {
    id?: string
    instanceId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    uploadedById: string
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportCreateOrConnectWithoutContactInput = {
    where: WhatsAppImportWhereUniqueInput
    create: XOR<WhatsAppImportCreateWithoutContactInput, WhatsAppImportUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppImportCreateManyContactInputEnvelope = {
    data: WhatsAppImportCreateManyContactInput | WhatsAppImportCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppInstanceUpsertWithoutContactsInput = {
    update: XOR<WhatsAppInstanceUpdateWithoutContactsInput, WhatsAppInstanceUncheckedUpdateWithoutContactsInput>
    create: XOR<WhatsAppInstanceCreateWithoutContactsInput, WhatsAppInstanceUncheckedCreateWithoutContactsInput>
    where?: WhatsAppInstanceWhereInput
  }

  export type WhatsAppInstanceUpdateToOneWithWhereWithoutContactsInput = {
    where?: WhatsAppInstanceWhereInput
    data: XOR<WhatsAppInstanceUpdateWithoutContactsInput, WhatsAppInstanceUncheckedUpdateWithoutContactsInput>
  }

  export type WhatsAppInstanceUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappInstancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutWhatsappInstancesCreatedNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type ClientUpsertWithoutWhatsappContactsInput = {
    update: XOR<ClientUpdateWithoutWhatsappContactsInput, ClientUncheckedUpdateWithoutWhatsappContactsInput>
    create: XOR<ClientCreateWithoutWhatsappContactsInput, ClientUncheckedCreateWithoutWhatsappContactsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutWhatsappContactsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutWhatsappContactsInput, ClientUncheckedUpdateWithoutWhatsappContactsInput>
  }

  export type ClientUpdateWithoutWhatsappContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutClientsNestedInput
    conversations?: ConversationUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutWhatsappContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUncheckedUpdateManyWithoutClientNestedInput
  }

  export type WhatsAppConversationUpsertWithWhereUniqueWithoutContactInput = {
    where: WhatsAppConversationWhereUniqueInput
    update: XOR<WhatsAppConversationUpdateWithoutContactInput, WhatsAppConversationUncheckedUpdateWithoutContactInput>
    create: XOR<WhatsAppConversationCreateWithoutContactInput, WhatsAppConversationUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppConversationUpdateWithWhereUniqueWithoutContactInput = {
    where: WhatsAppConversationWhereUniqueInput
    data: XOR<WhatsAppConversationUpdateWithoutContactInput, WhatsAppConversationUncheckedUpdateWithoutContactInput>
  }

  export type WhatsAppConversationUpdateManyWithWhereWithoutContactInput = {
    where: WhatsAppConversationScalarWhereInput
    data: XOR<WhatsAppConversationUpdateManyMutationInput, WhatsAppConversationUncheckedUpdateManyWithoutContactInput>
  }

  export type WhatsAppMessageUpsertWithWhereUniqueWithoutContactInput = {
    where: WhatsAppMessageWhereUniqueInput
    update: XOR<WhatsAppMessageUpdateWithoutContactInput, WhatsAppMessageUncheckedUpdateWithoutContactInput>
    create: XOR<WhatsAppMessageCreateWithoutContactInput, WhatsAppMessageUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppMessageUpdateWithWhereUniqueWithoutContactInput = {
    where: WhatsAppMessageWhereUniqueInput
    data: XOR<WhatsAppMessageUpdateWithoutContactInput, WhatsAppMessageUncheckedUpdateWithoutContactInput>
  }

  export type WhatsAppMessageUpdateManyWithWhereWithoutContactInput = {
    where: WhatsAppMessageScalarWhereInput
    data: XOR<WhatsAppMessageUpdateManyMutationInput, WhatsAppMessageUncheckedUpdateManyWithoutContactInput>
  }

  export type WhatsAppImportUpsertWithWhereUniqueWithoutContactInput = {
    where: WhatsAppImportWhereUniqueInput
    update: XOR<WhatsAppImportUpdateWithoutContactInput, WhatsAppImportUncheckedUpdateWithoutContactInput>
    create: XOR<WhatsAppImportCreateWithoutContactInput, WhatsAppImportUncheckedCreateWithoutContactInput>
  }

  export type WhatsAppImportUpdateWithWhereUniqueWithoutContactInput = {
    where: WhatsAppImportWhereUniqueInput
    data: XOR<WhatsAppImportUpdateWithoutContactInput, WhatsAppImportUncheckedUpdateWithoutContactInput>
  }

  export type WhatsAppImportUpdateManyWithWhereWithoutContactInput = {
    where: WhatsAppImportScalarWhereInput
    data: XOR<WhatsAppImportUpdateManyMutationInput, WhatsAppImportUncheckedUpdateManyWithoutContactInput>
  }

  export type WhatsAppInstanceCreateWithoutConversationsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappInstancesInput
    createdBy: UserCreateNestedOneWithoutWhatsappInstancesCreatedInput
    contacts?: WhatsAppContactCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: WhatsAppContactUncheckedCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceCreateOrConnectWithoutConversationsInput = {
    where: WhatsAppInstanceWhereUniqueInput
    create: XOR<WhatsAppInstanceCreateWithoutConversationsInput, WhatsAppInstanceUncheckedCreateWithoutConversationsInput>
  }

  export type WhatsAppContactCreateWithoutConversationsInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutContactsInput
    client?: ClientCreateNestedOneWithoutWhatsappContactsInput
    messages?: WhatsAppMessageCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactUncheckedCreateWithoutConversationsInput = {
    id?: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    clientId?: string | null
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactCreateOrConnectWithoutConversationsInput = {
    where: WhatsAppContactWhereUniqueInput
    create: XOR<WhatsAppContactCreateWithoutConversationsInput, WhatsAppContactUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutWhatsappConversationsAssignedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutWhatsappConversationsAssignedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutWhatsappConversationsAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsappConversationsAssignedInput, UserUncheckedCreateWithoutWhatsappConversationsAssignedInput>
  }

  export type AiAgentCreateWithoutWhatsappConversationsInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutAiAgentsInput
  }

  export type AiAgentUncheckedCreateWithoutWhatsappConversationsInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type AiAgentCreateOrConnectWithoutWhatsappConversationsInput = {
    where: AiAgentWhereUniqueInput
    create: XOR<AiAgentCreateWithoutWhatsappConversationsInput, AiAgentUncheckedCreateWithoutWhatsappConversationsInput>
  }

  export type WhatsAppMessageCreateWithoutConversationInput = {
    id?: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutMessagesInput
    contact: WhatsAppContactCreateNestedOneWithoutMessagesInput
    toolExecution?: ToolExecutionCreateNestedOneWithoutWhatsappMessagesInput
  }

  export type WhatsAppMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageCreateOrConnectWithoutConversationInput = {
    where: WhatsAppMessageWhereUniqueInput
    create: XOR<WhatsAppMessageCreateWithoutConversationInput, WhatsAppMessageUncheckedCreateWithoutConversationInput>
  }

  export type WhatsAppMessageCreateManyConversationInputEnvelope = {
    data: WhatsAppMessageCreateManyConversationInput | WhatsAppMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppInstanceUpsertWithoutConversationsInput = {
    update: XOR<WhatsAppInstanceUpdateWithoutConversationsInput, WhatsAppInstanceUncheckedUpdateWithoutConversationsInput>
    create: XOR<WhatsAppInstanceCreateWithoutConversationsInput, WhatsAppInstanceUncheckedCreateWithoutConversationsInput>
    where?: WhatsAppInstanceWhereInput
  }

  export type WhatsAppInstanceUpdateToOneWithWhereWithoutConversationsInput = {
    where?: WhatsAppInstanceWhereInput
    data: XOR<WhatsAppInstanceUpdateWithoutConversationsInput, WhatsAppInstanceUncheckedUpdateWithoutConversationsInput>
  }

  export type WhatsAppInstanceUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappInstancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutWhatsappInstancesCreatedNestedInput
    contacts?: WhatsAppContactUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: WhatsAppContactUncheckedUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppContactUpsertWithoutConversationsInput = {
    update: XOR<WhatsAppContactUpdateWithoutConversationsInput, WhatsAppContactUncheckedUpdateWithoutConversationsInput>
    create: XOR<WhatsAppContactCreateWithoutConversationsInput, WhatsAppContactUncheckedCreateWithoutConversationsInput>
    where?: WhatsAppContactWhereInput
  }

  export type WhatsAppContactUpdateToOneWithWhereWithoutConversationsInput = {
    where?: WhatsAppContactWhereInput
    data: XOR<WhatsAppContactUpdateWithoutConversationsInput, WhatsAppContactUncheckedUpdateWithoutConversationsInput>
  }

  export type WhatsAppContactUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutContactsNestedInput
    client?: ClientUpdateOneWithoutWhatsappContactsNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutWhatsappConversationsAssignedInput = {
    update: XOR<UserUpdateWithoutWhatsappConversationsAssignedInput, UserUncheckedUpdateWithoutWhatsappConversationsAssignedInput>
    create: XOR<UserCreateWithoutWhatsappConversationsAssignedInput, UserUncheckedCreateWithoutWhatsappConversationsAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsappConversationsAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsappConversationsAssignedInput, UserUncheckedUpdateWithoutWhatsappConversationsAssignedInput>
  }

  export type UserUpdateWithoutWhatsappConversationsAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsappConversationsAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type AiAgentUpsertWithoutWhatsappConversationsInput = {
    update: XOR<AiAgentUpdateWithoutWhatsappConversationsInput, AiAgentUncheckedUpdateWithoutWhatsappConversationsInput>
    create: XOR<AiAgentCreateWithoutWhatsappConversationsInput, AiAgentUncheckedCreateWithoutWhatsappConversationsInput>
    where?: AiAgentWhereInput
  }

  export type AiAgentUpdateToOneWithWhereWithoutWhatsappConversationsInput = {
    where?: AiAgentWhereInput
    data: XOR<AiAgentUpdateWithoutWhatsappConversationsInput, AiAgentUncheckedUpdateWithoutWhatsappConversationsInput>
  }

  export type AiAgentUpdateWithoutWhatsappConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutAiAgentsNestedInput
  }

  export type AiAgentUncheckedUpdateWithoutWhatsappConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: WhatsAppMessageWhereUniqueInput
    update: XOR<WhatsAppMessageUpdateWithoutConversationInput, WhatsAppMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<WhatsAppMessageCreateWithoutConversationInput, WhatsAppMessageUncheckedCreateWithoutConversationInput>
  }

  export type WhatsAppMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: WhatsAppMessageWhereUniqueInput
    data: XOR<WhatsAppMessageUpdateWithoutConversationInput, WhatsAppMessageUncheckedUpdateWithoutConversationInput>
  }

  export type WhatsAppMessageUpdateManyWithWhereWithoutConversationInput = {
    where: WhatsAppMessageScalarWhereInput
    data: XOR<WhatsAppMessageUpdateManyMutationInput, WhatsAppMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type WhatsAppInstanceCreateWithoutMessagesInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappInstancesInput
    createdBy: UserCreateNestedOneWithoutWhatsappInstancesCreatedInput
    contacts?: WhatsAppContactCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: WhatsAppContactUncheckedCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutInstanceInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceCreateOrConnectWithoutMessagesInput = {
    where: WhatsAppInstanceWhereUniqueInput
    create: XOR<WhatsAppInstanceCreateWithoutMessagesInput, WhatsAppInstanceUncheckedCreateWithoutMessagesInput>
  }

  export type WhatsAppConversationCreateWithoutMessagesInput = {
    id?: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutConversationsInput
    contact: WhatsAppContactCreateNestedOneWithoutConversationsInput
    assignedUser?: UserCreateNestedOneWithoutWhatsappConversationsAssignedInput
    currentAgent?: AiAgentCreateNestedOneWithoutWhatsappConversationsInput
  }

  export type WhatsAppConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppConversationCreateOrConnectWithoutMessagesInput = {
    where: WhatsAppConversationWhereUniqueInput
    create: XOR<WhatsAppConversationCreateWithoutMessagesInput, WhatsAppConversationUncheckedCreateWithoutMessagesInput>
  }

  export type WhatsAppContactCreateWithoutMessagesInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutContactsInput
    client?: ClientCreateNestedOneWithoutWhatsappContactsInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactUncheckedCreateWithoutMessagesInput = {
    id?: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    clientId?: string | null
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactCreateOrConnectWithoutMessagesInput = {
    where: WhatsAppContactWhereUniqueInput
    create: XOR<WhatsAppContactCreateWithoutMessagesInput, WhatsAppContactUncheckedCreateWithoutMessagesInput>
  }

  export type ToolExecutionCreateWithoutWhatsappMessagesInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
    tool: ToolCreateNestedOneWithoutExecutionsInput
  }

  export type ToolExecutionUncheckedCreateWithoutWhatsappMessagesInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
    toolId: string
  }

  export type ToolExecutionCreateOrConnectWithoutWhatsappMessagesInput = {
    where: ToolExecutionWhereUniqueInput
    create: XOR<ToolExecutionCreateWithoutWhatsappMessagesInput, ToolExecutionUncheckedCreateWithoutWhatsappMessagesInput>
  }

  export type WhatsAppInstanceUpsertWithoutMessagesInput = {
    update: XOR<WhatsAppInstanceUpdateWithoutMessagesInput, WhatsAppInstanceUncheckedUpdateWithoutMessagesInput>
    create: XOR<WhatsAppInstanceCreateWithoutMessagesInput, WhatsAppInstanceUncheckedCreateWithoutMessagesInput>
    where?: WhatsAppInstanceWhereInput
  }

  export type WhatsAppInstanceUpdateToOneWithWhereWithoutMessagesInput = {
    where?: WhatsAppInstanceWhereInput
    data: XOR<WhatsAppInstanceUpdateWithoutMessagesInput, WhatsAppInstanceUncheckedUpdateWithoutMessagesInput>
  }

  export type WhatsAppInstanceUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappInstancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutWhatsappInstancesCreatedNestedInput
    contacts?: WhatsAppContactUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: WhatsAppContactUncheckedUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppConversationUpsertWithoutMessagesInput = {
    update: XOR<WhatsAppConversationUpdateWithoutMessagesInput, WhatsAppConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<WhatsAppConversationCreateWithoutMessagesInput, WhatsAppConversationUncheckedCreateWithoutMessagesInput>
    where?: WhatsAppConversationWhereInput
  }

  export type WhatsAppConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: WhatsAppConversationWhereInput
    data: XOR<WhatsAppConversationUpdateWithoutMessagesInput, WhatsAppConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type WhatsAppConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutConversationsNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutConversationsNestedInput
    assignedUser?: UserUpdateOneWithoutWhatsappConversationsAssignedNestedInput
    currentAgent?: AiAgentUpdateOneWithoutWhatsappConversationsNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppContactUpsertWithoutMessagesInput = {
    update: XOR<WhatsAppContactUpdateWithoutMessagesInput, WhatsAppContactUncheckedUpdateWithoutMessagesInput>
    create: XOR<WhatsAppContactCreateWithoutMessagesInput, WhatsAppContactUncheckedCreateWithoutMessagesInput>
    where?: WhatsAppContactWhereInput
  }

  export type WhatsAppContactUpdateToOneWithWhereWithoutMessagesInput = {
    where?: WhatsAppContactWhereInput
    data: XOR<WhatsAppContactUpdateWithoutMessagesInput, WhatsAppContactUncheckedUpdateWithoutMessagesInput>
  }

  export type WhatsAppContactUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutContactsNestedInput
    client?: ClientUpdateOneWithoutWhatsappContactsNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ToolExecutionUpsertWithoutWhatsappMessagesInput = {
    update: XOR<ToolExecutionUpdateWithoutWhatsappMessagesInput, ToolExecutionUncheckedUpdateWithoutWhatsappMessagesInput>
    create: XOR<ToolExecutionCreateWithoutWhatsappMessagesInput, ToolExecutionUncheckedCreateWithoutWhatsappMessagesInput>
    where?: ToolExecutionWhereInput
  }

  export type ToolExecutionUpdateToOneWithWhereWithoutWhatsappMessagesInput = {
    where?: ToolExecutionWhereInput
    data: XOR<ToolExecutionUpdateWithoutWhatsappMessagesInput, ToolExecutionUncheckedUpdateWithoutWhatsappMessagesInput>
  }

  export type ToolExecutionUpdateWithoutWhatsappMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tool?: ToolUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type ToolExecutionUncheckedUpdateWithoutWhatsappMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    toolId?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppInstanceCreateWithoutImportsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappInstancesInput
    createdBy: UserCreateNestedOneWithoutWhatsappInstancesCreatedInput
    contacts?: WhatsAppContactCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceUncheckedCreateWithoutImportsInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: WhatsAppContactUncheckedCreateNestedManyWithoutInstanceInput
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutInstanceInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type WhatsAppInstanceCreateOrConnectWithoutImportsInput = {
    where: WhatsAppInstanceWhereUniqueInput
    create: XOR<WhatsAppInstanceCreateWithoutImportsInput, WhatsAppInstanceUncheckedCreateWithoutImportsInput>
  }

  export type WhatsAppContactCreateWithoutImportsInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutContactsInput
    client?: ClientCreateNestedOneWithoutWhatsappContactsInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactUncheckedCreateWithoutImportsInput = {
    id?: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    clientId?: string | null
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactCreateOrConnectWithoutImportsInput = {
    where: WhatsAppContactWhereUniqueInput
    create: XOR<WhatsAppContactCreateWithoutImportsInput, WhatsAppContactUncheckedCreateWithoutImportsInput>
  }

  export type UserCreateWithoutWhatsappImportsUploadedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutWhatsappImportsUploadedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutWhatsappImportsUploadedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsappImportsUploadedInput, UserUncheckedCreateWithoutWhatsappImportsUploadedInput>
  }

  export type WhatsAppInstanceUpsertWithoutImportsInput = {
    update: XOR<WhatsAppInstanceUpdateWithoutImportsInput, WhatsAppInstanceUncheckedUpdateWithoutImportsInput>
    create: XOR<WhatsAppInstanceCreateWithoutImportsInput, WhatsAppInstanceUncheckedCreateWithoutImportsInput>
    where?: WhatsAppInstanceWhereInput
  }

  export type WhatsAppInstanceUpdateToOneWithWhereWithoutImportsInput = {
    where?: WhatsAppInstanceWhereInput
    data: XOR<WhatsAppInstanceUpdateWithoutImportsInput, WhatsAppInstanceUncheckedUpdateWithoutImportsInput>
  }

  export type WhatsAppInstanceUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappInstancesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutWhatsappInstancesCreatedNestedInput
    contacts?: WhatsAppContactUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: WhatsAppContactUncheckedUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppContactUpsertWithoutImportsInput = {
    update: XOR<WhatsAppContactUpdateWithoutImportsInput, WhatsAppContactUncheckedUpdateWithoutImportsInput>
    create: XOR<WhatsAppContactCreateWithoutImportsInput, WhatsAppContactUncheckedCreateWithoutImportsInput>
    where?: WhatsAppContactWhereInput
  }

  export type WhatsAppContactUpdateToOneWithWhereWithoutImportsInput = {
    where?: WhatsAppContactWhereInput
    data: XOR<WhatsAppContactUpdateWithoutImportsInput, WhatsAppContactUncheckedUpdateWithoutImportsInput>
  }

  export type WhatsAppContactUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutContactsNestedInput
    client?: ClientUpdateOneWithoutWhatsappContactsNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutWhatsappImportsUploadedInput = {
    update: XOR<UserUpdateWithoutWhatsappImportsUploadedInput, UserUncheckedUpdateWithoutWhatsappImportsUploadedInput>
    create: XOR<UserCreateWithoutWhatsappImportsUploadedInput, UserUncheckedCreateWithoutWhatsappImportsUploadedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsappImportsUploadedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsappImportsUploadedInput, UserUncheckedUpdateWithoutWhatsappImportsUploadedInput>
  }

  export type UserUpdateWithoutWhatsappImportsUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsappImportsUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type OfficeCreateWithoutClientsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutClientsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutClientsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutClientsInput, OfficeUncheckedCreateWithoutClientsInput>
  }

  export type ConversationCreateWithoutClientInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutClientInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutClientInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput>
  }

  export type ConversationCreateManyClientInputEnvelope = {
    data: ConversationCreateManyClientInput | ConversationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutClientInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type DocumentCreateOrConnectWithoutClientInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentCreateManyClientInputEnvelope = {
    data: DocumentCreateManyClientInput | DocumentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientTagCreateWithoutClientInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutClientTagsInput
  }

  export type ClientTagUncheckedCreateWithoutClientInput = {
    id?: string
    createdAt?: Date | string
    tagId: string
  }

  export type ClientTagCreateOrConnectWithoutClientInput = {
    where: ClientTagWhereUniqueInput
    create: XOR<ClientTagCreateWithoutClientInput, ClientTagUncheckedCreateWithoutClientInput>
  }

  export type ClientTagCreateManyClientInputEnvelope = {
    data: ClientTagCreateManyClientInput | ClientTagCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppContactCreateWithoutClientInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutContactsInput
    conversations?: WhatsAppConversationCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactUncheckedCreateWithoutClientInput = {
    id?: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: WhatsAppConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutContactInput
    imports?: WhatsAppImportUncheckedCreateNestedManyWithoutContactInput
  }

  export type WhatsAppContactCreateOrConnectWithoutClientInput = {
    where: WhatsAppContactWhereUniqueInput
    create: XOR<WhatsAppContactCreateWithoutClientInput, WhatsAppContactUncheckedCreateWithoutClientInput>
  }

  export type WhatsAppContactCreateManyClientInputEnvelope = {
    data: WhatsAppContactCreateManyClientInput | WhatsAppContactCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutClientsInput = {
    update: XOR<OfficeUpdateWithoutClientsInput, OfficeUncheckedUpdateWithoutClientsInput>
    create: XOR<OfficeCreateWithoutClientsInput, OfficeUncheckedCreateWithoutClientsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutClientsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutClientsInput, OfficeUncheckedUpdateWithoutClientsInput>
  }

  export type OfficeUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type ConversationUpsertWithWhereUniqueWithoutClientInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutClientInput, ConversationUncheckedUpdateWithoutClientInput>
    create: XOR<ConversationCreateWithoutClientInput, ConversationUncheckedCreateWithoutClientInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutClientInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutClientInput, ConversationUncheckedUpdateWithoutClientInput>
  }

  export type ConversationUpdateManyWithWhereWithoutClientInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutClientInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClientInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientTagUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientTagWhereUniqueInput
    update: XOR<ClientTagUpdateWithoutClientInput, ClientTagUncheckedUpdateWithoutClientInput>
    create: XOR<ClientTagCreateWithoutClientInput, ClientTagUncheckedCreateWithoutClientInput>
  }

  export type ClientTagUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientTagWhereUniqueInput
    data: XOR<ClientTagUpdateWithoutClientInput, ClientTagUncheckedUpdateWithoutClientInput>
  }

  export type ClientTagUpdateManyWithWhereWithoutClientInput = {
    where: ClientTagScalarWhereInput
    data: XOR<ClientTagUpdateManyMutationInput, ClientTagUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientTagScalarWhereInput = {
    AND?: ClientTagScalarWhereInput | ClientTagScalarWhereInput[]
    OR?: ClientTagScalarWhereInput[]
    NOT?: ClientTagScalarWhereInput | ClientTagScalarWhereInput[]
    id?: StringFilter<"ClientTag"> | string
    createdAt?: DateTimeFilter<"ClientTag"> | Date | string
    clientId?: StringFilter<"ClientTag"> | string
    tagId?: StringFilter<"ClientTag"> | string
  }

  export type WhatsAppContactUpsertWithWhereUniqueWithoutClientInput = {
    where: WhatsAppContactWhereUniqueInput
    update: XOR<WhatsAppContactUpdateWithoutClientInput, WhatsAppContactUncheckedUpdateWithoutClientInput>
    create: XOR<WhatsAppContactCreateWithoutClientInput, WhatsAppContactUncheckedCreateWithoutClientInput>
  }

  export type WhatsAppContactUpdateWithWhereUniqueWithoutClientInput = {
    where: WhatsAppContactWhereUniqueInput
    data: XOR<WhatsAppContactUpdateWithoutClientInput, WhatsAppContactUncheckedUpdateWithoutClientInput>
  }

  export type WhatsAppContactUpdateManyWithWhereWithoutClientInput = {
    where: WhatsAppContactScalarWhereInput
    data: XOR<WhatsAppContactUpdateManyMutationInput, WhatsAppContactUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutClientsInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    clientTags?: ClientTagCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutConversationsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
  }

  export type OfficeCreateWithoutConversationsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutConversationsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutConversationsInput, OfficeUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutCreatedConversationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutCreatedConversationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutCreatedConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedConversationsInput, UserUncheckedCreateWithoutCreatedConversationsInput>
  }

  export type UserCreateWithoutAssignedConversationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutAssignedConversationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutAssignedConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedConversationsInput, UserUncheckedCreateWithoutAssignedConversationsInput>
  }

  export type WhatsappConfigCreateWithoutConversationsInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappConfigsInput
    messages?: MessageCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigUncheckedCreateWithoutConversationsInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    messages?: MessageUncheckedCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigCreateOrConnectWithoutConversationsInput = {
    where: WhatsappConfigWhereUniqueInput
    create: XOR<WhatsappConfigCreateWithoutConversationsInput, WhatsappConfigUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutMessagesInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutMessagesInput
    audioTranscription?: AudioTranscriptionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    whatsappConfigId?: string | null
    audioTranscription?: AudioTranscriptionUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationTagCreateWithoutConversationInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutConversationTagsInput
  }

  export type ConversationTagUncheckedCreateWithoutConversationInput = {
    id?: string
    createdAt?: Date | string
    tagId: string
  }

  export type ConversationTagCreateOrConnectWithoutConversationInput = {
    where: ConversationTagWhereUniqueInput
    create: XOR<ConversationTagCreateWithoutConversationInput, ConversationTagUncheckedCreateWithoutConversationInput>
  }

  export type ConversationTagCreateManyConversationInputEnvelope = {
    data: ConversationTagCreateManyConversationInput | ConversationTagCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCustomStatusCreateWithoutConversationInput = {
    id?: string
    createdAt?: Date | string
    customStatus: CustomStatusCreateNestedOneWithoutConversationStatusesInput
  }

  export type ConversationCustomStatusUncheckedCreateWithoutConversationInput = {
    id?: string
    createdAt?: Date | string
    customStatusId: string
  }

  export type ConversationCustomStatusCreateOrConnectWithoutConversationInput = {
    where: ConversationCustomStatusWhereUniqueInput
    create: XOR<ConversationCustomStatusCreateWithoutConversationInput, ConversationCustomStatusUncheckedCreateWithoutConversationInput>
  }

  export type ConversationCustomStatusCreateManyConversationInputEnvelope = {
    data: ConversationCustomStatusCreateManyConversationInput | ConversationCustomStatusCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutConversationsInput = {
    update: XOR<ClientUpdateWithoutConversationsInput, ClientUncheckedUpdateWithoutConversationsInput>
    create: XOR<ClientCreateWithoutConversationsInput, ClientUncheckedCreateWithoutConversationsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutConversationsInput, ClientUncheckedUpdateWithoutConversationsInput>
  }

  export type ClientUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutClientsNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUncheckedUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type OfficeUpsertWithoutConversationsInput = {
    update: XOR<OfficeUpdateWithoutConversationsInput, OfficeUncheckedUpdateWithoutConversationsInput>
    create: XOR<OfficeCreateWithoutConversationsInput, OfficeUncheckedCreateWithoutConversationsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutConversationsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutConversationsInput, OfficeUncheckedUpdateWithoutConversationsInput>
  }

  export type OfficeUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type UserUpsertWithoutCreatedConversationsInput = {
    update: XOR<UserUpdateWithoutCreatedConversationsInput, UserUncheckedUpdateWithoutCreatedConversationsInput>
    create: XOR<UserCreateWithoutCreatedConversationsInput, UserUncheckedCreateWithoutCreatedConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedConversationsInput, UserUncheckedUpdateWithoutCreatedConversationsInput>
  }

  export type UserUpdateWithoutCreatedConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUpsertWithoutAssignedConversationsInput = {
    update: XOR<UserUpdateWithoutAssignedConversationsInput, UserUncheckedUpdateWithoutAssignedConversationsInput>
    create: XOR<UserCreateWithoutAssignedConversationsInput, UserUncheckedCreateWithoutAssignedConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedConversationsInput, UserUncheckedUpdateWithoutAssignedConversationsInput>
  }

  export type UserUpdateWithoutAssignedConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type WhatsappConfigUpsertWithoutConversationsInput = {
    update: XOR<WhatsappConfigUpdateWithoutConversationsInput, WhatsappConfigUncheckedUpdateWithoutConversationsInput>
    create: XOR<WhatsappConfigCreateWithoutConversationsInput, WhatsappConfigUncheckedCreateWithoutConversationsInput>
    where?: WhatsappConfigWhereInput
  }

  export type WhatsappConfigUpdateToOneWithWhereWithoutConversationsInput = {
    where?: WhatsappConfigWhereInput
    data: XOR<WhatsappConfigUpdateWithoutConversationsInput, WhatsappConfigUncheckedUpdateWithoutConversationsInput>
  }

  export type WhatsappConfigUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappConfigsNestedInput
    messages?: MessageUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type WhatsappConfigUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationTagUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationTagWhereUniqueInput
    update: XOR<ConversationTagUpdateWithoutConversationInput, ConversationTagUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationTagCreateWithoutConversationInput, ConversationTagUncheckedCreateWithoutConversationInput>
  }

  export type ConversationTagUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationTagWhereUniqueInput
    data: XOR<ConversationTagUpdateWithoutConversationInput, ConversationTagUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationTagUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationTagScalarWhereInput
    data: XOR<ConversationTagUpdateManyMutationInput, ConversationTagUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationTagScalarWhereInput = {
    AND?: ConversationTagScalarWhereInput | ConversationTagScalarWhereInput[]
    OR?: ConversationTagScalarWhereInput[]
    NOT?: ConversationTagScalarWhereInput | ConversationTagScalarWhereInput[]
    id?: StringFilter<"ConversationTag"> | string
    createdAt?: DateTimeFilter<"ConversationTag"> | Date | string
    conversationId?: StringFilter<"ConversationTag"> | string
    tagId?: StringFilter<"ConversationTag"> | string
  }

  export type ConversationCustomStatusUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationCustomStatusWhereUniqueInput
    update: XOR<ConversationCustomStatusUpdateWithoutConversationInput, ConversationCustomStatusUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationCustomStatusCreateWithoutConversationInput, ConversationCustomStatusUncheckedCreateWithoutConversationInput>
  }

  export type ConversationCustomStatusUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationCustomStatusWhereUniqueInput
    data: XOR<ConversationCustomStatusUpdateWithoutConversationInput, ConversationCustomStatusUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationCustomStatusUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationCustomStatusScalarWhereInput
    data: XOR<ConversationCustomStatusUpdateManyMutationInput, ConversationCustomStatusUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCustomStatusScalarWhereInput = {
    AND?: ConversationCustomStatusScalarWhereInput | ConversationCustomStatusScalarWhereInput[]
    OR?: ConversationCustomStatusScalarWhereInput[]
    NOT?: ConversationCustomStatusScalarWhereInput | ConversationCustomStatusScalarWhereInput[]
    id?: StringFilter<"ConversationCustomStatus"> | string
    createdAt?: DateTimeFilter<"ConversationCustomStatus"> | Date | string
    conversationId?: StringFilter<"ConversationCustomStatus"> | string
    customStatusId?: StringFilter<"ConversationCustomStatus"> | string
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    office: OfficeCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type WhatsappConfigCreateWithoutMessagesInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWhatsappConfigsInput
    conversations?: ConversationCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigUncheckedCreateWithoutMessagesInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutWhatsappConfigInput
  }

  export type WhatsappConfigCreateOrConnectWithoutMessagesInput = {
    where: WhatsappConfigWhereUniqueInput
    create: XOR<WhatsappConfigCreateWithoutMessagesInput, WhatsappConfigUncheckedCreateWithoutMessagesInput>
  }

  export type AudioTranscriptionCreateWithoutMessageInput = {
    id?: string
    originalText?: string | null
    provider: $Enums.TranscriptionProvider
    confidence?: number | null
    duration?: number | null
    language?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioTranscriptionUncheckedCreateWithoutMessageInput = {
    id?: string
    originalText?: string | null
    provider: $Enums.TranscriptionProvider
    confidence?: number | null
    duration?: number | null
    language?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioTranscriptionCreateOrConnectWithoutMessageInput = {
    where: AudioTranscriptionWhereUniqueInput
    create: XOR<AudioTranscriptionCreateWithoutMessageInput, AudioTranscriptionUncheckedCreateWithoutMessageInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type WhatsappConfigUpsertWithoutMessagesInput = {
    update: XOR<WhatsappConfigUpdateWithoutMessagesInput, WhatsappConfigUncheckedUpdateWithoutMessagesInput>
    create: XOR<WhatsappConfigCreateWithoutMessagesInput, WhatsappConfigUncheckedCreateWithoutMessagesInput>
    where?: WhatsappConfigWhereInput
  }

  export type WhatsappConfigUpdateToOneWithWhereWithoutMessagesInput = {
    where?: WhatsappConfigWhereInput
    data: XOR<WhatsappConfigUpdateWithoutMessagesInput, WhatsappConfigUncheckedUpdateWithoutMessagesInput>
  }

  export type WhatsappConfigUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappConfigsNestedInput
    conversations?: ConversationUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type WhatsappConfigUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type AudioTranscriptionUpsertWithoutMessageInput = {
    update: XOR<AudioTranscriptionUpdateWithoutMessageInput, AudioTranscriptionUncheckedUpdateWithoutMessageInput>
    create: XOR<AudioTranscriptionCreateWithoutMessageInput, AudioTranscriptionUncheckedCreateWithoutMessageInput>
    where?: AudioTranscriptionWhereInput
  }

  export type AudioTranscriptionUpdateToOneWithWhereWithoutMessageInput = {
    where?: AudioTranscriptionWhereInput
    data: XOR<AudioTranscriptionUpdateWithoutMessageInput, AudioTranscriptionUncheckedUpdateWithoutMessageInput>
  }

  export type AudioTranscriptionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTranscriptionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalText?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateWithoutAudioTranscriptionInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutMessagesInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutAudioTranscriptionInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    userId?: string | null
    whatsappConfigId?: string | null
  }

  export type MessageCreateOrConnectWithoutAudioTranscriptionInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAudioTranscriptionInput, MessageUncheckedCreateWithoutAudioTranscriptionInput>
  }

  export type MessageUpsertWithoutAudioTranscriptionInput = {
    update: XOR<MessageUpdateWithoutAudioTranscriptionInput, MessageUncheckedUpdateWithoutAudioTranscriptionInput>
    create: XOR<MessageCreateWithoutAudioTranscriptionInput, MessageUncheckedCreateWithoutAudioTranscriptionInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAudioTranscriptionInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAudioTranscriptionInput, MessageUncheckedUpdateWithoutAudioTranscriptionInput>
  }

  export type MessageUpdateWithoutAudioTranscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutMessagesNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutAudioTranscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OfficeCreateWithoutTagsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutTagsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutTagsInput, OfficeUncheckedCreateWithoutTagsInput>
  }

  export type ClientTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutClientTagsInput
  }

  export type ClientTagUncheckedCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    clientId: string
  }

  export type ClientTagCreateOrConnectWithoutTagInput = {
    where: ClientTagWhereUniqueInput
    create: XOR<ClientTagCreateWithoutTagInput, ClientTagUncheckedCreateWithoutTagInput>
  }

  export type ClientTagCreateManyTagInputEnvelope = {
    data: ClientTagCreateManyTagInput | ClientTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ConversationTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutConversationTagsInput
  }

  export type ConversationTagUncheckedCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
  }

  export type ConversationTagCreateOrConnectWithoutTagInput = {
    where: ConversationTagWhereUniqueInput
    create: XOR<ConversationTagCreateWithoutTagInput, ConversationTagUncheckedCreateWithoutTagInput>
  }

  export type ConversationTagCreateManyTagInputEnvelope = {
    data: ConversationTagCreateManyTagInput | ConversationTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutTagsInput = {
    update: XOR<OfficeUpdateWithoutTagsInput, OfficeUncheckedUpdateWithoutTagsInput>
    create: XOR<OfficeCreateWithoutTagsInput, OfficeUncheckedCreateWithoutTagsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutTagsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutTagsInput, OfficeUncheckedUpdateWithoutTagsInput>
  }

  export type OfficeUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type ClientTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ClientTagWhereUniqueInput
    update: XOR<ClientTagUpdateWithoutTagInput, ClientTagUncheckedUpdateWithoutTagInput>
    create: XOR<ClientTagCreateWithoutTagInput, ClientTagUncheckedCreateWithoutTagInput>
  }

  export type ClientTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ClientTagWhereUniqueInput
    data: XOR<ClientTagUpdateWithoutTagInput, ClientTagUncheckedUpdateWithoutTagInput>
  }

  export type ClientTagUpdateManyWithWhereWithoutTagInput = {
    where: ClientTagScalarWhereInput
    data: XOR<ClientTagUpdateManyMutationInput, ClientTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ConversationTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ConversationTagWhereUniqueInput
    update: XOR<ConversationTagUpdateWithoutTagInput, ConversationTagUncheckedUpdateWithoutTagInput>
    create: XOR<ConversationTagCreateWithoutTagInput, ConversationTagUncheckedCreateWithoutTagInput>
  }

  export type ConversationTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ConversationTagWhereUniqueInput
    data: XOR<ConversationTagUpdateWithoutTagInput, ConversationTagUncheckedUpdateWithoutTagInput>
  }

  export type ConversationTagUpdateManyWithWhereWithoutTagInput = {
    where: ConversationTagScalarWhereInput
    data: XOR<ConversationTagUpdateManyMutationInput, ConversationTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ClientCreateWithoutClientTagsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutClientsInput
    conversations?: ConversationCreateNestedManyWithoutClientInput
    documents?: DocumentCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientTagsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientTagsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientTagsInput, ClientUncheckedCreateWithoutClientTagsInput>
  }

  export type TagCreateWithoutClientTagsInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutTagsInput
    conversationTags?: ConversationTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutClientTagsInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutClientTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutClientTagsInput, TagUncheckedCreateWithoutClientTagsInput>
  }

  export type ClientUpsertWithoutClientTagsInput = {
    update: XOR<ClientUpdateWithoutClientTagsInput, ClientUncheckedUpdateWithoutClientTagsInput>
    create: XOR<ClientCreateWithoutClientTagsInput, ClientUncheckedCreateWithoutClientTagsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientTagsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientTagsInput, ClientUncheckedUpdateWithoutClientTagsInput>
  }

  export type ClientUpdateWithoutClientTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutClientsNestedInput
    conversations?: ConversationUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type TagUpsertWithoutClientTagsInput = {
    update: XOR<TagUpdateWithoutClientTagsInput, TagUncheckedUpdateWithoutClientTagsInput>
    create: XOR<TagCreateWithoutClientTagsInput, TagUncheckedCreateWithoutClientTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutClientTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutClientTagsInput, TagUncheckedUpdateWithoutClientTagsInput>
  }

  export type TagUpdateWithoutClientTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutTagsNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutClientTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type ConversationCreateWithoutConversationTagsInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    office: OfficeCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutConversationTagsInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationStatus?: ConversationCustomStatusUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutConversationTagsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutConversationTagsInput, ConversationUncheckedCreateWithoutConversationTagsInput>
  }

  export type TagCreateWithoutConversationTagsInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutTagsInput
    clientTags?: ClientTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutConversationTagsInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutConversationTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutConversationTagsInput, TagUncheckedCreateWithoutConversationTagsInput>
  }

  export type ConversationUpsertWithoutConversationTagsInput = {
    update: XOR<ConversationUpdateWithoutConversationTagsInput, ConversationUncheckedUpdateWithoutConversationTagsInput>
    create: XOR<ConversationCreateWithoutConversationTagsInput, ConversationUncheckedCreateWithoutConversationTagsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutConversationTagsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutConversationTagsInput, ConversationUncheckedUpdateWithoutConversationTagsInput>
  }

  export type ConversationUpdateWithoutConversationTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutConversationTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type TagUpsertWithoutConversationTagsInput = {
    update: XOR<TagUpdateWithoutConversationTagsInput, TagUncheckedUpdateWithoutConversationTagsInput>
    create: XOR<TagCreateWithoutConversationTagsInput, TagUncheckedCreateWithoutConversationTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutConversationTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutConversationTagsInput, TagUncheckedUpdateWithoutConversationTagsInput>
  }

  export type TagUpdateWithoutConversationTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutTagsNestedInput
    clientTags?: ClientTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutConversationTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    clientTags?: ClientTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type OfficeCreateWithoutCustomStatusesInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutCustomStatusesInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutCustomStatusesInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutCustomStatusesInput, OfficeUncheckedCreateWithoutCustomStatusesInput>
  }

  export type ConversationCustomStatusCreateWithoutCustomStatusInput = {
    id?: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutConversationStatusInput
  }

  export type ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
  }

  export type ConversationCustomStatusCreateOrConnectWithoutCustomStatusInput = {
    where: ConversationCustomStatusWhereUniqueInput
    create: XOR<ConversationCustomStatusCreateWithoutCustomStatusInput, ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput>
  }

  export type ConversationCustomStatusCreateManyCustomStatusInputEnvelope = {
    data: ConversationCustomStatusCreateManyCustomStatusInput | ConversationCustomStatusCreateManyCustomStatusInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutCustomStatusesInput = {
    update: XOR<OfficeUpdateWithoutCustomStatusesInput, OfficeUncheckedUpdateWithoutCustomStatusesInput>
    create: XOR<OfficeCreateWithoutCustomStatusesInput, OfficeUncheckedCreateWithoutCustomStatusesInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutCustomStatusesInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutCustomStatusesInput, OfficeUncheckedUpdateWithoutCustomStatusesInput>
  }

  export type OfficeUpdateWithoutCustomStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutCustomStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type ConversationCustomStatusUpsertWithWhereUniqueWithoutCustomStatusInput = {
    where: ConversationCustomStatusWhereUniqueInput
    update: XOR<ConversationCustomStatusUpdateWithoutCustomStatusInput, ConversationCustomStatusUncheckedUpdateWithoutCustomStatusInput>
    create: XOR<ConversationCustomStatusCreateWithoutCustomStatusInput, ConversationCustomStatusUncheckedCreateWithoutCustomStatusInput>
  }

  export type ConversationCustomStatusUpdateWithWhereUniqueWithoutCustomStatusInput = {
    where: ConversationCustomStatusWhereUniqueInput
    data: XOR<ConversationCustomStatusUpdateWithoutCustomStatusInput, ConversationCustomStatusUncheckedUpdateWithoutCustomStatusInput>
  }

  export type ConversationCustomStatusUpdateManyWithWhereWithoutCustomStatusInput = {
    where: ConversationCustomStatusScalarWhereInput
    data: XOR<ConversationCustomStatusUpdateManyMutationInput, ConversationCustomStatusUncheckedUpdateManyWithoutCustomStatusInput>
  }

  export type ConversationCreateWithoutConversationStatusInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutConversationsInput
    office: OfficeCreateNestedOneWithoutConversationsInput
    creator: UserCreateNestedOneWithoutCreatedConversationsInput
    assignee?: UserCreateNestedOneWithoutAssignedConversationsInput
    whatsappConfig?: WhatsappConfigCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutConversationStatusInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    conversationTags?: ConversationTagUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutConversationStatusInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutConversationStatusInput, ConversationUncheckedCreateWithoutConversationStatusInput>
  }

  export type CustomStatusCreateWithoutConversationStatusesInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutCustomStatusesInput
  }

  export type CustomStatusUncheckedCreateWithoutConversationStatusesInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type CustomStatusCreateOrConnectWithoutConversationStatusesInput = {
    where: CustomStatusWhereUniqueInput
    create: XOR<CustomStatusCreateWithoutConversationStatusesInput, CustomStatusUncheckedCreateWithoutConversationStatusesInput>
  }

  export type ConversationUpsertWithoutConversationStatusInput = {
    update: XOR<ConversationUpdateWithoutConversationStatusInput, ConversationUncheckedUpdateWithoutConversationStatusInput>
    create: XOR<ConversationCreateWithoutConversationStatusInput, ConversationUncheckedCreateWithoutConversationStatusInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutConversationStatusInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutConversationStatusInput, ConversationUncheckedUpdateWithoutConversationStatusInput>
  }

  export type ConversationUpdateWithoutConversationStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutConversationStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type CustomStatusUpsertWithoutConversationStatusesInput = {
    update: XOR<CustomStatusUpdateWithoutConversationStatusesInput, CustomStatusUncheckedUpdateWithoutConversationStatusesInput>
    create: XOR<CustomStatusCreateWithoutConversationStatusesInput, CustomStatusUncheckedCreateWithoutConversationStatusesInput>
    where?: CustomStatusWhereInput
  }

  export type CustomStatusUpdateToOneWithWhereWithoutConversationStatusesInput = {
    where?: CustomStatusWhereInput
    data: XOR<CustomStatusUpdateWithoutConversationStatusesInput, CustomStatusUncheckedUpdateWithoutConversationStatusesInput>
  }

  export type CustomStatusUpdateWithoutConversationStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutCustomStatusesNestedInput
  }

  export type CustomStatusUncheckedUpdateWithoutConversationStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type OfficeCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutAiAgentsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutAiAgentsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutAiAgentsInput, OfficeUncheckedCreateWithoutAiAgentsInput>
  }

  export type WhatsAppConversationCreateWithoutCurrentAgentInput = {
    id?: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutConversationsInput
    contact: WhatsAppContactCreateNestedOneWithoutConversationsInput
    assignedUser?: UserCreateNestedOneWithoutWhatsappConversationsAssignedInput
    messages?: WhatsAppMessageCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: WhatsAppMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type WhatsAppConversationCreateOrConnectWithoutCurrentAgentInput = {
    where: WhatsAppConversationWhereUniqueInput
    create: XOR<WhatsAppConversationCreateWithoutCurrentAgentInput, WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput>
  }

  export type WhatsAppConversationCreateManyCurrentAgentInputEnvelope = {
    data: WhatsAppConversationCreateManyCurrentAgentInput | WhatsAppConversationCreateManyCurrentAgentInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutAiAgentsInput = {
    update: XOR<OfficeUpdateWithoutAiAgentsInput, OfficeUncheckedUpdateWithoutAiAgentsInput>
    create: XOR<OfficeCreateWithoutAiAgentsInput, OfficeUncheckedCreateWithoutAiAgentsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutAiAgentsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutAiAgentsInput, OfficeUncheckedUpdateWithoutAiAgentsInput>
  }

  export type OfficeUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutAiAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type WhatsAppConversationUpsertWithWhereUniqueWithoutCurrentAgentInput = {
    where: WhatsAppConversationWhereUniqueInput
    update: XOR<WhatsAppConversationUpdateWithoutCurrentAgentInput, WhatsAppConversationUncheckedUpdateWithoutCurrentAgentInput>
    create: XOR<WhatsAppConversationCreateWithoutCurrentAgentInput, WhatsAppConversationUncheckedCreateWithoutCurrentAgentInput>
  }

  export type WhatsAppConversationUpdateWithWhereUniqueWithoutCurrentAgentInput = {
    where: WhatsAppConversationWhereUniqueInput
    data: XOR<WhatsAppConversationUpdateWithoutCurrentAgentInput, WhatsAppConversationUncheckedUpdateWithoutCurrentAgentInput>
  }

  export type WhatsAppConversationUpdateManyWithWhereWithoutCurrentAgentInput = {
    where: WhatsAppConversationScalarWhereInput
    data: XOR<WhatsAppConversationUpdateManyMutationInput, WhatsAppConversationUncheckedUpdateManyWithoutCurrentAgentInput>
  }

  export type OfficeCreateWithoutAiConfigsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutAiConfigsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutAiConfigsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutAiConfigsInput, OfficeUncheckedCreateWithoutAiConfigsInput>
  }

  export type OfficeUpsertWithoutAiConfigsInput = {
    update: XOR<OfficeUpdateWithoutAiConfigsInput, OfficeUncheckedUpdateWithoutAiConfigsInput>
    create: XOR<OfficeCreateWithoutAiConfigsInput, OfficeUncheckedCreateWithoutAiConfigsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutAiConfigsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutAiConfigsInput, OfficeUncheckedUpdateWithoutAiConfigsInput>
  }

  export type OfficeUpdateWithoutAiConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutAiConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type ClientCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutClientsInput
    conversations?: ConversationCreateNestedManyWithoutClientInput
    clientTags?: ClientTagCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutClientInput
    clientTags?: ClientTagUncheckedCreateNestedManyWithoutClientInput
    whatsappContacts?: WhatsAppContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDocumentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
  }

  export type OfficeCreateWithoutDocumentsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutDocumentsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutDocumentsInput, OfficeUncheckedCreateWithoutDocumentsInput>
  }

  export type ClientUpsertWithoutDocumentsInput = {
    update: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutClientsNestedInput
    conversations?: ConversationUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUncheckedUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type OfficeUpsertWithoutDocumentsInput = {
    update: XOR<OfficeUpdateWithoutDocumentsInput, OfficeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<OfficeCreateWithoutDocumentsInput, OfficeUncheckedCreateWithoutDocumentsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutDocumentsInput, OfficeUncheckedUpdateWithoutDocumentsInput>
  }

  export type OfficeUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeCreateWithoutToolsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutToolsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutToolsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutToolsInput, OfficeUncheckedCreateWithoutToolsInput>
  }

  export type UserCreateWithoutToolsCreatedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    logs?: AuditLogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutToolsCreatedInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    logs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutToolsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutToolsCreatedInput, UserUncheckedCreateWithoutToolsCreatedInput>
  }

  export type ToolExecutionCreateWithoutToolInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
    whatsappMessages?: WhatsAppMessageCreateNestedManyWithoutToolExecutionInput
  }

  export type ToolExecutionUncheckedCreateWithoutToolInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
    whatsappMessages?: WhatsAppMessageUncheckedCreateNestedManyWithoutToolExecutionInput
  }

  export type ToolExecutionCreateOrConnectWithoutToolInput = {
    where: ToolExecutionWhereUniqueInput
    create: XOR<ToolExecutionCreateWithoutToolInput, ToolExecutionUncheckedCreateWithoutToolInput>
  }

  export type ToolExecutionCreateManyToolInputEnvelope = {
    data: ToolExecutionCreateManyToolInput | ToolExecutionCreateManyToolInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutToolsInput = {
    update: XOR<OfficeUpdateWithoutToolsInput, OfficeUncheckedUpdateWithoutToolsInput>
    create: XOR<OfficeCreateWithoutToolsInput, OfficeUncheckedCreateWithoutToolsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutToolsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutToolsInput, OfficeUncheckedUpdateWithoutToolsInput>
  }

  export type OfficeUpdateWithoutToolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutToolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type UserUpsertWithoutToolsCreatedInput = {
    update: XOR<UserUpdateWithoutToolsCreatedInput, UserUncheckedUpdateWithoutToolsCreatedInput>
    create: XOR<UserCreateWithoutToolsCreatedInput, UserUncheckedCreateWithoutToolsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutToolsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutToolsCreatedInput, UserUncheckedUpdateWithoutToolsCreatedInput>
  }

  export type UserUpdateWithoutToolsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutToolsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type ToolExecutionUpsertWithWhereUniqueWithoutToolInput = {
    where: ToolExecutionWhereUniqueInput
    update: XOR<ToolExecutionUpdateWithoutToolInput, ToolExecutionUncheckedUpdateWithoutToolInput>
    create: XOR<ToolExecutionCreateWithoutToolInput, ToolExecutionUncheckedCreateWithoutToolInput>
  }

  export type ToolExecutionUpdateWithWhereUniqueWithoutToolInput = {
    where: ToolExecutionWhereUniqueInput
    data: XOR<ToolExecutionUpdateWithoutToolInput, ToolExecutionUncheckedUpdateWithoutToolInput>
  }

  export type ToolExecutionUpdateManyWithWhereWithoutToolInput = {
    where: ToolExecutionScalarWhereInput
    data: XOR<ToolExecutionUpdateManyMutationInput, ToolExecutionUncheckedUpdateManyWithoutToolInput>
  }

  export type ToolExecutionScalarWhereInput = {
    AND?: ToolExecutionScalarWhereInput | ToolExecutionScalarWhereInput[]
    OR?: ToolExecutionScalarWhereInput[]
    NOT?: ToolExecutionScalarWhereInput | ToolExecutionScalarWhereInput[]
    id?: StringFilter<"ToolExecution"> | string
    requestId?: StringFilter<"ToolExecution"> | string
    description?: StringFilter<"ToolExecution"> | string
    status?: EnumToolExecutionStatusFilter<"ToolExecution"> | $Enums.ToolExecutionStatus
    requestData?: JsonNullableFilter<"ToolExecution">
    responseData?: JsonNullableFilter<"ToolExecution">
    errorMessage?: StringNullableFilter<"ToolExecution"> | string | null
    startedAt?: DateTimeFilter<"ToolExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"ToolExecution"> | Date | string | null
    conversationId?: StringNullableFilter<"ToolExecution"> | string | null
    agentId?: StringNullableFilter<"ToolExecution"> | string | null
    toolId?: StringFilter<"ToolExecution"> | string
  }

  export type ToolCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutToolsInput
    createdBy: UserCreateNestedOneWithoutToolsCreatedInput
  }

  export type ToolUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    createdById: string
  }

  export type ToolCreateOrConnectWithoutExecutionsInput = {
    where: ToolWhereUniqueInput
    create: XOR<ToolCreateWithoutExecutionsInput, ToolUncheckedCreateWithoutExecutionsInput>
  }

  export type WhatsAppMessageCreateWithoutToolExecutionInput = {
    id?: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: WhatsAppInstanceCreateNestedOneWithoutMessagesInput
    conversation: WhatsAppConversationCreateNestedOneWithoutMessagesInput
    contact: WhatsAppContactCreateNestedOneWithoutMessagesInput
  }

  export type WhatsAppMessageUncheckedCreateWithoutToolExecutionInput = {
    id?: string
    instanceId: string
    conversationId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageCreateOrConnectWithoutToolExecutionInput = {
    where: WhatsAppMessageWhereUniqueInput
    create: XOR<WhatsAppMessageCreateWithoutToolExecutionInput, WhatsAppMessageUncheckedCreateWithoutToolExecutionInput>
  }

  export type WhatsAppMessageCreateManyToolExecutionInputEnvelope = {
    data: WhatsAppMessageCreateManyToolExecutionInput | WhatsAppMessageCreateManyToolExecutionInput[]
    skipDuplicates?: boolean
  }

  export type ToolUpsertWithoutExecutionsInput = {
    update: XOR<ToolUpdateWithoutExecutionsInput, ToolUncheckedUpdateWithoutExecutionsInput>
    create: XOR<ToolCreateWithoutExecutionsInput, ToolUncheckedCreateWithoutExecutionsInput>
    where?: ToolWhereInput
  }

  export type ToolUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: ToolWhereInput
    data: XOR<ToolUpdateWithoutExecutionsInput, ToolUncheckedUpdateWithoutExecutionsInput>
  }

  export type ToolUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutToolsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutToolsCreatedNestedInput
  }

  export type ToolUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppMessageUpsertWithWhereUniqueWithoutToolExecutionInput = {
    where: WhatsAppMessageWhereUniqueInput
    update: XOR<WhatsAppMessageUpdateWithoutToolExecutionInput, WhatsAppMessageUncheckedUpdateWithoutToolExecutionInput>
    create: XOR<WhatsAppMessageCreateWithoutToolExecutionInput, WhatsAppMessageUncheckedCreateWithoutToolExecutionInput>
  }

  export type WhatsAppMessageUpdateWithWhereUniqueWithoutToolExecutionInput = {
    where: WhatsAppMessageWhereUniqueInput
    data: XOR<WhatsAppMessageUpdateWithoutToolExecutionInput, WhatsAppMessageUncheckedUpdateWithoutToolExecutionInput>
  }

  export type WhatsAppMessageUpdateManyWithWhereWithoutToolExecutionInput = {
    where: WhatsAppMessageScalarWhereInput
    data: XOR<WhatsAppMessageUpdateManyMutationInput, WhatsAppMessageUncheckedUpdateManyWithoutToolExecutionInput>
  }

  export type OfficeCreateWithoutWebhooksInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutWebhooksInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutWebhooksInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutWebhooksInput, OfficeUncheckedCreateWithoutWebhooksInput>
  }

  export type WebhookExecutionCreateWithoutWebhookInput = {
    id?: string
    status: string
    requestBody: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: number | null
    executedAt?: Date | string
    attempt?: number
    error?: string | null
  }

  export type WebhookExecutionUncheckedCreateWithoutWebhookInput = {
    id?: string
    status: string
    requestBody: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: number | null
    executedAt?: Date | string
    attempt?: number
    error?: string | null
  }

  export type WebhookExecutionCreateOrConnectWithoutWebhookInput = {
    where: WebhookExecutionWhereUniqueInput
    create: XOR<WebhookExecutionCreateWithoutWebhookInput, WebhookExecutionUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookExecutionCreateManyWebhookInputEnvelope = {
    data: WebhookExecutionCreateManyWebhookInput | WebhookExecutionCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type OfficeUpsertWithoutWebhooksInput = {
    update: XOR<OfficeUpdateWithoutWebhooksInput, OfficeUncheckedUpdateWithoutWebhooksInput>
    create: XOR<OfficeCreateWithoutWebhooksInput, OfficeUncheckedCreateWithoutWebhooksInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutWebhooksInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutWebhooksInput, OfficeUncheckedUpdateWithoutWebhooksInput>
  }

  export type OfficeUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type WebhookExecutionUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookExecutionWhereUniqueInput
    update: XOR<WebhookExecutionUpdateWithoutWebhookInput, WebhookExecutionUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookExecutionCreateWithoutWebhookInput, WebhookExecutionUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookExecutionUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookExecutionWhereUniqueInput
    data: XOR<WebhookExecutionUpdateWithoutWebhookInput, WebhookExecutionUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookExecutionUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookExecutionScalarWhereInput
    data: XOR<WebhookExecutionUpdateManyMutationInput, WebhookExecutionUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookExecutionScalarWhereInput = {
    AND?: WebhookExecutionScalarWhereInput | WebhookExecutionScalarWhereInput[]
    OR?: WebhookExecutionScalarWhereInput[]
    NOT?: WebhookExecutionScalarWhereInput | WebhookExecutionScalarWhereInput[]
    id?: StringFilter<"WebhookExecution"> | string
    status?: StringFilter<"WebhookExecution"> | string
    requestBody?: JsonFilter<"WebhookExecution">
    responseBody?: JsonNullableFilter<"WebhookExecution">
    responseCode?: IntNullableFilter<"WebhookExecution"> | number | null
    executedAt?: DateTimeFilter<"WebhookExecution"> | Date | string
    attempt?: IntFilter<"WebhookExecution"> | number
    error?: StringNullableFilter<"WebhookExecution"> | string | null
    webhookId?: StringFilter<"WebhookExecution"> | string
  }

  export type WebhookCreateWithoutExecutionsInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    office: OfficeCreateNestedOneWithoutWebhooksInput
  }

  export type WebhookUncheckedCreateWithoutExecutionsInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type WebhookCreateOrConnectWithoutExecutionsInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutExecutionsInput, WebhookUncheckedCreateWithoutExecutionsInput>
  }

  export type WebhookUpsertWithoutExecutionsInput = {
    update: XOR<WebhookUpdateWithoutExecutionsInput, WebhookUncheckedUpdateWithoutExecutionsInput>
    create: XOR<WebhookCreateWithoutExecutionsInput, WebhookUncheckedCreateWithoutExecutionsInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutExecutionsInput, WebhookUncheckedUpdateWithoutExecutionsInput>
  }

  export type WebhookUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type WebhookUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    office?: OfficeCreateNestedOneWithoutUsersInput
    createdConversations?: ConversationCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationCreateNestedManyWithoutAssigneeInput
    messages?: MessageCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    toolsCreated?: ToolCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationCreateNestedManyWithoutAssignedUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId?: string | null
    createdConversations?: ConversationUncheckedCreateNestedManyWithoutCreatorInput
    assignedConversations?: ConversationUncheckedCreateNestedManyWithoutAssigneeInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    toolsCreated?: ToolUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedCreateNestedManyWithoutCreatedByInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedCreateNestedManyWithoutUploadedByInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedCreateNestedManyWithoutAssignedUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type OfficeCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOfficeInput
    clients?: ClientCreateNestedManyWithoutOfficeInput
    conversations?: ConversationCreateNestedManyWithoutOfficeInput
    tags?: TagCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigCreateNestedManyWithoutOfficeInput
    documents?: DocumentCreateNestedManyWithoutOfficeInput
    tools?: ToolCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceCreateNestedManyWithoutOfficeInput
  }

  export type OfficeUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    cnpj?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOfficeInput
    clients?: ClientUncheckedCreateNestedManyWithoutOfficeInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutOfficeInput
    tags?: TagUncheckedCreateNestedManyWithoutOfficeInput
    customStatuses?: CustomStatusUncheckedCreateNestedManyWithoutOfficeInput
    aiAgents?: AiAgentUncheckedCreateNestedManyWithoutOfficeInput
    whatsappConfigs?: WhatsappConfigUncheckedCreateNestedManyWithoutOfficeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOfficeInput
    tools?: ToolUncheckedCreateNestedManyWithoutOfficeInput
    webhooks?: WebhookUncheckedCreateNestedManyWithoutOfficeInput
    aiConfigs?: AIProviderConfigUncheckedCreateNestedManyWithoutOfficeInput
    whatsappInstances?: WhatsAppInstanceUncheckedCreateNestedManyWithoutOfficeInput
  }

  export type OfficeCreateOrConnectWithoutAuditLogsInput = {
    where: OfficeWhereUniqueInput
    create: XOR<OfficeCreateWithoutAuditLogsInput, OfficeUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneWithoutUsersNestedInput
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type OfficeUpsertWithoutAuditLogsInput = {
    update: XOR<OfficeUpdateWithoutAuditLogsInput, OfficeUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<OfficeCreateWithoutAuditLogsInput, OfficeUncheckedCreateWithoutAuditLogsInput>
    where?: OfficeWhereInput
  }

  export type OfficeUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: OfficeWhereInput
    data: XOR<OfficeUpdateWithoutAuditLogsInput, OfficeUncheckedUpdateWithoutAuditLogsInput>
  }

  export type OfficeUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOfficeNestedInput
    clients?: ClientUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUpdateManyWithoutOfficeNestedInput
    tags?: TagUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUpdateManyWithoutOfficeNestedInput
    tools?: ToolUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUpdateManyWithoutOfficeNestedInput
  }

  export type OfficeUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOfficeNestedInput
    clients?: ClientUncheckedUpdateManyWithoutOfficeNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutOfficeNestedInput
    tags?: TagUncheckedUpdateManyWithoutOfficeNestedInput
    customStatuses?: CustomStatusUncheckedUpdateManyWithoutOfficeNestedInput
    aiAgents?: AiAgentUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappConfigs?: WhatsappConfigUncheckedUpdateManyWithoutOfficeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOfficeNestedInput
    tools?: ToolUncheckedUpdateManyWithoutOfficeNestedInput
    webhooks?: WebhookUncheckedUpdateManyWithoutOfficeNestedInput
    aiConfigs?: AIProviderConfigUncheckedUpdateManyWithoutOfficeNestedInput
    whatsappInstances?: WhatsAppInstanceUncheckedUpdateManyWithoutOfficeNestedInput
  }

  export type ConversationCreateManyCreatorInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
  }

  export type ConversationCreateManyAssigneeInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    whatsappConfigId?: string | null
  }

  export type MessageCreateManyUserInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    whatsappConfigId?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    officeId: string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type ToolCreateManyCreatedByInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type WhatsAppInstanceCreateManyCreatedByInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    officeId: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportCreateManyUploadedByInput = {
    id?: string
    instanceId: string
    contactId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppConversationCreateManyAssignedUserInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutMessagesNestedInput
    audioTranscription?: AudioTranscriptionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    audioTranscription?: AudioTranscriptionUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutToolsNestedInput
    executions?: ToolExecutionUpdateManyWithoutToolNestedInput
  }

  export type ToolUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    executions?: ToolExecutionUncheckedUpdateManyWithoutToolNestedInput
  }

  export type ToolUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppInstanceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutWhatsappInstancesNestedInput
    contacts?: WhatsAppContactUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: WhatsAppContactUncheckedUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    officeId?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutImportsNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutImportsNestedInput
  }

  export type WhatsAppImportUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppConversationUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutConversationsNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutConversationsNestedInput
    currentAgent?: AiAgentUpdateOneWithoutWhatsappConversationsNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyOfficeInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateManyOfficeInput = {
    id?: string
    name?: string | null
    phone: string
    email?: string | null
    document?: string | null
    notes?: string | null
    isLead?: boolean
    dateOfBirth?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyOfficeInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
  }

  export type TagCreateManyOfficeInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomStatusCreateManyOfficeInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiAgentCreateManyOfficeInput = {
    id?: string
    name: string
    type: $Enums.AgentType
    prompt: string
    model: string
    provider: $Enums.AIProvider
    aiModel: $Enums.AIModel
    temperature?: number
    maxTokens?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappConfigCreateManyOfficeInput = {
    id?: string
    instanceId: string
    phone: string
    qrCode?: string | null
    isActive?: boolean
    apiUrl?: string | null
    apiKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyOfficeInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
  }

  export type ToolCreateManyOfficeInput = {
    id?: string
    name: string
    description: string
    webhookUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type WebhookCreateManyOfficeInput = {
    id?: string
    name: string
    url: string
    secret?: string | null
    isActive?: boolean
    description?: string | null
    retryCount?: number
    timeoutMs?: number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyOfficeInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    userId?: string | null
  }

  export type AIProviderConfigCreateManyOfficeInput = {
    id?: string
    provider: $Enums.AIProvider
    apiKey: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppInstanceCreateManyOfficeInput = {
    id?: string
    name: string
    phoneNumber?: string | null
    status?: $Enums.WhatsAppInstanceStatus
    qrCode?: string | null
    webhookUrl?: string | null
    createdById: string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdConversations?: ConversationUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    logs?: AuditLogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdConversations?: ConversationUncheckedUpdateManyWithoutCreatorNestedInput
    assignedConversations?: ConversationUncheckedUpdateManyWithoutAssigneeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    logs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    toolsCreated?: ToolUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappInstancesCreated?: WhatsAppInstanceUncheckedUpdateManyWithoutCreatedByNestedInput
    whatsappImportsUploaded?: WhatsAppImportUncheckedUpdateManyWithoutUploadedByNestedInput
    whatsappConversationsAssigned?: WhatsAppConversationUncheckedUpdateManyWithoutAssignedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutClientNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutClientNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
    clientTags?: ClientTagUncheckedUpdateManyWithoutClientNestedInput
    whatsappContacts?: WhatsAppContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isLead?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientTags?: ClientTagUpdateManyWithoutTagNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientTags?: ClientTagUncheckedUpdateManyWithoutTagNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomStatusUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationStatuses?: ConversationCustomStatusUpdateManyWithoutCustomStatusNestedInput
  }

  export type CustomStatusUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationStatuses?: ConversationCustomStatusUncheckedUpdateManyWithoutCustomStatusNestedInput
  }

  export type CustomStatusUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiAgentUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappConversations?: WhatsAppConversationUpdateManyWithoutCurrentAgentNestedInput
  }

  export type AiAgentUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappConversations?: WhatsAppConversationUncheckedUpdateManyWithoutCurrentAgentNestedInput
  }

  export type AiAgentUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    prompt?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    aiModel?: EnumAIModelFieldUpdateOperationsInput | $Enums.AIModel
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappConfigUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutWhatsappConfigNestedInput
    messages?: MessageUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type WhatsappConfigUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutWhatsappConfigNestedInput
    messages?: MessageUncheckedUpdateManyWithoutWhatsappConfigNestedInput
  }

  export type WhatsappConfigUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type ToolUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutToolsCreatedNestedInput
    executions?: ToolExecutionUpdateManyWithoutToolNestedInput
  }

  export type ToolUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    executions?: ToolExecutionUncheckedUpdateManyWithoutToolNestedInput
  }

  export type ToolUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: WebhookExecutionUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: WebhookExecutionUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    timeoutMs?: IntFieldUpdateOperationsInput | number
    headers?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIProviderConfigUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    apiKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderConfigUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    apiKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderConfigUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAIProviderFieldUpdateOperationsInput | $Enums.AIProvider
    apiKey?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppInstanceUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutWhatsappInstancesCreatedNestedInput
    contacts?: WhatsAppContactUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: WhatsAppContactUncheckedUpdateManyWithoutInstanceNestedInput
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutInstanceNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutInstanceNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WhatsAppInstanceUncheckedUpdateManyWithoutOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppInstanceStatusFieldUpdateOperationsInput | $Enums.WhatsAppInstanceStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    connectionData?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyWhatsappConfigInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    officeId: string
    createdBy: string
    assignedTo?: string | null
  }

  export type MessageCreateManyWhatsappConfigInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId: string
    userId?: string | null
  }

  export type ConversationUpdateWithoutWhatsappConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutConversationsNestedInput
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutWhatsappConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutWhatsappConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutWhatsappConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutMessagesNestedInput
    audioTranscription?: AudioTranscriptionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutWhatsappConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    audioTranscription?: AudioTranscriptionUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutWhatsappConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppContactCreateManyInstanceInput = {
    id?: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    clientId?: string | null
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppConversationCreateManyInstanceInput = {
    id?: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageCreateManyInstanceInput = {
    id?: string
    conversationId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportCreateManyInstanceInput = {
    id?: string
    contactId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    uploadedById: string
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppContactUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutWhatsappContactsNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppConversationUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: WhatsAppContactUpdateOneRequiredWithoutConversationsNestedInput
    assignedUser?: UserUpdateOneWithoutWhatsappConversationsAssignedNestedInput
    currentAgent?: AiAgentUpdateOneWithoutWhatsappConversationsNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: WhatsAppConversationUpdateOneRequiredWithoutMessagesNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutMessagesNestedInput
    toolExecution?: ToolExecutionUpdateOneWithoutWhatsappMessagesNestedInput
  }

  export type WhatsAppMessageUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: WhatsAppContactUpdateOneRequiredWithoutImportsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutWhatsappImportsUploadedNestedInput
  }

  export type WhatsAppImportUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppConversationCreateManyContactInput = {
    id?: string
    instanceId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    currentAgentId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageCreateManyContactInput = {
    id?: string
    instanceId: string
    conversationId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppImportCreateManyContactInput = {
    id?: string
    instanceId: string
    fileName: string
    fileSize: number
    totalMessages?: number
    importedMessages?: number
    failedMessages?: number
    mediaFiles?: WhatsAppImportCreatemediaFilesInput | string[]
    status?: $Enums.WhatsAppImportStatus
    errorMessage?: string | null
    uploadedById: string
    importedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppConversationUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutConversationsNestedInput
    assignedUser?: UserUpdateOneWithoutWhatsappConversationsAssignedNestedInput
    currentAgent?: AiAgentUpdateOneWithoutWhatsappConversationsNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    currentAgentId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: WhatsAppConversationUpdateOneRequiredWithoutMessagesNestedInput
    toolExecution?: ToolExecutionUpdateOneWithoutWhatsappMessagesNestedInput
  }

  export type WhatsAppMessageUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutImportsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutWhatsappImportsUploadedNestedInput
  }

  export type WhatsAppImportUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppImportUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    totalMessages?: IntFieldUpdateOperationsInput | number
    importedMessages?: IntFieldUpdateOperationsInput | number
    failedMessages?: IntFieldUpdateOperationsInput | number
    mediaFiles?: WhatsAppImportUpdatemediaFilesInput | string[]
    status?: EnumWhatsAppImportStatusFieldUpdateOperationsInput | $Enums.WhatsAppImportStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    importedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageCreateManyConversationInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    toolExecutionId?: string | null
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutMessagesNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutMessagesNestedInput
    toolExecution?: ToolExecutionUpdateOneWithoutWhatsappMessagesNestedInput
  }

  export type WhatsAppMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    toolExecutionId?: NullableStringFieldUpdateOperationsInput | string | null
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyClientInput = {
    id?: string
    title?: string | null
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: $Enums.AgentType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
    createdBy: string
    assignedTo?: string | null
    whatsappConfigId?: string | null
  }

  export type DocumentCreateManyClientInput = {
    id?: string
    name: string
    originalName: string
    mimeType: string
    size: number
    url: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeId: string
  }

  export type ClientTagCreateManyClientInput = {
    id?: string
    createdAt?: Date | string
    tagId: string
  }

  export type WhatsAppContactCreateManyClientInput = {
    id?: string
    instanceId: string
    remoteJid: string
    phoneNumber: string
    name?: string | null
    pushName?: string | null
    profilePicUrl?: string | null
    isGroup?: boolean
    lastSeen?: Date | string | null
    isBlocked?: boolean
    tags?: WhatsAppContactCreatetagsInput | string[]
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutConversationsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedConversationsNestedInput
    assignee?: UserUpdateOneWithoutAssignedConversationsNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    conversationTags?: ConversationTagUncheckedUpdateManyWithoutConversationNestedInput
    conversationStatus?: ConversationCustomStatusUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    currentAgentType?: NullableEnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    office?: OfficeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientTagUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutClientTagsNestedInput
  }

  export type ClientTagUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientTagUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppContactUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutContactsNestedInput
    conversations?: WhatsAppConversationUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: WhatsAppConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutContactNestedInput
    imports?: WhatsAppImportUncheckedUpdateManyWithoutContactNestedInput
  }

  export type WhatsAppContactUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlocked?: BoolFieldUpdateOperationsInput | boolean
    tags?: WhatsAppContactUpdatetagsInput | string[]
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    content?: string | null
    type?: $Enums.MessageType
    isFromClient?: boolean
    isFromAI?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    mediaUrl?: string | null
    transcription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    whatsappConfigId?: string | null
  }

  export type ConversationTagCreateManyConversationInput = {
    id?: string
    createdAt?: Date | string
    tagId: string
  }

  export type ConversationCustomStatusCreateManyConversationInput = {
    id?: string
    createdAt?: Date | string
    customStatusId: string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMessagesNestedInput
    whatsappConfig?: WhatsappConfigUpdateOneWithoutMessagesNestedInput
    audioTranscription?: AudioTranscriptionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    audioTranscription?: AudioTranscriptionUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isFromClient?: BoolFieldUpdateOperationsInput | boolean
    isFromAI?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappConfigId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationTagUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutConversationTagsNestedInput
  }

  export type ConversationTagUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationTagUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCustomStatusUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customStatus?: CustomStatusUpdateOneRequiredWithoutConversationStatusesNestedInput
  }

  export type ConversationCustomStatusUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCustomStatusUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customStatusId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientTagCreateManyTagInput = {
    id?: string
    createdAt?: Date | string
    clientId: string
  }

  export type ConversationTagCreateManyTagInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
  }

  export type ClientTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientTagsNestedInput
  }

  export type ClientTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutConversationTagsNestedInput
  }

  export type ConversationTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCustomStatusCreateManyCustomStatusInput = {
    id?: string
    createdAt?: Date | string
    conversationId: string
  }

  export type ConversationCustomStatusUpdateWithoutCustomStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutConversationStatusNestedInput
  }

  export type ConversationCustomStatusUncheckedUpdateWithoutCustomStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCustomStatusUncheckedUpdateManyWithoutCustomStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppConversationCreateManyCurrentAgentInput = {
    id?: string
    instanceId: string
    contactId: string
    remoteJid: string
    title?: string | null
    isGroup?: boolean
    lastMessageId?: string | null
    lastMessageAt?: Date | string | null
    unreadCount?: number
    isArchived?: boolean
    isPinned?: boolean
    assignedUserId?: string | null
    status?: $Enums.WhatsAppConversationStatus
    aiEnabled?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppConversationUpdateWithoutCurrentAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutConversationsNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutConversationsNestedInput
    assignedUser?: UserUpdateOneWithoutWhatsappConversationsAssignedNestedInput
    messages?: WhatsAppMessageUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateWithoutCurrentAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: WhatsAppMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type WhatsAppConversationUncheckedUpdateManyWithoutCurrentAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    lastMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadCount?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWhatsAppConversationStatusFieldUpdateOperationsInput | $Enums.WhatsAppConversationStatus
    aiEnabled?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ToolExecutionCreateManyToolInput = {
    id?: string
    requestId: string
    description: string
    status?: $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    conversationId?: string | null
    agentId?: string | null
  }

  export type ToolExecutionUpdateWithoutToolInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessages?: WhatsAppMessageUpdateManyWithoutToolExecutionNestedInput
  }

  export type ToolExecutionUncheckedUpdateWithoutToolInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessages?: WhatsAppMessageUncheckedUpdateManyWithoutToolExecutionNestedInput
  }

  export type ToolExecutionUncheckedUpdateManyWithoutToolInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumToolExecutionStatusFieldUpdateOperationsInput | $Enums.ToolExecutionStatus
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhatsAppMessageCreateManyToolExecutionInput = {
    id?: string
    instanceId: string
    conversationId: string
    contactId: string
    remoteJid: string
    messageId: string
    fromMe: boolean
    messageType: $Enums.WhatsAppMessageType
    content?: string | null
    quotedMessageId?: string | null
    mediaUrl?: string | null
    mediaSize?: number | null
    mimetype?: string | null
    fileName?: string | null
    caption?: string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: boolean
    timestamp: Date | string
    status?: $Enums.WhatsAppMessageStatus
    isDeleted?: boolean
    isEdited?: boolean
    aiResponse?: boolean
    importedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageUpdateWithoutToolExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: WhatsAppInstanceUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: WhatsAppConversationUpdateOneRequiredWithoutMessagesNestedInput
    contact?: WhatsAppContactUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type WhatsAppMessageUncheckedUpdateWithoutToolExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageUncheckedUpdateManyWithoutToolExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    messageType?: EnumWhatsAppMessageTypeFieldUpdateOperationsInput | $Enums.WhatsAppMessageType
    content?: NullableStringFieldUpdateOperationsInput | string | null
    quotedMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimetype?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableJsonNullValueInput | InputJsonValue
    isForwarded?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWhatsAppMessageStatusFieldUpdateOperationsInput | $Enums.WhatsAppMessageStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    aiResponse?: BoolFieldUpdateOperationsInput | boolean
    importedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookExecutionCreateManyWebhookInput = {
    id?: string
    status: string
    requestBody: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: number | null
    executedAt?: Date | string
    attempt?: number
    error?: string | null
  }

  export type WebhookExecutionUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestBody?: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookExecutionUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestBody?: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WebhookExecutionUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestBody?: JsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    responseCode?: NullableIntFieldUpdateOperationsInput | number | null
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}